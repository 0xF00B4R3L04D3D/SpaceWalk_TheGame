\hypertarget{gmock-actions_8h_source}{}\doxysection{gmock-\/actions.h}
\label{gmock-actions_8h_source}\index{build/\_deps/googletest-\/src/googlemock/include/gmock/gmock-\/actions.h@{build/\_deps/googletest-\/src/googlemock/include/gmock/gmock-\/actions.h}}

\begin{DoxyCode}{0}
\DoxyCodeLine{1 \textcolor{comment}{// Copyright 2007, Google Inc.}}
\DoxyCodeLine{2 \textcolor{comment}{// All rights reserved.}}
\DoxyCodeLine{3 \textcolor{comment}{//}}
\DoxyCodeLine{4 \textcolor{comment}{// Redistribution and use in source and binary forms, with or without}}
\DoxyCodeLine{5 \textcolor{comment}{// modification, are permitted provided that the following conditions are}}
\DoxyCodeLine{6 \textcolor{comment}{// met:}}
\DoxyCodeLine{7 \textcolor{comment}{//}}
\DoxyCodeLine{8 \textcolor{comment}{//     * Redistributions of source code must retain the above copyright}}
\DoxyCodeLine{9 \textcolor{comment}{// notice, this list of conditions and the following disclaimer.}}
\DoxyCodeLine{10 \textcolor{comment}{//     * Redistributions in binary form must reproduce the above}}
\DoxyCodeLine{11 \textcolor{comment}{// copyright notice, this list of conditions and the following disclaimer}}
\DoxyCodeLine{12 \textcolor{comment}{// in the documentation and/or other materials provided with the}}
\DoxyCodeLine{13 \textcolor{comment}{// distribution.}}
\DoxyCodeLine{14 \textcolor{comment}{//     * Neither the name of Google Inc. nor the names of its}}
\DoxyCodeLine{15 \textcolor{comment}{// contributors may be used to endorse or promote products derived from}}
\DoxyCodeLine{16 \textcolor{comment}{// this software without specific prior written permission.}}
\DoxyCodeLine{17 \textcolor{comment}{//}}
\DoxyCodeLine{18 \textcolor{comment}{// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS}}
\DoxyCodeLine{19 \textcolor{comment}{// "{}AS IS"{} AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT}}
\DoxyCodeLine{20 \textcolor{comment}{// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR}}
\DoxyCodeLine{21 \textcolor{comment}{// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT}}
\DoxyCodeLine{22 \textcolor{comment}{// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,}}
\DoxyCodeLine{23 \textcolor{comment}{// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT}}
\DoxyCodeLine{24 \textcolor{comment}{// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,}}
\DoxyCodeLine{25 \textcolor{comment}{// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY}}
\DoxyCodeLine{26 \textcolor{comment}{// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT}}
\DoxyCodeLine{27 \textcolor{comment}{// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE}}
\DoxyCodeLine{28 \textcolor{comment}{// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.}}
\DoxyCodeLine{29 }
\DoxyCodeLine{30 \textcolor{comment}{// Google Mock -\/ a framework for writing C++ mock classes.}}
\DoxyCodeLine{31 \textcolor{comment}{//}}
\DoxyCodeLine{32 \textcolor{comment}{// The ACTION* family of macros can be used in a namespace scope to}}
\DoxyCodeLine{33 \textcolor{comment}{// define custom actions easily.  The syntax:}}
\DoxyCodeLine{34 \textcolor{comment}{//}}
\DoxyCodeLine{35 \textcolor{comment}{//   ACTION(name) \{ statements; \}}}
\DoxyCodeLine{36 \textcolor{comment}{//}}
\DoxyCodeLine{37 \textcolor{comment}{// will define an action with the given name that executes the}}
\DoxyCodeLine{38 \textcolor{comment}{// statements.  The value returned by the statements will be used as}}
\DoxyCodeLine{39 \textcolor{comment}{// the return value of the action.  Inside the statements, you can}}
\DoxyCodeLine{40 \textcolor{comment}{// refer to the K-\/th (0-\/based) argument of the mock function by}}
\DoxyCodeLine{41 \textcolor{comment}{// 'argK', and refer to its type by 'argK\_type'.  For example:}}
\DoxyCodeLine{42 \textcolor{comment}{//}}
\DoxyCodeLine{43 \textcolor{comment}{//   ACTION(IncrementArg1) \{}}
\DoxyCodeLine{44 \textcolor{comment}{//     arg1\_type temp = arg1;}}
\DoxyCodeLine{45 \textcolor{comment}{//     return ++(*temp);}}
\DoxyCodeLine{46 \textcolor{comment}{//   \}}}
\DoxyCodeLine{47 \textcolor{comment}{//}}
\DoxyCodeLine{48 \textcolor{comment}{// allows you to write}}
\DoxyCodeLine{49 \textcolor{comment}{//}}
\DoxyCodeLine{50 \textcolor{comment}{//   ...WillOnce(IncrementArg1());}}
\DoxyCodeLine{51 \textcolor{comment}{//}}
\DoxyCodeLine{52 \textcolor{comment}{// You can also refer to the entire argument tuple and its type by}}
\DoxyCodeLine{53 \textcolor{comment}{// 'args' and 'args\_type', and refer to the mock function type and its}}
\DoxyCodeLine{54 \textcolor{comment}{// return type by 'function\_type' and 'return\_type'.}}
\DoxyCodeLine{55 \textcolor{comment}{//}}
\DoxyCodeLine{56 \textcolor{comment}{// Note that you don't need to specify the types of the mock function}}
\DoxyCodeLine{57 \textcolor{comment}{// arguments.  However rest assured that your code is still type-\/safe:}}
\DoxyCodeLine{58 \textcolor{comment}{// you'll get a compiler error if *arg1 doesn't support the ++}}
\DoxyCodeLine{59 \textcolor{comment}{// operator, or if the type of ++(*arg1) isn't compatible with the}}
\DoxyCodeLine{60 \textcolor{comment}{// mock function's return type, for example.}}
\DoxyCodeLine{61 \textcolor{comment}{//}}
\DoxyCodeLine{62 \textcolor{comment}{// Sometimes you'll want to parameterize the action.   For that you can use}}
\DoxyCodeLine{63 \textcolor{comment}{// another macro:}}
\DoxyCodeLine{64 \textcolor{comment}{//}}
\DoxyCodeLine{65 \textcolor{comment}{//   ACTION\_P(name, param\_name) \{ statements; \}}}
\DoxyCodeLine{66 \textcolor{comment}{//}}
\DoxyCodeLine{67 \textcolor{comment}{// For example:}}
\DoxyCodeLine{68 \textcolor{comment}{//}}
\DoxyCodeLine{69 \textcolor{comment}{//   ACTION\_P(Add, n) \{ return arg0 + n; \}}}
\DoxyCodeLine{70 \textcolor{comment}{//}}
\DoxyCodeLine{71 \textcolor{comment}{// will allow you to write:}}
\DoxyCodeLine{72 \textcolor{comment}{//}}
\DoxyCodeLine{73 \textcolor{comment}{//   ...WillOnce(Add(5));}}
\DoxyCodeLine{74 \textcolor{comment}{//}}
\DoxyCodeLine{75 \textcolor{comment}{// Note that you don't need to provide the type of the parameter}}
\DoxyCodeLine{76 \textcolor{comment}{// either.  If you need to reference the type of a parameter named}}
\DoxyCodeLine{77 \textcolor{comment}{// 'foo', you can write 'foo\_type'.  For example, in the body of}}
\DoxyCodeLine{78 \textcolor{comment}{// ACTION\_P(Add, n) above, you can write 'n\_type' to refer to the type}}
\DoxyCodeLine{79 \textcolor{comment}{// of 'n'.}}
\DoxyCodeLine{80 \textcolor{comment}{//}}
\DoxyCodeLine{81 \textcolor{comment}{// We also provide ACTION\_P2, ACTION\_P3, ..., up to ACTION\_P10 to support}}
\DoxyCodeLine{82 \textcolor{comment}{// multi-\/parameter actions.}}
\DoxyCodeLine{83 \textcolor{comment}{//}}
\DoxyCodeLine{84 \textcolor{comment}{// For the purpose of typing, you can view}}
\DoxyCodeLine{85 \textcolor{comment}{//}}
\DoxyCodeLine{86 \textcolor{comment}{//   ACTION\_Pk(Foo, p1, ..., pk) \{ ... \}}}
\DoxyCodeLine{87 \textcolor{comment}{//}}
\DoxyCodeLine{88 \textcolor{comment}{// as shorthand for}}
\DoxyCodeLine{89 \textcolor{comment}{//}}
\DoxyCodeLine{90 \textcolor{comment}{//   template <typename p1\_type, ..., typename pk\_type>}}
\DoxyCodeLine{91 \textcolor{comment}{//   FooActionPk<p1\_type, ..., pk\_type> Foo(p1\_type p1, ..., pk\_type pk) \{ ... \}}}
\DoxyCodeLine{92 \textcolor{comment}{//}}
\DoxyCodeLine{93 \textcolor{comment}{// In particular, you can provide the template type arguments}}
\DoxyCodeLine{94 \textcolor{comment}{// explicitly when invoking Foo(), as in Foo<long, bool>(5, false);}}
\DoxyCodeLine{95 \textcolor{comment}{// although usually you can rely on the compiler to infer the types}}
\DoxyCodeLine{96 \textcolor{comment}{// for you automatically.  You can assign the result of expression}}
\DoxyCodeLine{97 \textcolor{comment}{// Foo(p1, ..., pk) to a variable of type FooActionPk<p1\_type, ...,}}
\DoxyCodeLine{98 \textcolor{comment}{// pk\_type>.  This can be useful when composing actions.}}
\DoxyCodeLine{99 \textcolor{comment}{//}}
\DoxyCodeLine{100 \textcolor{comment}{// You can also overload actions with different numbers of parameters:}}
\DoxyCodeLine{101 \textcolor{comment}{//}}
\DoxyCodeLine{102 \textcolor{comment}{//   ACTION\_P(Plus, a) \{ ... \}}}
\DoxyCodeLine{103 \textcolor{comment}{//   ACTION\_P2(Plus, a, b) \{ ... \}}}
\DoxyCodeLine{104 \textcolor{comment}{//}}
\DoxyCodeLine{105 \textcolor{comment}{// While it's tempting to always use the ACTION* macros when defining}}
\DoxyCodeLine{106 \textcolor{comment}{// a new action, you should also consider implementing ActionInterface}}
\DoxyCodeLine{107 \textcolor{comment}{// or using MakePolymorphicAction() instead, especially if you need to}}
\DoxyCodeLine{108 \textcolor{comment}{// use the action a lot.  While these approaches require more work,}}
\DoxyCodeLine{109 \textcolor{comment}{// they give you more control on the types of the mock function}}
\DoxyCodeLine{110 \textcolor{comment}{// arguments and the action parameters, which in general leads to}}
\DoxyCodeLine{111 \textcolor{comment}{// better compiler error messages that pay off in the long run.  They}}
\DoxyCodeLine{112 \textcolor{comment}{// also allow overloading actions based on parameter types (as opposed}}
\DoxyCodeLine{113 \textcolor{comment}{// to just based on the number of parameters).}}
\DoxyCodeLine{114 \textcolor{comment}{//}}
\DoxyCodeLine{115 \textcolor{comment}{// CAVEAT:}}
\DoxyCodeLine{116 \textcolor{comment}{//}}
\DoxyCodeLine{117 \textcolor{comment}{// ACTION*() can only be used in a namespace scope as templates cannot be}}
\DoxyCodeLine{118 \textcolor{comment}{// declared inside of a local class.}}
\DoxyCodeLine{119 \textcolor{comment}{// Users can, however, define any local functors (e.g. a lambda) that}}
\DoxyCodeLine{120 \textcolor{comment}{// can be used as actions.}}
\DoxyCodeLine{121 \textcolor{comment}{//}}
\DoxyCodeLine{122 \textcolor{comment}{// MORE INFORMATION:}}
\DoxyCodeLine{123 \textcolor{comment}{//}}
\DoxyCodeLine{124 \textcolor{comment}{// To learn more about using these macros, please search for 'ACTION' on}}
\DoxyCodeLine{125 \textcolor{comment}{// https://github.com/google/googletest/blob/master/docs/gmock\_cook\_book.md}}
\DoxyCodeLine{126 }
\DoxyCodeLine{127 \textcolor{comment}{// IWYU pragma: private, include "{}gmock/gmock.h"{}}}
\DoxyCodeLine{128 \textcolor{comment}{// IWYU pragma: friend gmock/.*}}
\DoxyCodeLine{129 }
\DoxyCodeLine{130 \textcolor{preprocessor}{\#ifndef GOOGLEMOCK\_INCLUDE\_GMOCK\_GMOCK\_ACTIONS\_H\_}}
\DoxyCodeLine{131 \textcolor{preprocessor}{\#define GOOGLEMOCK\_INCLUDE\_GMOCK\_GMOCK\_ACTIONS\_H\_}}
\DoxyCodeLine{132 }
\DoxyCodeLine{133 \textcolor{preprocessor}{\#ifndef \_WIN32\_WCE}}
\DoxyCodeLine{134 \textcolor{preprocessor}{\#include <errno.h>}}
\DoxyCodeLine{135 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{136 }
\DoxyCodeLine{137 \textcolor{preprocessor}{\#include <algorithm>}}
\DoxyCodeLine{138 \textcolor{preprocessor}{\#include <functional>}}
\DoxyCodeLine{139 \textcolor{preprocessor}{\#include <memory>}}
\DoxyCodeLine{140 \textcolor{preprocessor}{\#include <string>}}
\DoxyCodeLine{141 \textcolor{preprocessor}{\#include <tuple>}}
\DoxyCodeLine{142 \textcolor{preprocessor}{\#include <type\_traits>}}
\DoxyCodeLine{143 \textcolor{preprocessor}{\#include <utility>}}
\DoxyCodeLine{144 }
\DoxyCodeLine{145 \textcolor{preprocessor}{\#include "{}gmock/internal/gmock-\/internal-\/utils.h"{}}}
\DoxyCodeLine{146 \textcolor{preprocessor}{\#include "{}gmock/internal/gmock-\/port.h"{}}}
\DoxyCodeLine{147 \textcolor{preprocessor}{\#include "{}gmock/internal/gmock-\/pp.h"{}}}
\DoxyCodeLine{148 }
\DoxyCodeLine{149 \textcolor{preprocessor}{\#ifdef \_MSC\_VER}}
\DoxyCodeLine{150 \textcolor{preprocessor}{\#pragma warning(push)}}
\DoxyCodeLine{151 \textcolor{preprocessor}{\#pragma warning(disable : 4100)}}
\DoxyCodeLine{152 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{153 }
\DoxyCodeLine{154 \textcolor{keyword}{namespace }testing \{}
\DoxyCodeLine{155 }
\DoxyCodeLine{156 \textcolor{comment}{// To implement an action Foo, define:}}
\DoxyCodeLine{157 \textcolor{comment}{//   1. a class FooAction that implements the ActionInterface interface, and}}
\DoxyCodeLine{158 \textcolor{comment}{//   2. a factory function that creates an Action object from a}}
\DoxyCodeLine{159 \textcolor{comment}{//      const FooAction*.}}
\DoxyCodeLine{160 \textcolor{comment}{//}}
\DoxyCodeLine{161 \textcolor{comment}{// The two-\/level delegation design follows that of Matcher, providing}}
\DoxyCodeLine{162 \textcolor{comment}{// consistency for extension developers.  It also eases ownership}}
\DoxyCodeLine{163 \textcolor{comment}{// management as Action objects can now be copied like plain values.}}
\DoxyCodeLine{164 }
\DoxyCodeLine{165 \textcolor{keyword}{namespace }internal \{}
\DoxyCodeLine{166 }
\DoxyCodeLine{167 \textcolor{comment}{// BuiltInDefaultValueGetter<T, true>::Get() returns a}}
\DoxyCodeLine{168 \textcolor{comment}{// default-\/constructed T value.  BuiltInDefaultValueGetter<T,}}
\DoxyCodeLine{169 \textcolor{comment}{// false>::Get() crashes with an error.}}
\DoxyCodeLine{170 \textcolor{comment}{//}}
\DoxyCodeLine{171 \textcolor{comment}{// This primary template is used when kDefaultConstructible is true.}}
\DoxyCodeLine{172 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T, \textcolor{keywordtype}{bool} kDefaultConstructible>}
\DoxyCodeLine{173 \textcolor{keyword}{struct }\mbox{\hyperlink{structtesting_1_1internal_1_1BuiltInDefaultValueGetter}{BuiltInDefaultValueGetter}} \{}
\DoxyCodeLine{174   \textcolor{keyword}{static} T Get() \{ \textcolor{keywordflow}{return} T(); \}}
\DoxyCodeLine{175 \};}
\DoxyCodeLine{176 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{177 \textcolor{keyword}{struct }\mbox{\hyperlink{structtesting_1_1internal_1_1BuiltInDefaultValueGetter}{BuiltInDefaultValueGetter}}<T, false> \{}
\DoxyCodeLine{178   \textcolor{keyword}{static} T Get() \{}
\DoxyCodeLine{179     Assert(\textcolor{keyword}{false}, \_\_FILE\_\_, \_\_LINE\_\_,}
\DoxyCodeLine{180            \textcolor{stringliteral}{"{}Default action undefined for the function return type."{}});}
\DoxyCodeLine{181     \textcolor{keywordflow}{return} internal::Invalid<T>();}
\DoxyCodeLine{182     \textcolor{comment}{// The above statement will never be reached, but is required in}}
\DoxyCodeLine{183     \textcolor{comment}{// order for this function to compile.}}
\DoxyCodeLine{184   \}}
\DoxyCodeLine{185 \};}
\DoxyCodeLine{186 }
\DoxyCodeLine{187 \textcolor{comment}{// BuiltInDefaultValue<T>::Get() returns the "{}built-\/in"{} default value}}
\DoxyCodeLine{188 \textcolor{comment}{// for type T, which is NULL when T is a raw pointer type, 0 when T is}}
\DoxyCodeLine{189 \textcolor{comment}{// a numeric type, false when T is bool, or "{}"{} when T is string or}}
\DoxyCodeLine{190 \textcolor{comment}{// std::string.  In addition, in C++11 and above, it turns a}}
\DoxyCodeLine{191 \textcolor{comment}{// default-\/constructed T value if T is default constructible.  For any}}
\DoxyCodeLine{192 \textcolor{comment}{// other type T, the built-\/in default T value is undefined, and the}}
\DoxyCodeLine{193 \textcolor{comment}{// function will abort the process.}}
\DoxyCodeLine{194 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{195 \textcolor{keyword}{class }\mbox{\hyperlink{classtesting_1_1internal_1_1BuiltInDefaultValue}{BuiltInDefaultValue}} \{}
\DoxyCodeLine{196  \textcolor{keyword}{public}:}
\DoxyCodeLine{197   \textcolor{comment}{// This function returns true if and only if type T has a built-\/in default}}
\DoxyCodeLine{198   \textcolor{comment}{// value.}}
\DoxyCodeLine{199   \textcolor{keyword}{static} \textcolor{keywordtype}{bool} Exists() \{ return ::std::is\_default\_constructible<T>::value; \}}
\DoxyCodeLine{200 }
\DoxyCodeLine{201   \textcolor{keyword}{static} T Get() \{}
\DoxyCodeLine{202     \textcolor{keywordflow}{return} \mbox{\hyperlink{structtesting_1_1internal_1_1BuiltInDefaultValueGetter}{BuiltInDefaultValueGetter}}<}
\DoxyCodeLine{203         T, ::std::is\_default\_constructible<T>::value>::Get();}
\DoxyCodeLine{204   \}}
\DoxyCodeLine{205 \};}
\DoxyCodeLine{206 }
\DoxyCodeLine{207 \textcolor{comment}{// This partial specialization says that we use the same built-\/in}}
\DoxyCodeLine{208 \textcolor{comment}{// default value for T and const T.}}
\DoxyCodeLine{209 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{210 \textcolor{keyword}{class }\mbox{\hyperlink{classtesting_1_1internal_1_1BuiltInDefaultValue}{BuiltInDefaultValue}}<const T> \{}
\DoxyCodeLine{211  \textcolor{keyword}{public}:}
\DoxyCodeLine{212   \textcolor{keyword}{static} \textcolor{keywordtype}{bool} Exists() \{ \textcolor{keywordflow}{return} \mbox{\hyperlink{classtesting_1_1internal_1_1BuiltInDefaultValue}{BuiltInDefaultValue<T>::Exists}}(); \}}
\DoxyCodeLine{213   \textcolor{keyword}{static} T Get() \{ \textcolor{keywordflow}{return} \mbox{\hyperlink{classtesting_1_1internal_1_1BuiltInDefaultValue}{BuiltInDefaultValue<T>::Get}}(); \}}
\DoxyCodeLine{214 \};}
\DoxyCodeLine{215 }
\DoxyCodeLine{216 \textcolor{comment}{// This partial specialization defines the default values for pointer}}
\DoxyCodeLine{217 \textcolor{comment}{// types.}}
\DoxyCodeLine{218 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{219 \textcolor{keyword}{class }\mbox{\hyperlink{classtesting_1_1internal_1_1BuiltInDefaultValue}{BuiltInDefaultValue}}<T*> \{}
\DoxyCodeLine{220  \textcolor{keyword}{public}:}
\DoxyCodeLine{221   \textcolor{keyword}{static} \textcolor{keywordtype}{bool} Exists() \{ \textcolor{keywordflow}{return} \textcolor{keyword}{true}; \}}
\DoxyCodeLine{222   \textcolor{keyword}{static} T* Get() \{ \textcolor{keywordflow}{return} \textcolor{keyword}{nullptr}; \}}
\DoxyCodeLine{223 \};}
\DoxyCodeLine{224 }
\DoxyCodeLine{225 \textcolor{comment}{// The following specializations define the default values for}}
\DoxyCodeLine{226 \textcolor{comment}{// specific types we care about.}}
\DoxyCodeLine{227 \textcolor{preprocessor}{\#define GMOCK\_DEFINE\_DEFAULT\_ACTION\_FOR\_RETURN\_TYPE\_(type, value) \(\backslash\)}}
\DoxyCodeLine{228 \textcolor{preprocessor}{  template <>                                                     \(\backslash\)}}
\DoxyCodeLine{229 \textcolor{preprocessor}{  class BuiltInDefaultValue<type> \{                               \(\backslash\)}}
\DoxyCodeLine{230 \textcolor{preprocessor}{   public:                                                        \(\backslash\)}}
\DoxyCodeLine{231 \textcolor{preprocessor}{    static bool Exists() \{ return true; \}                         \(\backslash\)}}
\DoxyCodeLine{232 \textcolor{preprocessor}{    static type Get() \{ return value; \}                           \(\backslash\)}}
\DoxyCodeLine{233 \textcolor{preprocessor}{  \}}}
\DoxyCodeLine{234 }
\DoxyCodeLine{235 GMOCK\_DEFINE\_DEFAULT\_ACTION\_FOR\_RETURN\_TYPE\_(\textcolor{keywordtype}{void}, );  \textcolor{comment}{// NOLINT}}
\DoxyCodeLine{236 GMOCK\_DEFINE\_DEFAULT\_ACTION\_FOR\_RETURN\_TYPE\_(::std::string, \textcolor{stringliteral}{"{}"{}});}
\DoxyCodeLine{237 GMOCK\_DEFINE\_DEFAULT\_ACTION\_FOR\_RETURN\_TYPE\_(\textcolor{keywordtype}{bool}, \textcolor{keyword}{false});}
\DoxyCodeLine{238 GMOCK\_DEFINE\_DEFAULT\_ACTION\_FOR\_RETURN\_TYPE\_(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char}, \textcolor{charliteral}{'\(\backslash\)0'});}
\DoxyCodeLine{239 GMOCK\_DEFINE\_DEFAULT\_ACTION\_FOR\_RETURN\_TYPE\_(\textcolor{keywordtype}{signed} \textcolor{keywordtype}{char}, \textcolor{charliteral}{'\(\backslash\)0'});}
\DoxyCodeLine{240 GMOCK\_DEFINE\_DEFAULT\_ACTION\_FOR\_RETURN\_TYPE\_(\textcolor{keywordtype}{char}, \textcolor{charliteral}{'\(\backslash\)0'});}
\DoxyCodeLine{241 }
\DoxyCodeLine{242 \textcolor{comment}{// There's no need for a default action for signed wchar\_t, as that}}
\DoxyCodeLine{243 \textcolor{comment}{// type is the same as wchar\_t for gcc, and invalid for MSVC.}}
\DoxyCodeLine{244 \textcolor{comment}{//}}
\DoxyCodeLine{245 \textcolor{comment}{// There's also no need for a default action for unsigned wchar\_t, as}}
\DoxyCodeLine{246 \textcolor{comment}{// that type is the same as unsigned int for gcc, and invalid for}}
\DoxyCodeLine{247 \textcolor{comment}{// MSVC.}}
\DoxyCodeLine{248 \textcolor{preprocessor}{\#if GMOCK\_WCHAR\_T\_IS\_NATIVE\_}}
\DoxyCodeLine{249 GMOCK\_DEFINE\_DEFAULT\_ACTION\_FOR\_RETURN\_TYPE\_(\textcolor{keywordtype}{wchar\_t}, 0U);  \textcolor{comment}{// NOLINT}}
\DoxyCodeLine{250 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{251 }
\DoxyCodeLine{252 GMOCK\_DEFINE\_DEFAULT\_ACTION\_FOR\_RETURN\_TYPE\_(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{short}, 0U);  \textcolor{comment}{// NOLINT}}
\DoxyCodeLine{253 GMOCK\_DEFINE\_DEFAULT\_ACTION\_FOR\_RETURN\_TYPE\_(\textcolor{keywordtype}{signed} \textcolor{keywordtype}{short}, 0);     \textcolor{comment}{// NOLINT}}
\DoxyCodeLine{254 GMOCK\_DEFINE\_DEFAULT\_ACTION\_FOR\_RETURN\_TYPE\_(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int}, 0U);}
\DoxyCodeLine{255 GMOCK\_DEFINE\_DEFAULT\_ACTION\_FOR\_RETURN\_TYPE\_(\textcolor{keywordtype}{signed} \textcolor{keywordtype}{int}, 0);}
\DoxyCodeLine{256 GMOCK\_DEFINE\_DEFAULT\_ACTION\_FOR\_RETURN\_TYPE\_(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long}, 0UL);     \textcolor{comment}{// NOLINT}}
\DoxyCodeLine{257 GMOCK\_DEFINE\_DEFAULT\_ACTION\_FOR\_RETURN\_TYPE\_(\textcolor{keywordtype}{signed} \textcolor{keywordtype}{long}, 0L);        \textcolor{comment}{// NOLINT}}
\DoxyCodeLine{258 GMOCK\_DEFINE\_DEFAULT\_ACTION\_FOR\_RETURN\_TYPE\_(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long}, 0);  \textcolor{comment}{// NOLINT}}
\DoxyCodeLine{259 GMOCK\_DEFINE\_DEFAULT\_ACTION\_FOR\_RETURN\_TYPE\_(\textcolor{keywordtype}{signed} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long}, 0);    \textcolor{comment}{// NOLINT}}
\DoxyCodeLine{260 GMOCK\_DEFINE\_DEFAULT\_ACTION\_FOR\_RETURN\_TYPE\_(\textcolor{keywordtype}{float}, 0);}
\DoxyCodeLine{261 GMOCK\_DEFINE\_DEFAULT\_ACTION\_FOR\_RETURN\_TYPE\_(\textcolor{keywordtype}{double}, 0);}
\DoxyCodeLine{262 }
\DoxyCodeLine{263 \textcolor{preprocessor}{\#undef GMOCK\_DEFINE\_DEFAULT\_ACTION\_FOR\_RETURN\_TYPE\_}}
\DoxyCodeLine{264 }
\DoxyCodeLine{265 \textcolor{comment}{// Partial implementations of metaprogramming types from the standard library}}
\DoxyCodeLine{266 \textcolor{comment}{// not available in C++11.}}
\DoxyCodeLine{267 }
\DoxyCodeLine{268 \textcolor{keyword}{template} <\textcolor{keyword}{typename} P>}
\DoxyCodeLine{269 \textcolor{keyword}{struct }\mbox{\hyperlink{structtesting_1_1internal_1_1negation}{negation}}}
\DoxyCodeLine{270     \textcolor{comment}{// NOLINTNEXTLINE}}
\DoxyCodeLine{271     : std::integral\_constant<bool, bool(!P::value)> \{\};}
\DoxyCodeLine{272 }
\DoxyCodeLine{273 \textcolor{comment}{// Base case: with zero predicates the answer is always true.}}
\DoxyCodeLine{274 \textcolor{keyword}{template} <\textcolor{keyword}{typename}...>}
\DoxyCodeLine{275 \textcolor{keyword}{struct }\mbox{\hyperlink{structtesting_1_1internal_1_1conjunction}{conjunction}} : std::true\_type \{\};}
\DoxyCodeLine{276 }
\DoxyCodeLine{277 \textcolor{comment}{// With a single predicate, the answer is that predicate.}}
\DoxyCodeLine{278 \textcolor{keyword}{template} <\textcolor{keyword}{typename} P1>}
\DoxyCodeLine{279 \textcolor{keyword}{struct }\mbox{\hyperlink{structtesting_1_1internal_1_1conjunction}{conjunction<P1>}} : P1 \{\};}
\DoxyCodeLine{280 }
\DoxyCodeLine{281 \textcolor{comment}{// With multiple predicates the answer is the first predicate if that is false,}}
\DoxyCodeLine{282 \textcolor{comment}{// and we recurse otherwise.}}
\DoxyCodeLine{283 \textcolor{keyword}{template} <\textcolor{keyword}{typename} P1, \textcolor{keyword}{typename}... Ps>}
\DoxyCodeLine{284 \textcolor{keyword}{struct }\mbox{\hyperlink{structtesting_1_1internal_1_1conjunction}{conjunction}}<P1, Ps...>}
\DoxyCodeLine{285     : std::conditional<bool(P1::value), conjunction<Ps...>, P1>::type \{\};}
\DoxyCodeLine{286 }
\DoxyCodeLine{287 \textcolor{keyword}{template} <\textcolor{keyword}{typename}...>}
\DoxyCodeLine{288 \textcolor{keyword}{struct }\mbox{\hyperlink{structtesting_1_1internal_1_1disjunction}{disjunction}} : std::false\_type \{\};}
\DoxyCodeLine{289 }
\DoxyCodeLine{290 \textcolor{keyword}{template} <\textcolor{keyword}{typename} P1>}
\DoxyCodeLine{291 \textcolor{keyword}{struct }\mbox{\hyperlink{structtesting_1_1internal_1_1disjunction}{disjunction<P1>}} : P1 \{\};}
\DoxyCodeLine{292 }
\DoxyCodeLine{293 \textcolor{keyword}{template} <\textcolor{keyword}{typename} P1, \textcolor{keyword}{typename}... Ps>}
\DoxyCodeLine{294 \textcolor{keyword}{struct }\mbox{\hyperlink{structtesting_1_1internal_1_1disjunction}{disjunction}}<P1, Ps...>}
\DoxyCodeLine{295     \textcolor{comment}{// NOLINTNEXTLINE}}
\DoxyCodeLine{296     : std::conditional<!bool(P1::value), disjunction<Ps...>, P1>::type \{\};}
\DoxyCodeLine{297 }
\DoxyCodeLine{298 \textcolor{keyword}{template} <\textcolor{keyword}{typename}...>}
\DoxyCodeLine{299 \textcolor{keyword}{using }void\_t = void;}
\DoxyCodeLine{300 }
\DoxyCodeLine{301 \textcolor{comment}{// Detects whether an expression of type `From` can be implicitly converted to}}
\DoxyCodeLine{302 \textcolor{comment}{// `To` according to [conv]. In C++17, [conv]/3 defines this as follows:}}
\DoxyCodeLine{303 \textcolor{comment}{//}}
\DoxyCodeLine{304 \textcolor{comment}{//     An expression e can be implicitly converted to a type T if and only if}}
\DoxyCodeLine{305 \textcolor{comment}{//     the declaration T t=e; is well-\/formed, for some invented temporary}}
\DoxyCodeLine{306 \textcolor{comment}{//     variable t ([dcl.init]).}}
\DoxyCodeLine{307 \textcolor{comment}{//}}
\DoxyCodeLine{308 \textcolor{comment}{// [conv]/2 implies we can use function argument passing to detect whether this}}
\DoxyCodeLine{309 \textcolor{comment}{// initialization is valid.}}
\DoxyCodeLine{310 \textcolor{comment}{//}}
\DoxyCodeLine{311 \textcolor{comment}{// Note that this is distinct from is\_convertible, which requires this be valid:}}
\DoxyCodeLine{312 \textcolor{comment}{//}}
\DoxyCodeLine{313 \textcolor{comment}{//     To test() \{}}
\DoxyCodeLine{314 \textcolor{comment}{//       return declval<From>();}}
\DoxyCodeLine{315 \textcolor{comment}{//     \}}}
\DoxyCodeLine{316 \textcolor{comment}{//}}
\DoxyCodeLine{317 \textcolor{comment}{// In particular, is\_convertible doesn't give the correct answer when `To` and}}
\DoxyCodeLine{318 \textcolor{comment}{// `From` are the same non-\/moveable type since `declval<From>` will be an rvalue}}
\DoxyCodeLine{319 \textcolor{comment}{// reference, defeating the guaranteed copy elision that would otherwise make}}
\DoxyCodeLine{320 \textcolor{comment}{// this function work.}}
\DoxyCodeLine{321 \textcolor{comment}{//}}
\DoxyCodeLine{322 \textcolor{comment}{// REQUIRES: `From` is not cv void.}}
\DoxyCodeLine{323 \textcolor{keyword}{template} <\textcolor{keyword}{typename} From, \textcolor{keyword}{typename} To>}
\DoxyCodeLine{324 \textcolor{keyword}{struct }\mbox{\hyperlink{structtesting_1_1internal_1_1is__implicitly__convertible}{is\_implicitly\_convertible}} \{}
\DoxyCodeLine{325  \textcolor{keyword}{private}:}
\DoxyCodeLine{326   \textcolor{comment}{// A function that accepts a parameter of type T. This can be called with type}}
\DoxyCodeLine{327   \textcolor{comment}{// U successfully only if U is implicitly convertible to T.}}
\DoxyCodeLine{328   \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{329   \textcolor{keyword}{static} \textcolor{keywordtype}{void} Accept(T);}
\DoxyCodeLine{330 }
\DoxyCodeLine{331   \textcolor{comment}{// A function that creates a value of type T.}}
\DoxyCodeLine{332   \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{333   \textcolor{keyword}{static} T Make();}
\DoxyCodeLine{334 }
\DoxyCodeLine{335   \textcolor{comment}{// An overload be selected when implicit conversion from T to To is possible.}}
\DoxyCodeLine{336   template <typename T, typename = decltype(Accept<To>(Make<T>()))>}
\DoxyCodeLine{337   \textcolor{keyword}{static} std::true\_type TestImplicitConversion(\textcolor{keywordtype}{int});}
\DoxyCodeLine{338 }
\DoxyCodeLine{339   \textcolor{comment}{// A fallback overload selected in all other cases.}}
\DoxyCodeLine{340   \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{341   \textcolor{keyword}{static} std::false\_type TestImplicitConversion(...);}
\DoxyCodeLine{342 }
\DoxyCodeLine{343  \textcolor{keyword}{public}:}
\DoxyCodeLine{344   \textcolor{keyword}{using }type = \textcolor{keyword}{decltype}(TestImplicitConversion<From>(0));}
\DoxyCodeLine{345   \textcolor{keyword}{static} \textcolor{keyword}{constexpr} \textcolor{keywordtype}{bool} value = type::value;}
\DoxyCodeLine{346 \};}
\DoxyCodeLine{347 }
\DoxyCodeLine{348 \textcolor{comment}{// Like std::invoke\_result\_t from C++17, but works only for objects with call}}
\DoxyCodeLine{349 \textcolor{comment}{// operators (not e.g. member function pointers, which we don't need specific}}
\DoxyCodeLine{350 \textcolor{comment}{// support for in OnceAction because std::function deals with them).}}
\DoxyCodeLine{351 \textcolor{keyword}{template} <\textcolor{keyword}{typename} F, \textcolor{keyword}{typename}... Args>}
\DoxyCodeLine{352 \textcolor{keyword}{using }call\_result\_t = \textcolor{keyword}{decltype}(std::declval<F>()(std::declval<Args>()...));}
\DoxyCodeLine{353 }
\DoxyCodeLine{354 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Void, \textcolor{keyword}{typename} R, \textcolor{keyword}{typename} F, \textcolor{keyword}{typename}... Args>}
\DoxyCodeLine{355 \textcolor{keyword}{struct }\mbox{\hyperlink{structtesting_1_1internal_1_1is__callable__r__impl}{is\_callable\_r\_impl}} : std::false\_type \{\};}
\DoxyCodeLine{356 }
\DoxyCodeLine{357 \textcolor{comment}{// Specialize the struct for those template arguments where call\_result\_t is}}
\DoxyCodeLine{358 \textcolor{comment}{// well-\/formed. When it's not, the generic template above is chosen, resulting}}
\DoxyCodeLine{359 \textcolor{comment}{// in std::false\_type.}}
\DoxyCodeLine{360 \textcolor{keyword}{template} <\textcolor{keyword}{typename} R, \textcolor{keyword}{typename} F, \textcolor{keyword}{typename}... Args>}
\DoxyCodeLine{361 \textcolor{keyword}{struct }\mbox{\hyperlink{structtesting_1_1internal_1_1is__callable__r__impl}{is\_callable\_r\_impl}}<void\_t<call\_result\_t<F, Args...>>, R, F, Args...>}
\DoxyCodeLine{362     : std::conditional<}
\DoxyCodeLine{363           std::is\_void<R>::value,  \textcolor{comment}{//}}
\DoxyCodeLine{364           std::true\_type,          \textcolor{comment}{//}}
\DoxyCodeLine{365           is\_implicitly\_convertible<call\_result\_t<F, Args...>, R>>::type \{\};}
\DoxyCodeLine{366 }
\DoxyCodeLine{367 \textcolor{comment}{// Like std::is\_invocable\_r from C++17, but works only for objects with call}}
\DoxyCodeLine{368 \textcolor{comment}{// operators. See the note on call\_result\_t.}}
\DoxyCodeLine{369 \textcolor{keyword}{template} <\textcolor{keyword}{typename} R, \textcolor{keyword}{typename} F, \textcolor{keyword}{typename}... Args>}
\DoxyCodeLine{370 \textcolor{keyword}{using }\mbox{\hyperlink{structtesting_1_1internal_1_1is__callable__r__impl}{is\_callable\_r}} = \mbox{\hyperlink{structtesting_1_1internal_1_1is__callable__r__impl}{is\_callable\_r\_impl}}<void, R, F, Args...>;}
\DoxyCodeLine{371 }
\DoxyCodeLine{372 \textcolor{comment}{// Like std::as\_const from C++17.}}
\DoxyCodeLine{373 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{374 \textcolor{keyword}{typename} std::add\_const<T>::type\& as\_const(T\& t) \{}
\DoxyCodeLine{375   \textcolor{keywordflow}{return} t;}
\DoxyCodeLine{376 \}}
\DoxyCodeLine{377 }
\DoxyCodeLine{378 \}  \textcolor{comment}{// namespace internal}}
\DoxyCodeLine{379 }
\DoxyCodeLine{380 \textcolor{comment}{// Specialized for function types below.}}
\DoxyCodeLine{381 \textcolor{keyword}{template} <\textcolor{keyword}{typename} F>}
\DoxyCodeLine{382 \textcolor{keyword}{class }\mbox{\hyperlink{classtesting_1_1OnceAction}{OnceAction}};}
\DoxyCodeLine{383 }
\DoxyCodeLine{384 \textcolor{comment}{// An action that can only be used once.}}
\DoxyCodeLine{385 \textcolor{comment}{//}}
\DoxyCodeLine{386 \textcolor{comment}{// This is accepted by WillOnce, which doesn't require the underlying action to}}
\DoxyCodeLine{387 \textcolor{comment}{// be copy-\/constructible (only move-\/constructible), and promises to invoke it as}}
\DoxyCodeLine{388 \textcolor{comment}{// an rvalue reference. This allows the action to work with move-\/only types like}}
\DoxyCodeLine{389 \textcolor{comment}{// std::move\_only\_function in a type-\/safe manner.}}
\DoxyCodeLine{390 \textcolor{comment}{//}}
\DoxyCodeLine{391 \textcolor{comment}{// For example:}}
\DoxyCodeLine{392 \textcolor{comment}{//}}
\DoxyCodeLine{393 \textcolor{comment}{//     // Assume we have some API that needs to accept a unique pointer to some}}
\DoxyCodeLine{394 \textcolor{comment}{//     // non-\/copyable object Foo.}}
\DoxyCodeLine{395 \textcolor{comment}{//     void AcceptUniquePointer(std::unique\_ptr<Foo> foo);}}
\DoxyCodeLine{396 \textcolor{comment}{//}}
\DoxyCodeLine{397 \textcolor{comment}{//     // We can define an action that provides a Foo to that API. Because It}}
\DoxyCodeLine{398 \textcolor{comment}{//     // has to give away its unique pointer, it must not be called more than}}
\DoxyCodeLine{399 \textcolor{comment}{//     // once, so its call operator is \&\&-\/qualified.}}
\DoxyCodeLine{400 \textcolor{comment}{//     struct ProvideFoo \{}}
\DoxyCodeLine{401 \textcolor{comment}{//       std::unique\_ptr<Foo> foo;}}
\DoxyCodeLine{402 \textcolor{comment}{//}}
\DoxyCodeLine{403 \textcolor{comment}{//       void operator()() \&\& \{}}
\DoxyCodeLine{404 \textcolor{comment}{//         AcceptUniquePointer(std::move(Foo));}}
\DoxyCodeLine{405 \textcolor{comment}{//       \}}}
\DoxyCodeLine{406 \textcolor{comment}{//     \};}}
\DoxyCodeLine{407 \textcolor{comment}{//}}
\DoxyCodeLine{408 \textcolor{comment}{//     // This action can be used with WillOnce.}}
\DoxyCodeLine{409 \textcolor{comment}{//     EXPECT\_CALL(mock, Call)}}
\DoxyCodeLine{410 \textcolor{comment}{//         .WillOnce(ProvideFoo\{std::make\_unique<Foo>(...)\});}}
\DoxyCodeLine{411 \textcolor{comment}{//}}
\DoxyCodeLine{412 \textcolor{comment}{//     // But a call to WillRepeatedly will fail to compile. This is correct,}}
\DoxyCodeLine{413 \textcolor{comment}{//     // since the action cannot correctly be used repeatedly.}}
\DoxyCodeLine{414 \textcolor{comment}{//     EXPECT\_CALL(mock, Call)}}
\DoxyCodeLine{415 \textcolor{comment}{//         .WillRepeatedly(ProvideFoo\{std::make\_unique<Foo>(...)\});}}
\DoxyCodeLine{416 \textcolor{comment}{//}}
\DoxyCodeLine{417 \textcolor{comment}{// A less-\/contrived example would be an action that returns an arbitrary type,}}
\DoxyCodeLine{418 \textcolor{comment}{// whose \&\&-\/qualified call operator is capable of dealing with move-\/only types.}}
\DoxyCodeLine{419 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Result, \textcolor{keyword}{typename}... Args>}
\DoxyCodeLine{420 \textcolor{keyword}{class }\mbox{\hyperlink{classtesting_1_1OnceAction}{OnceAction}}<Result(Args...)> final \{}
\DoxyCodeLine{421  \textcolor{keyword}{private}:}
\DoxyCodeLine{422   \textcolor{comment}{// True iff we can use the given callable type (or lvalue reference) directly}}
\DoxyCodeLine{423   \textcolor{comment}{// via StdFunctionAdaptor.}}
\DoxyCodeLine{424   \textcolor{keyword}{template} <\textcolor{keyword}{typename} Callable>}
\DoxyCodeLine{425   \textcolor{keyword}{using }\mbox{\hyperlink{structtesting_1_1internal_1_1conjunction}{IsDirectlyCompatible}} = \mbox{\hyperlink{structtesting_1_1internal_1_1conjunction}{internal::conjunction}}<}
\DoxyCodeLine{426       \textcolor{comment}{// It must be possible to capture the callable in StdFunctionAdaptor.}}
\DoxyCodeLine{427       std::is\_constructible<typename std::decay<Callable>::type, Callable>,}
\DoxyCodeLine{428       \textcolor{comment}{// The callable must be compatible with our signature.}}
\DoxyCodeLine{429       \mbox{\hyperlink{structtesting_1_1internal_1_1is__callable__r__impl}{internal::is\_callable\_r<Result, typename std::decay<Callable>::type}},}
\DoxyCodeLine{430                               Args...>>;}
\DoxyCodeLine{431 }
\DoxyCodeLine{432   \textcolor{comment}{// True iff we can use the given callable type via StdFunctionAdaptor once we}}
\DoxyCodeLine{433   \textcolor{comment}{// ignore incoming arguments.}}
\DoxyCodeLine{434   \textcolor{keyword}{template} <\textcolor{keyword}{typename} Callable>}
\DoxyCodeLine{435   \textcolor{keyword}{using }\mbox{\hyperlink{structtesting_1_1internal_1_1conjunction}{IsCompatibleAfterIgnoringArguments}} = \mbox{\hyperlink{structtesting_1_1internal_1_1conjunction}{internal::conjunction}}<}
\DoxyCodeLine{436       \textcolor{comment}{// It must be possible to capture the callable in a lambda.}}
\DoxyCodeLine{437       std::is\_constructible<typename std::decay<Callable>::type, Callable>,}
\DoxyCodeLine{438       \textcolor{comment}{// The callable must be invocable with zero arguments, returning something}}
\DoxyCodeLine{439       \textcolor{comment}{// convertible to Result.}}
\DoxyCodeLine{440       \mbox{\hyperlink{structtesting_1_1internal_1_1is__callable__r__impl}{internal::is\_callable\_r<Result, typename std::decay<Callable>::type}}>>;}
\DoxyCodeLine{441 }
\DoxyCodeLine{442  \textcolor{keyword}{public}:}
\DoxyCodeLine{443   \textcolor{comment}{// Construct from a callable that is directly compatible with our mocked}}
\DoxyCodeLine{444   \textcolor{comment}{// signature: it accepts our function type's arguments and returns something}}
\DoxyCodeLine{445   \textcolor{comment}{// convertible to our result type.}}
\DoxyCodeLine{446   \textcolor{keyword}{template} <\textcolor{keyword}{typename} Callable,}
\DoxyCodeLine{447             \textcolor{keyword}{typename} std::enable\_if<}
\DoxyCodeLine{448                 \mbox{\hyperlink{structtesting_1_1internal_1_1conjunction}{internal::conjunction}}<}
\DoxyCodeLine{449                     \textcolor{comment}{// Teach clang on macOS that we're not talking about a}}
\DoxyCodeLine{450                     \textcolor{comment}{// copy/move constructor here. Otherwise it gets confused}}
\DoxyCodeLine{451                     \textcolor{comment}{// when checking the is\_constructible requirement of our}}
\DoxyCodeLine{452                     \textcolor{comment}{// traits above.}}
\DoxyCodeLine{453                     \mbox{\hyperlink{structtesting_1_1internal_1_1negation}{internal::negation}}<std::is\_same<}
\DoxyCodeLine{454                         \mbox{\hyperlink{classtesting_1_1OnceAction}{OnceAction}}, \textcolor{keyword}{typename} std::decay<Callable>::type>>,}
\DoxyCodeLine{455                     \mbox{\hyperlink{structtesting_1_1internal_1_1conjunction}{IsDirectlyCompatible<Callable>}}>  \textcolor{comment}{//}}
\DoxyCodeLine{456                 ::value,}
\DoxyCodeLine{457                 \textcolor{keywordtype}{int}>::type = 0>}
\DoxyCodeLine{458   \mbox{\hyperlink{classtesting_1_1OnceAction}{OnceAction}}(Callable\&\& callable)  \textcolor{comment}{// NOLINT}}
\DoxyCodeLine{459       : function\_(StdFunctionAdaptor<\textcolor{keyword}{typename} std::decay<Callable>::type>(}
\DoxyCodeLine{460             \{\}, std::forward<Callable>(callable))) \{\}}
\DoxyCodeLine{461 }
\DoxyCodeLine{462   \textcolor{comment}{// As above, but for a callable that ignores the mocked function's arguments.}}
\DoxyCodeLine{463   \textcolor{keyword}{template} <\textcolor{keyword}{typename} Callable,}
\DoxyCodeLine{464             \textcolor{keyword}{typename} std::enable\_if<}
\DoxyCodeLine{465                 \mbox{\hyperlink{structtesting_1_1internal_1_1conjunction}{internal::conjunction}}<}
\DoxyCodeLine{466                     \textcolor{comment}{// Teach clang on macOS that we're not talking about a}}
\DoxyCodeLine{467                     \textcolor{comment}{// copy/move constructor here. Otherwise it gets confused}}
\DoxyCodeLine{468                     \textcolor{comment}{// when checking the is\_constructible requirement of our}}
\DoxyCodeLine{469                     \textcolor{comment}{// traits above.}}
\DoxyCodeLine{470                     \mbox{\hyperlink{structtesting_1_1internal_1_1negation}{internal::negation}}<std::is\_same<}
\DoxyCodeLine{471                         \mbox{\hyperlink{classtesting_1_1OnceAction}{OnceAction}}, \textcolor{keyword}{typename} std::decay<Callable>::type>>,}
\DoxyCodeLine{472                     \textcolor{comment}{// Exclude callables for which the overload above works.}}
\DoxyCodeLine{473                     \textcolor{comment}{// We'd rather provide the arguments if possible.}}
\DoxyCodeLine{474                     \mbox{\hyperlink{structtesting_1_1internal_1_1negation}{internal::negation<IsDirectlyCompatible<Callable>}}>,}
\DoxyCodeLine{475                     \mbox{\hyperlink{structtesting_1_1internal_1_1conjunction}{IsCompatibleAfterIgnoringArguments<Callable>}}>::value,}
\DoxyCodeLine{476                 \textcolor{keywordtype}{int}>::type = 0>}
\DoxyCodeLine{477   \mbox{\hyperlink{classtesting_1_1OnceAction}{OnceAction}}(Callable\&\& callable)  \textcolor{comment}{// NOLINT}}
\DoxyCodeLine{478                                    \textcolor{comment}{// Call the constructor above with a callable}}
\DoxyCodeLine{479                                    \textcolor{comment}{// that ignores the input arguments.}}
\DoxyCodeLine{480       : \mbox{\hyperlink{classtesting_1_1OnceAction}{OnceAction}}(IgnoreIncomingArguments<\textcolor{keyword}{typename} std::decay<Callable>::type>\{}
\DoxyCodeLine{481             std::forward<Callable>(callable)\}) \{\}}
\DoxyCodeLine{482 }
\DoxyCodeLine{483   \textcolor{comment}{// We are naturally copyable because we store only an std::function, but}}
\DoxyCodeLine{484   \textcolor{comment}{// semantically we should not be copyable.}}
\DoxyCodeLine{485   \mbox{\hyperlink{classtesting_1_1OnceAction}{OnceAction}}(\textcolor{keyword}{const} \mbox{\hyperlink{classtesting_1_1OnceAction}{OnceAction}}\&) = \textcolor{keyword}{delete};}
\DoxyCodeLine{486   \mbox{\hyperlink{classtesting_1_1OnceAction}{OnceAction}}\& operator=(\textcolor{keyword}{const} \mbox{\hyperlink{classtesting_1_1OnceAction}{OnceAction}}\&) = \textcolor{keyword}{delete};}
\DoxyCodeLine{487   \mbox{\hyperlink{classtesting_1_1OnceAction}{OnceAction}}(\mbox{\hyperlink{classtesting_1_1OnceAction}{OnceAction}}\&\&) = \textcolor{keywordflow}{default};}
\DoxyCodeLine{488 }
\DoxyCodeLine{489   \textcolor{comment}{// Invoke the underlying action callable with which we were constructed,}}
\DoxyCodeLine{490   \textcolor{comment}{// handing it the supplied arguments.}}
\DoxyCodeLine{491   Result Call(Args... args) \&\& \{}
\DoxyCodeLine{492     \textcolor{keywordflow}{return} function\_(std::forward<Args>(args)...);}
\DoxyCodeLine{493   \}}
\DoxyCodeLine{494 }
\DoxyCodeLine{495  \textcolor{keyword}{private}:}
\DoxyCodeLine{496   \textcolor{comment}{// An adaptor that wraps a callable that is compatible with our signature and}}
\DoxyCodeLine{497   \textcolor{comment}{// being invoked as an rvalue reference so that it can be used as an}}
\DoxyCodeLine{498   \textcolor{comment}{// StdFunctionAdaptor. This throws away type safety, but that's fine because}}
\DoxyCodeLine{499   \textcolor{comment}{// this is only used by WillOnce, which we know calls at most once.}}
\DoxyCodeLine{500   \textcolor{comment}{//}}
\DoxyCodeLine{501   \textcolor{comment}{// Once we have something like std::move\_only\_function from C++23, we can do}}
\DoxyCodeLine{502   \textcolor{comment}{// away with this.}}
\DoxyCodeLine{503   \textcolor{keyword}{template} <\textcolor{keyword}{typename} Callable>}
\DoxyCodeLine{504   \textcolor{keyword}{class }StdFunctionAdaptor final \{}
\DoxyCodeLine{505    \textcolor{keyword}{public}:}
\DoxyCodeLine{506     \textcolor{comment}{// A tag indicating that the (otherwise universal) constructor is accepting}}
\DoxyCodeLine{507     \textcolor{comment}{// the callable itself, instead of e.g. stealing calls for the move}}
\DoxyCodeLine{508     \textcolor{comment}{// constructor.}}
\DoxyCodeLine{509     \textcolor{keyword}{struct }CallableTag final \{\};}
\DoxyCodeLine{510 }
\DoxyCodeLine{511     \textcolor{keyword}{template} <\textcolor{keyword}{typename} F>}
\DoxyCodeLine{512     \textcolor{keyword}{explicit} StdFunctionAdaptor(CallableTag, F\&\& callable)}
\DoxyCodeLine{513         : callable\_(std::make\_shared<Callable>(std::forward<F>(callable))) \{\}}
\DoxyCodeLine{514 }
\DoxyCodeLine{515     \textcolor{comment}{// Rather than explicitly returning Result, we return whatever the wrapped}}
\DoxyCodeLine{516     \textcolor{comment}{// callable returns. This allows for compatibility with existing uses like}}
\DoxyCodeLine{517     \textcolor{comment}{// the following, when the mocked function returns void:}}
\DoxyCodeLine{518     \textcolor{comment}{//}}
\DoxyCodeLine{519     \textcolor{comment}{//     EXPECT\_CALL(mock\_fn\_, Call)}}
\DoxyCodeLine{520     \textcolor{comment}{//         .WillOnce([\&] \{}}
\DoxyCodeLine{521     \textcolor{comment}{//            [...]}}
\DoxyCodeLine{522     \textcolor{comment}{//            return 0;}}
\DoxyCodeLine{523     \textcolor{comment}{//         \});}}
\DoxyCodeLine{524     \textcolor{comment}{//}}
\DoxyCodeLine{525     \textcolor{comment}{// Such a callable can be turned into std::function<void()>. If we use an}}
\DoxyCodeLine{526     \textcolor{comment}{// explicit return type of Result here then it *doesn't* work with}}
\DoxyCodeLine{527     \textcolor{comment}{// std::function, because we'll get a "{}void function should not return a}}
\DoxyCodeLine{528     \textcolor{comment}{// value"{} error.}}
\DoxyCodeLine{529     \textcolor{comment}{//}}
\DoxyCodeLine{530     \textcolor{comment}{// We need not worry about incompatible result types because the SFINAE on}}
\DoxyCodeLine{531     \textcolor{comment}{// OnceAction already checks this for us. std::is\_invocable\_r\_v itself makes}}
\DoxyCodeLine{532     \textcolor{comment}{// the same allowance for void result types.}}
\DoxyCodeLine{533     \textcolor{keyword}{template} <\textcolor{keyword}{typename}... ArgRefs>}
\DoxyCodeLine{534     internal::call\_result\_t<Callable, ArgRefs...> operator()(}
\DoxyCodeLine{535         ArgRefs\&\&... args)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{536       \textcolor{keywordflow}{return} std::move(*callable\_)(std::forward<ArgRefs>(args)...);}
\DoxyCodeLine{537     \}}
\DoxyCodeLine{538 }
\DoxyCodeLine{539    \textcolor{keyword}{private}:}
\DoxyCodeLine{540     \textcolor{comment}{// We must put the callable on the heap so that we are copyable, which}}
\DoxyCodeLine{541     \textcolor{comment}{// std::function needs.}}
\DoxyCodeLine{542     std::shared\_ptr<Callable> callable\_;}
\DoxyCodeLine{543   \};}
\DoxyCodeLine{544 }
\DoxyCodeLine{545   \textcolor{comment}{// An adaptor that makes a callable that accepts zero arguments callable with}}
\DoxyCodeLine{546   \textcolor{comment}{// our mocked arguments.}}
\DoxyCodeLine{547   \textcolor{keyword}{template} <\textcolor{keyword}{typename} Callable>}
\DoxyCodeLine{548   \textcolor{keyword}{struct }IgnoreIncomingArguments \{}
\DoxyCodeLine{549     internal::call\_result\_t<Callable> operator()(Args\&\&...) \{}
\DoxyCodeLine{550       \textcolor{keywordflow}{return} std::move(callable)();}
\DoxyCodeLine{551     \}}
\DoxyCodeLine{552 }
\DoxyCodeLine{553     Callable callable;}
\DoxyCodeLine{554   \};}
\DoxyCodeLine{555 }
\DoxyCodeLine{556   std::function<Result(Args...)> function\_;}
\DoxyCodeLine{557 \};}
\DoxyCodeLine{558 }
\DoxyCodeLine{559 \textcolor{comment}{// When an unexpected function call is encountered, Google Mock will}}
\DoxyCodeLine{560 \textcolor{comment}{// let it return a default value if the user has specified one for its}}
\DoxyCodeLine{561 \textcolor{comment}{// return type, or if the return type has a built-\/in default value;}}
\DoxyCodeLine{562 \textcolor{comment}{// otherwise Google Mock won't know what value to return and will have}}
\DoxyCodeLine{563 \textcolor{comment}{// to abort the process.}}
\DoxyCodeLine{564 \textcolor{comment}{//}}
\DoxyCodeLine{565 \textcolor{comment}{// The DefaultValue<T> class allows a user to specify the}}
\DoxyCodeLine{566 \textcolor{comment}{// default value for a type T that is both copyable and publicly}}
\DoxyCodeLine{567 \textcolor{comment}{// destructible (i.e. anything that can be used as a function return}}
\DoxyCodeLine{568 \textcolor{comment}{// type).  The usage is:}}
\DoxyCodeLine{569 \textcolor{comment}{//}}
\DoxyCodeLine{570 \textcolor{comment}{//   // Sets the default value for type T to be foo.}}
\DoxyCodeLine{571 \textcolor{comment}{//   DefaultValue<T>::Set(foo);}}
\DoxyCodeLine{572 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{573 \textcolor{keyword}{class }\mbox{\hyperlink{classtesting_1_1DefaultValue}{DefaultValue}} \{}
\DoxyCodeLine{574  \textcolor{keyword}{public}:}
\DoxyCodeLine{575   \textcolor{comment}{// Sets the default value for type T; requires T to be}}
\DoxyCodeLine{576   \textcolor{comment}{// copy-\/constructable and have a public destructor.}}
\DoxyCodeLine{577   \textcolor{keyword}{static} \textcolor{keywordtype}{void} Set(T x) \{}
\DoxyCodeLine{578     \textcolor{keyword}{delete} producer\_;}
\DoxyCodeLine{579     producer\_ = \textcolor{keyword}{new} FixedValueProducer(x);}
\DoxyCodeLine{580   \}}
\DoxyCodeLine{581 }
\DoxyCodeLine{582   \textcolor{comment}{// Provides a factory function to be called to generate the default value.}}
\DoxyCodeLine{583   \textcolor{comment}{// This method can be used even if T is only move-\/constructible, but it is not}}
\DoxyCodeLine{584   \textcolor{comment}{// limited to that case.}}
\DoxyCodeLine{585   \textcolor{keyword}{typedef} T (*FactoryFunction)();}
\DoxyCodeLine{586   \textcolor{keyword}{static} \textcolor{keywordtype}{void} SetFactory(FactoryFunction factory) \{}
\DoxyCodeLine{587     \textcolor{keyword}{delete} producer\_;}
\DoxyCodeLine{588     producer\_ = \textcolor{keyword}{new} FactoryValueProducer(factory);}
\DoxyCodeLine{589   \}}
\DoxyCodeLine{590 }
\DoxyCodeLine{591   \textcolor{comment}{// Unsets the default value for type T.}}
\DoxyCodeLine{592   \textcolor{keyword}{static} \textcolor{keywordtype}{void} Clear() \{}
\DoxyCodeLine{593     \textcolor{keyword}{delete} producer\_;}
\DoxyCodeLine{594     producer\_ = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{595   \}}
\DoxyCodeLine{596 }
\DoxyCodeLine{597   \textcolor{comment}{// Returns true if and only if the user has set the default value for type T.}}
\DoxyCodeLine{598   \textcolor{keyword}{static} \textcolor{keywordtype}{bool} IsSet() \{ \textcolor{keywordflow}{return} producer\_ != \textcolor{keyword}{nullptr}; \}}
\DoxyCodeLine{599 }
\DoxyCodeLine{600   \textcolor{comment}{// Returns true if T has a default return value set by the user or there}}
\DoxyCodeLine{601   \textcolor{comment}{// exists a built-\/in default value.}}
\DoxyCodeLine{602   \textcolor{keyword}{static} \textcolor{keywordtype}{bool} Exists() \{}
\DoxyCodeLine{603     \textcolor{keywordflow}{return} IsSet() || \mbox{\hyperlink{classtesting_1_1internal_1_1BuiltInDefaultValue}{internal::BuiltInDefaultValue<T>::Exists}}();}
\DoxyCodeLine{604   \}}
\DoxyCodeLine{605 }
\DoxyCodeLine{606   \textcolor{comment}{// Returns the default value for type T if the user has set one;}}
\DoxyCodeLine{607   \textcolor{comment}{// otherwise returns the built-\/in default value. Requires that Exists()}}
\DoxyCodeLine{608   \textcolor{comment}{// is true, which ensures that the return value is well-\/defined.}}
\DoxyCodeLine{609   \textcolor{keyword}{static} T Get() \{}
\DoxyCodeLine{610     \textcolor{keywordflow}{return} producer\_ == \textcolor{keyword}{nullptr} ? \mbox{\hyperlink{classtesting_1_1internal_1_1BuiltInDefaultValue}{internal::BuiltInDefaultValue<T>::Get}}()}
\DoxyCodeLine{611                                 : producer\_-\/>Produce();}
\DoxyCodeLine{612   \}}
\DoxyCodeLine{613 }
\DoxyCodeLine{614  \textcolor{keyword}{private}:}
\DoxyCodeLine{615   \textcolor{keyword}{class }ValueProducer \{}
\DoxyCodeLine{616    \textcolor{keyword}{public}:}
\DoxyCodeLine{617     \textcolor{keyword}{virtual} \string~ValueProducer() \{\}}
\DoxyCodeLine{618     \textcolor{keyword}{virtual} T Produce() = 0;}
\DoxyCodeLine{619   \};}
\DoxyCodeLine{620 }
\DoxyCodeLine{621   \textcolor{keyword}{class }FixedValueProducer : \textcolor{keyword}{public} ValueProducer \{}
\DoxyCodeLine{622    \textcolor{keyword}{public}:}
\DoxyCodeLine{623     \textcolor{keyword}{explicit} FixedValueProducer(T value) : value\_(value) \{\}}
\DoxyCodeLine{624     T Produce()\textcolor{keyword}{ override }\{ \textcolor{keywordflow}{return} value\_; \}}
\DoxyCodeLine{625 }
\DoxyCodeLine{626    \textcolor{keyword}{private}:}
\DoxyCodeLine{627     \textcolor{keyword}{const} T value\_;}
\DoxyCodeLine{628     FixedValueProducer(\textcolor{keyword}{const} FixedValueProducer\&) = \textcolor{keyword}{delete};}
\DoxyCodeLine{629     FixedValueProducer\& operator=(\textcolor{keyword}{const} FixedValueProducer\&) = \textcolor{keyword}{delete};}
\DoxyCodeLine{630   \};}
\DoxyCodeLine{631 }
\DoxyCodeLine{632   \textcolor{keyword}{class }FactoryValueProducer : \textcolor{keyword}{public} ValueProducer \{}
\DoxyCodeLine{633    \textcolor{keyword}{public}:}
\DoxyCodeLine{634     \textcolor{keyword}{explicit} FactoryValueProducer(FactoryFunction factory)}
\DoxyCodeLine{635         : factory\_(factory) \{\}}
\DoxyCodeLine{636     T Produce()\textcolor{keyword}{ override }\{ \textcolor{keywordflow}{return} factory\_(); \}}
\DoxyCodeLine{637 }
\DoxyCodeLine{638    \textcolor{keyword}{private}:}
\DoxyCodeLine{639     \textcolor{keyword}{const} FactoryFunction factory\_;}
\DoxyCodeLine{640     FactoryValueProducer(\textcolor{keyword}{const} FactoryValueProducer\&) = \textcolor{keyword}{delete};}
\DoxyCodeLine{641     FactoryValueProducer\& operator=(\textcolor{keyword}{const} FactoryValueProducer\&) = \textcolor{keyword}{delete};}
\DoxyCodeLine{642   \};}
\DoxyCodeLine{643 }
\DoxyCodeLine{644   \textcolor{keyword}{static} ValueProducer* producer\_;}
\DoxyCodeLine{645 \};}
\DoxyCodeLine{646 }
\DoxyCodeLine{647 \textcolor{comment}{// This partial specialization allows a user to set default values for}}
\DoxyCodeLine{648 \textcolor{comment}{// reference types.}}
\DoxyCodeLine{649 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{650 \textcolor{keyword}{class }\mbox{\hyperlink{classtesting_1_1DefaultValue}{DefaultValue}}<T\&> \{}
\DoxyCodeLine{651  \textcolor{keyword}{public}:}
\DoxyCodeLine{652   \textcolor{comment}{// Sets the default value for type T\&.}}
\DoxyCodeLine{653   \textcolor{keyword}{static} \textcolor{keywordtype}{void} Set(T\& x) \{  \textcolor{comment}{// NOLINT}}
\DoxyCodeLine{654     address\_ = \&x;}
\DoxyCodeLine{655   \}}
\DoxyCodeLine{656 }
\DoxyCodeLine{657   \textcolor{comment}{// Unsets the default value for type T\&.}}
\DoxyCodeLine{658   \textcolor{keyword}{static} \textcolor{keywordtype}{void} Clear() \{ address\_ = \textcolor{keyword}{nullptr}; \}}
\DoxyCodeLine{659 }
\DoxyCodeLine{660   \textcolor{comment}{// Returns true if and only if the user has set the default value for type T\&.}}
\DoxyCodeLine{661   \textcolor{keyword}{static} \textcolor{keywordtype}{bool} IsSet() \{ \textcolor{keywordflow}{return} address\_ != \textcolor{keyword}{nullptr}; \}}
\DoxyCodeLine{662 }
\DoxyCodeLine{663   \textcolor{comment}{// Returns true if T has a default return value set by the user or there}}
\DoxyCodeLine{664   \textcolor{comment}{// exists a built-\/in default value.}}
\DoxyCodeLine{665   \textcolor{keyword}{static} \textcolor{keywordtype}{bool} Exists() \{}
\DoxyCodeLine{666     \textcolor{keywordflow}{return} IsSet() || \mbox{\hyperlink{classtesting_1_1internal_1_1BuiltInDefaultValue}{internal::BuiltInDefaultValue<T\&>::Exists}}();}
\DoxyCodeLine{667   \}}
\DoxyCodeLine{668 }
\DoxyCodeLine{669   \textcolor{comment}{// Returns the default value for type T\& if the user has set one;}}
\DoxyCodeLine{670   \textcolor{comment}{// otherwise returns the built-\/in default value if there is one;}}
\DoxyCodeLine{671   \textcolor{comment}{// otherwise aborts the process.}}
\DoxyCodeLine{672   \textcolor{keyword}{static} T\& Get() \{}
\DoxyCodeLine{673     \textcolor{keywordflow}{return} address\_ == \textcolor{keyword}{nullptr} ? \mbox{\hyperlink{classtesting_1_1internal_1_1BuiltInDefaultValue}{internal::BuiltInDefaultValue<T\&>::Get}}()}
\DoxyCodeLine{674                                : *address\_;}
\DoxyCodeLine{675   \}}
\DoxyCodeLine{676 }
\DoxyCodeLine{677  \textcolor{keyword}{private}:}
\DoxyCodeLine{678   \textcolor{keyword}{static} T* address\_;}
\DoxyCodeLine{679 \};}
\DoxyCodeLine{680 }
\DoxyCodeLine{681 \textcolor{comment}{// This specialization allows DefaultValue<void>::Get() to}}
\DoxyCodeLine{682 \textcolor{comment}{// compile.}}
\DoxyCodeLine{683 \textcolor{keyword}{template} <>}
\DoxyCodeLine{684 \textcolor{keyword}{class }\mbox{\hyperlink{classtesting_1_1DefaultValue}{DefaultValue}}<void> \{}
\DoxyCodeLine{685  \textcolor{keyword}{public}:}
\DoxyCodeLine{686   \textcolor{keyword}{static} \textcolor{keywordtype}{bool} Exists() \{ \textcolor{keywordflow}{return} \textcolor{keyword}{true}; \}}
\DoxyCodeLine{687   \textcolor{keyword}{static} \textcolor{keywordtype}{void} Get() \{\}}
\DoxyCodeLine{688 \};}
\DoxyCodeLine{689 }
\DoxyCodeLine{690 \textcolor{comment}{// Points to the user-\/set default value for type T.}}
\DoxyCodeLine{691 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{692 \textcolor{keyword}{typename} \mbox{\hyperlink{classtesting_1_1DefaultValue}{DefaultValue<T>::ValueProducer}}* \mbox{\hyperlink{classtesting_1_1DefaultValue}{DefaultValue<T>::producer\_}} = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{693 }
\DoxyCodeLine{694 \textcolor{comment}{// Points to the user-\/set default value for type T\&.}}
\DoxyCodeLine{695 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{696 T* \mbox{\hyperlink{classtesting_1_1DefaultValue}{DefaultValue<T\&>::address\_}} = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{697 }
\DoxyCodeLine{698 \textcolor{comment}{// Implement this interface to define an action for function type F.}}
\DoxyCodeLine{699 \textcolor{keyword}{template} <\textcolor{keyword}{typename} F>}
\DoxyCodeLine{700 \textcolor{keyword}{class }\mbox{\hyperlink{classtesting_1_1ActionInterface}{ActionInterface}} \{}
\DoxyCodeLine{701  \textcolor{keyword}{public}:}
\DoxyCodeLine{702   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \mbox{\hyperlink{structtesting_1_1internal_1_1Function}{internal::Function<F>::Result}} Result;}
\DoxyCodeLine{703   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \mbox{\hyperlink{structtesting_1_1internal_1_1Function}{internal::Function<F>::ArgumentTuple}} ArgumentTuple;}
\DoxyCodeLine{704 }
\DoxyCodeLine{705   \mbox{\hyperlink{classtesting_1_1ActionInterface}{ActionInterface}}() \{\}}
\DoxyCodeLine{706   \textcolor{keyword}{virtual} \mbox{\hyperlink{classtesting_1_1ActionInterface}{\string~ActionInterface}}() \{\}}
\DoxyCodeLine{707 }
\DoxyCodeLine{708   \textcolor{comment}{// Performs the action.  This method is not const, as in general an}}
\DoxyCodeLine{709   \textcolor{comment}{// action can have side effects and be stateful.  For example, a}}
\DoxyCodeLine{710   \textcolor{comment}{// get-\/the-\/next-\/element-\/from-\/the-\/collection action will need to}}
\DoxyCodeLine{711   \textcolor{comment}{// remember the current element.}}
\DoxyCodeLine{712   \textcolor{keyword}{virtual} Result Perform(\textcolor{keyword}{const} ArgumentTuple\& args) = 0;}
\DoxyCodeLine{713 }
\DoxyCodeLine{714  \textcolor{keyword}{private}:}
\DoxyCodeLine{715   \mbox{\hyperlink{classtesting_1_1ActionInterface}{ActionInterface}}(\textcolor{keyword}{const} \mbox{\hyperlink{classtesting_1_1ActionInterface}{ActionInterface}}\&) = \textcolor{keyword}{delete};}
\DoxyCodeLine{716   \mbox{\hyperlink{classtesting_1_1ActionInterface}{ActionInterface}}\& operator=(\textcolor{keyword}{const} \mbox{\hyperlink{classtesting_1_1ActionInterface}{ActionInterface}}\&) = \textcolor{keyword}{delete};}
\DoxyCodeLine{717 \};}
\DoxyCodeLine{718 }
\DoxyCodeLine{719 \textcolor{keyword}{template} <\textcolor{keyword}{typename} F>}
\DoxyCodeLine{720 \textcolor{keyword}{class }\mbox{\hyperlink{classtesting_1_1Action}{Action}};}
\DoxyCodeLine{721 }
\DoxyCodeLine{722 \textcolor{comment}{// An Action<R(Args...)> is a copyable and IMMUTABLE (except by assignment)}}
\DoxyCodeLine{723 \textcolor{comment}{// object that represents an action to be taken when a mock function of type}}
\DoxyCodeLine{724 \textcolor{comment}{// R(Args...) is called. The implementation of Action<T> is just a}}
\DoxyCodeLine{725 \textcolor{comment}{// std::shared\_ptr to const ActionInterface<T>. Don't inherit from Action! You}}
\DoxyCodeLine{726 \textcolor{comment}{// can view an object implementing ActionInterface<F> as a concrete action}}
\DoxyCodeLine{727 \textcolor{comment}{// (including its current state), and an Action<F> object as a handle to it.}}
\DoxyCodeLine{728 \textcolor{keyword}{template} <\textcolor{keyword}{typename} R, \textcolor{keyword}{typename}... Args>}
\DoxyCodeLine{729 \textcolor{keyword}{class }\mbox{\hyperlink{classtesting_1_1Action}{Action}}<R(Args...)> \{}
\DoxyCodeLine{730  \textcolor{keyword}{private}:}
\DoxyCodeLine{731   \textcolor{keyword}{using }F = R(Args...);}
\DoxyCodeLine{732 }
\DoxyCodeLine{733   \textcolor{comment}{// Adapter class to allow constructing Action from a legacy ActionInterface.}}
\DoxyCodeLine{734   \textcolor{comment}{// New code should create Actions from functors instead.}}
\DoxyCodeLine{735   \textcolor{keyword}{struct }ActionAdapter \{}
\DoxyCodeLine{736     \textcolor{comment}{// Adapter must be copyable to satisfy std::function requirements.}}
\DoxyCodeLine{737     ::std::shared\_ptr<ActionInterface<F>> impl\_;}
\DoxyCodeLine{738 }
\DoxyCodeLine{739     \textcolor{keyword}{template} <\textcolor{keyword}{typename}... InArgs>}
\DoxyCodeLine{740     \textcolor{keyword}{typename} \mbox{\hyperlink{structtesting_1_1internal_1_1Function}{internal::Function<F>::Result}} operator()(InArgs\&\&... args) \{}
\DoxyCodeLine{741       \textcolor{keywordflow}{return} impl\_-\/>Perform(}
\DoxyCodeLine{742           ::std::forward\_as\_tuple(::std::forward<InArgs>(args)...));}
\DoxyCodeLine{743     \}}
\DoxyCodeLine{744   \};}
\DoxyCodeLine{745 }
\DoxyCodeLine{746   \textcolor{keyword}{template} <\textcolor{keyword}{typename} G>}
\DoxyCodeLine{747   \textcolor{keyword}{using }IsCompatibleFunctor = std::is\_constructible<std::function<F>, G>;}
\DoxyCodeLine{748 }
\DoxyCodeLine{749  \textcolor{keyword}{public}:}
\DoxyCodeLine{750   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \mbox{\hyperlink{structtesting_1_1internal_1_1Function}{internal::Function<F>::Result}} Result;}
\DoxyCodeLine{751   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \mbox{\hyperlink{structtesting_1_1internal_1_1Function}{internal::Function<F>::ArgumentTuple}} ArgumentTuple;}
\DoxyCodeLine{752 }
\DoxyCodeLine{753   \textcolor{comment}{// Constructs a null Action.  Needed for storing Action objects in}}
\DoxyCodeLine{754   \textcolor{comment}{// STL containers.}}
\DoxyCodeLine{755   \mbox{\hyperlink{classtesting_1_1Action}{Action}}() \{\}}
\DoxyCodeLine{756 }
\DoxyCodeLine{757   \textcolor{comment}{// Construct an Action from a specified callable.}}
\DoxyCodeLine{758   \textcolor{comment}{// This cannot take std::function directly, because then Action would not be}}
\DoxyCodeLine{759   \textcolor{comment}{// directly constructible from lambda (it would require two conversions).}}
\DoxyCodeLine{760   \textcolor{keyword}{template} <}
\DoxyCodeLine{761       \textcolor{keyword}{typename} G,}
\DoxyCodeLine{762       \textcolor{keyword}{typename} = \textcolor{keyword}{typename} std::enable\_if<\mbox{\hyperlink{structtesting_1_1internal_1_1disjunction}{internal::disjunction}}<}
\DoxyCodeLine{763           IsCompatibleFunctor<G>, std::is\_constructible<std::function<Result()>,}
\DoxyCodeLine{764                                                         G>>::value>::type>}
\DoxyCodeLine{765   \mbox{\hyperlink{classtesting_1_1Action}{Action}}(G\&\& fun) \{  \textcolor{comment}{// NOLINT}}
\DoxyCodeLine{766     Init(::std::forward<G>(fun), IsCompatibleFunctor<G>());}
\DoxyCodeLine{767   \}}
\DoxyCodeLine{768 }
\DoxyCodeLine{769   \textcolor{comment}{// Constructs an Action from its implementation.}}
\DoxyCodeLine{770   \textcolor{keyword}{explicit} \mbox{\hyperlink{classtesting_1_1Action}{Action}}(\mbox{\hyperlink{classtesting_1_1ActionInterface}{ActionInterface<F>}}* impl)}
\DoxyCodeLine{771       : fun\_(ActionAdapter\{::std::shared\_ptr<ActionInterface<F>>(impl)\}) \{\}}
\DoxyCodeLine{772 }
\DoxyCodeLine{773   \textcolor{comment}{// This constructor allows us to turn an Action<Func> object into an}}
\DoxyCodeLine{774   \textcolor{comment}{// Action<F>, as long as F's arguments can be implicitly converted}}
\DoxyCodeLine{775   \textcolor{comment}{// to Func's and Func's return type can be implicitly converted to F's.}}
\DoxyCodeLine{776   \textcolor{keyword}{template} <\textcolor{keyword}{typename} Func>}
\DoxyCodeLine{777   \mbox{\hyperlink{classtesting_1_1Action}{Action}}(\textcolor{keyword}{const} \mbox{\hyperlink{classtesting_1_1Action}{Action<Func>}}\& action)  \textcolor{comment}{// NOLINT}}
\DoxyCodeLine{778       : fun\_(action.fun\_) \{\}}
\DoxyCodeLine{779 }
\DoxyCodeLine{780   \textcolor{comment}{// Returns true if and only if this is the DoDefault() action.}}
\DoxyCodeLine{781   \textcolor{keywordtype}{bool} IsDoDefault()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} fun\_ == \textcolor{keyword}{nullptr}; \}}
\DoxyCodeLine{782 }
\DoxyCodeLine{783   \textcolor{comment}{// Performs the action.  Note that this method is const even though}}
\DoxyCodeLine{784   \textcolor{comment}{// the corresponding method in ActionInterface is not.  The reason}}
\DoxyCodeLine{785   \textcolor{comment}{// is that a const Action<F> means that it cannot be re-\/bound to}}
\DoxyCodeLine{786   \textcolor{comment}{// another concrete action, not that the concrete action it binds to}}
\DoxyCodeLine{787   \textcolor{comment}{// cannot change state.  (Think of the difference between a const}}
\DoxyCodeLine{788   \textcolor{comment}{// pointer and a pointer to const.)}}
\DoxyCodeLine{789   Result Perform(ArgumentTuple args)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{790     \textcolor{keywordflow}{if} (IsDoDefault()) \{}
\DoxyCodeLine{791       internal::IllegalDoDefault(\_\_FILE\_\_, \_\_LINE\_\_);}
\DoxyCodeLine{792     \}}
\DoxyCodeLine{793     \textcolor{keywordflow}{return} internal::Apply(fun\_, ::std::move(args));}
\DoxyCodeLine{794   \}}
\DoxyCodeLine{795 }
\DoxyCodeLine{796   \textcolor{comment}{// An action can be used as a OnceAction, since it's obviously safe to call it}}
\DoxyCodeLine{797   \textcolor{comment}{// once.}}
\DoxyCodeLine{798   \textcolor{keyword}{operator} \mbox{\hyperlink{classtesting_1_1OnceAction}{OnceAction<F>}}()\textcolor{keyword}{ const }\{  \textcolor{comment}{// NOLINT}}
\DoxyCodeLine{799     \textcolor{comment}{// Return a OnceAction-\/compatible callable that calls Perform with the}}
\DoxyCodeLine{800     \textcolor{comment}{// arguments it is provided. We could instead just return fun\_, but then}}
\DoxyCodeLine{801     \textcolor{comment}{// we'd need to handle the IsDoDefault() case separately.}}
\DoxyCodeLine{802     \textcolor{keyword}{struct }OA \{}
\DoxyCodeLine{803       \mbox{\hyperlink{classtesting_1_1Action}{Action<F>}} action;}
\DoxyCodeLine{804 }
\DoxyCodeLine{805       R operator()(Args... args) \&\& \{}
\DoxyCodeLine{806         \textcolor{keywordflow}{return} action.Perform(}
\DoxyCodeLine{807             std::forward\_as\_tuple(std::forward<Args>(args)...));}
\DoxyCodeLine{808       \}}
\DoxyCodeLine{809     \};}
\DoxyCodeLine{810 }
\DoxyCodeLine{811     \textcolor{keywordflow}{return} OA\{*\textcolor{keyword}{this}\};}
\DoxyCodeLine{812   \}}
\DoxyCodeLine{813 }
\DoxyCodeLine{814  \textcolor{keyword}{private}:}
\DoxyCodeLine{815   \textcolor{keyword}{template} <\textcolor{keyword}{typename} G>}
\DoxyCodeLine{816   \textcolor{keyword}{friend} \textcolor{keyword}{class }\mbox{\hyperlink{classtesting_1_1Action}{Action}};}
\DoxyCodeLine{817 }
\DoxyCodeLine{818   \textcolor{keyword}{template} <\textcolor{keyword}{typename} G>}
\DoxyCodeLine{819   \textcolor{keywordtype}{void} Init(G\&\& g, ::std::true\_type) \{}
\DoxyCodeLine{820     fun\_ = ::std::forward<G>(g);}
\DoxyCodeLine{821   \}}
\DoxyCodeLine{822 }
\DoxyCodeLine{823   \textcolor{keyword}{template} <\textcolor{keyword}{typename} G>}
\DoxyCodeLine{824   \textcolor{keywordtype}{void} Init(G\&\& g, ::std::false\_type) \{}
\DoxyCodeLine{825     fun\_ = IgnoreArgs<typename ::std::decay<G>::type>\{::std::forward<G>(g)\};}
\DoxyCodeLine{826   \}}
\DoxyCodeLine{827 }
\DoxyCodeLine{828   \textcolor{keyword}{template} <\textcolor{keyword}{typename} FunctionImpl>}
\DoxyCodeLine{829   \textcolor{keyword}{struct }IgnoreArgs \{}
\DoxyCodeLine{830     \textcolor{keyword}{template} <\textcolor{keyword}{typename}... InArgs>}
\DoxyCodeLine{831     Result operator()(\textcolor{keyword}{const} InArgs\&...)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{832       \textcolor{keywordflow}{return} function\_impl();}
\DoxyCodeLine{833     \}}
\DoxyCodeLine{834 }
\DoxyCodeLine{835     FunctionImpl function\_impl;}
\DoxyCodeLine{836   \};}
\DoxyCodeLine{837 }
\DoxyCodeLine{838   \textcolor{comment}{// fun\_ is an empty function if and only if this is the DoDefault() action.}}
\DoxyCodeLine{839   ::std::function<F> fun\_;}
\DoxyCodeLine{840 \};}
\DoxyCodeLine{841 }
\DoxyCodeLine{842 \textcolor{comment}{// The PolymorphicAction class template makes it easy to implement a}}
\DoxyCodeLine{843 \textcolor{comment}{// polymorphic action (i.e. an action that can be used in mock}}
\DoxyCodeLine{844 \textcolor{comment}{// functions of than one type, e.g. Return()).}}
\DoxyCodeLine{845 \textcolor{comment}{//}}
\DoxyCodeLine{846 \textcolor{comment}{// To define a polymorphic action, a user first provides a COPYABLE}}
\DoxyCodeLine{847 \textcolor{comment}{// implementation class that has a Perform() method template:}}
\DoxyCodeLine{848 \textcolor{comment}{//}}
\DoxyCodeLine{849 \textcolor{comment}{//   class FooAction \{}}
\DoxyCodeLine{850 \textcolor{comment}{//    public:}}
\DoxyCodeLine{851 \textcolor{comment}{//     template <typename Result, typename ArgumentTuple>}}
\DoxyCodeLine{852 \textcolor{comment}{//     Result Perform(const ArgumentTuple\& args) const \{}}
\DoxyCodeLine{853 \textcolor{comment}{//       // Processes the arguments and returns a result, using}}
\DoxyCodeLine{854 \textcolor{comment}{//       // std::get<N>(args) to get the N-\/th (0-\/based) argument in the tuple.}}
\DoxyCodeLine{855 \textcolor{comment}{//     \}}}
\DoxyCodeLine{856 \textcolor{comment}{//     ...}}
\DoxyCodeLine{857 \textcolor{comment}{//   \};}}
\DoxyCodeLine{858 \textcolor{comment}{//}}
\DoxyCodeLine{859 \textcolor{comment}{// Then the user creates the polymorphic action using}}
\DoxyCodeLine{860 \textcolor{comment}{// MakePolymorphicAction(object) where object has type FooAction.  See}}
\DoxyCodeLine{861 \textcolor{comment}{// the definition of Return(void) and SetArgumentPointee<N>(value) for}}
\DoxyCodeLine{862 \textcolor{comment}{// complete examples.}}
\DoxyCodeLine{863 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Impl>}
\DoxyCodeLine{864 \textcolor{keyword}{class }\mbox{\hyperlink{classtesting_1_1PolymorphicAction}{PolymorphicAction}} \{}
\DoxyCodeLine{865  \textcolor{keyword}{public}:}
\DoxyCodeLine{866   \textcolor{keyword}{explicit} \mbox{\hyperlink{classtesting_1_1PolymorphicAction}{PolymorphicAction}}(\textcolor{keyword}{const} Impl\& impl) : impl\_(impl) \{\}}
\DoxyCodeLine{867 }
\DoxyCodeLine{868   \textcolor{keyword}{template} <\textcolor{keyword}{typename} F>}
\DoxyCodeLine{869   \textcolor{keyword}{operator} \mbox{\hyperlink{classtesting_1_1Action}{Action<F>}}()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{870     \textcolor{keywordflow}{return} \mbox{\hyperlink{classtesting_1_1Action}{Action<F>}}(\textcolor{keyword}{new} MonomorphicImpl<F>(impl\_));}
\DoxyCodeLine{871   \}}
\DoxyCodeLine{872 }
\DoxyCodeLine{873  \textcolor{keyword}{private}:}
\DoxyCodeLine{874   \textcolor{keyword}{template} <\textcolor{keyword}{typename} F>}
\DoxyCodeLine{875   \textcolor{keyword}{class }MonomorphicImpl : \textcolor{keyword}{public} \mbox{\hyperlink{classtesting_1_1ActionInterface}{ActionInterface}}<F> \{}
\DoxyCodeLine{876    \textcolor{keyword}{public}:}
\DoxyCodeLine{877     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \mbox{\hyperlink{structtesting_1_1internal_1_1Function}{internal::Function<F>::Result}} Result;}
\DoxyCodeLine{878     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \mbox{\hyperlink{structtesting_1_1internal_1_1Function}{internal::Function<F>::ArgumentTuple}} ArgumentTuple;}
\DoxyCodeLine{879 }
\DoxyCodeLine{880     \textcolor{keyword}{explicit} MonomorphicImpl(\textcolor{keyword}{const} Impl\& impl) : impl\_(impl) \{\}}
\DoxyCodeLine{881 }
\DoxyCodeLine{882     Result Perform(\textcolor{keyword}{const} ArgumentTuple\& args)\textcolor{keyword}{ override }\{}
\DoxyCodeLine{883       \textcolor{keywordflow}{return} impl\_.template Perform<Result>(args);}
\DoxyCodeLine{884     \}}
\DoxyCodeLine{885 }
\DoxyCodeLine{886    \textcolor{keyword}{private}:}
\DoxyCodeLine{887     Impl impl\_;}
\DoxyCodeLine{888   \};}
\DoxyCodeLine{889 }
\DoxyCodeLine{890   Impl impl\_;}
\DoxyCodeLine{891 \};}
\DoxyCodeLine{892 }
\DoxyCodeLine{893 \textcolor{comment}{// Creates an Action from its implementation and returns it.  The}}
\DoxyCodeLine{894 \textcolor{comment}{// created Action object owns the implementation.}}
\DoxyCodeLine{895 \textcolor{keyword}{template} <\textcolor{keyword}{typename} F>}
\DoxyCodeLine{896 \mbox{\hyperlink{classtesting_1_1Action}{Action<F>}} MakeAction(\mbox{\hyperlink{classtesting_1_1ActionInterface}{ActionInterface<F>}}* impl) \{}
\DoxyCodeLine{897   \textcolor{keywordflow}{return} \mbox{\hyperlink{classtesting_1_1Action}{Action<F>}}(impl);}
\DoxyCodeLine{898 \}}
\DoxyCodeLine{899 }
\DoxyCodeLine{900 \textcolor{comment}{// Creates a polymorphic action from its implementation.  This is}}
\DoxyCodeLine{901 \textcolor{comment}{// easier to use than the PolymorphicAction<Impl> constructor as it}}
\DoxyCodeLine{902 \textcolor{comment}{// doesn't require you to explicitly write the template argument, e.g.}}
\DoxyCodeLine{903 \textcolor{comment}{//}}
\DoxyCodeLine{904 \textcolor{comment}{//   MakePolymorphicAction(foo);}}
\DoxyCodeLine{905 \textcolor{comment}{// vs}}
\DoxyCodeLine{906 \textcolor{comment}{//   PolymorphicAction<TypeOfFoo>(foo);}}
\DoxyCodeLine{907 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Impl>}
\DoxyCodeLine{908 \textcolor{keyword}{inline} PolymorphicAction<Impl> MakePolymorphicAction(\textcolor{keyword}{const} Impl\& impl) \{}
\DoxyCodeLine{909   \textcolor{keywordflow}{return} PolymorphicAction<Impl>(impl);}
\DoxyCodeLine{910 \}}
\DoxyCodeLine{911 }
\DoxyCodeLine{912 \textcolor{keyword}{namespace }internal \{}
\DoxyCodeLine{913 }
\DoxyCodeLine{914 \textcolor{comment}{// Helper struct to specialize ReturnAction to execute a move instead of a copy}}
\DoxyCodeLine{915 \textcolor{comment}{// on return. Useful for move-\/only types, but could be used on any type.}}
\DoxyCodeLine{916 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{917 \textcolor{keyword}{struct }\mbox{\hyperlink{structtesting_1_1internal_1_1ByMoveWrapper}{ByMoveWrapper}} \{}
\DoxyCodeLine{918   \textcolor{keyword}{explicit} \mbox{\hyperlink{structtesting_1_1internal_1_1ByMoveWrapper}{ByMoveWrapper}}(T value) : payload(std::move(value)) \{\}}
\DoxyCodeLine{919   T payload;}
\DoxyCodeLine{920 \};}
\DoxyCodeLine{921 }
\DoxyCodeLine{922 \textcolor{comment}{// The general implementation of Return(R). Specializations follow below.}}
\DoxyCodeLine{923 \textcolor{keyword}{template} <\textcolor{keyword}{typename} R>}
\DoxyCodeLine{924 \textcolor{keyword}{class }\mbox{\hyperlink{classtesting_1_1internal_1_1ReturnAction}{ReturnAction}} final \{}
\DoxyCodeLine{925  \textcolor{keyword}{public}:}
\DoxyCodeLine{926   \textcolor{keyword}{explicit} \mbox{\hyperlink{classtesting_1_1internal_1_1ReturnAction}{ReturnAction}}(R value) : value\_(std::move(value)) \{\}}
\DoxyCodeLine{927 }
\DoxyCodeLine{928   \textcolor{keyword}{template} <\textcolor{keyword}{typename} U, \textcolor{keyword}{typename}... Args,}
\DoxyCodeLine{929             \textcolor{keyword}{typename} = \textcolor{keyword}{typename} std::enable\_if<\mbox{\hyperlink{structtesting_1_1internal_1_1conjunction}{conjunction}}<}
\DoxyCodeLine{930                 \textcolor{comment}{// See the requirements documented on Return.}}
\DoxyCodeLine{931                 \mbox{\hyperlink{structtesting_1_1internal_1_1negation}{negation<std::is\_same<void, U>}}>,  \textcolor{comment}{//}}
\DoxyCodeLine{932                 \mbox{\hyperlink{structtesting_1_1internal_1_1negation}{negation<std::is\_reference<U>}}>,   \textcolor{comment}{//}}
\DoxyCodeLine{933                 std::is\_convertible<R, U>,        \textcolor{comment}{//}}
\DoxyCodeLine{934                 std::is\_move\_constructible<U>>::value>::type>}
\DoxyCodeLine{935   \textcolor{keyword}{operator} \mbox{\hyperlink{classtesting_1_1OnceAction}{OnceAction}}<U(Args...)>() \&\& \{  \textcolor{comment}{// NOLINT}}
\DoxyCodeLine{936     \textcolor{keywordflow}{return} Impl<U>(std::move(value\_));}
\DoxyCodeLine{937   \}}
\DoxyCodeLine{938 }
\DoxyCodeLine{939   \textcolor{keyword}{template} <\textcolor{keyword}{typename} U, \textcolor{keyword}{typename}... Args,}
\DoxyCodeLine{940             \textcolor{keyword}{typename} = \textcolor{keyword}{typename} std::enable\_if<\mbox{\hyperlink{structtesting_1_1internal_1_1conjunction}{conjunction}}<}
\DoxyCodeLine{941                 \textcolor{comment}{// See the requirements documented on Return.}}
\DoxyCodeLine{942                 \mbox{\hyperlink{structtesting_1_1internal_1_1negation}{negation<std::is\_same<void, U>}}>,   \textcolor{comment}{//}}
\DoxyCodeLine{943                 \mbox{\hyperlink{structtesting_1_1internal_1_1negation}{negation<std::is\_reference<U>}}>,    \textcolor{comment}{//}}
\DoxyCodeLine{944                 std::is\_convertible<const R\&, U>,  \textcolor{comment}{//}}
\DoxyCodeLine{945                 std::is\_copy\_constructible<U>>::value>::type>}
\DoxyCodeLine{946   \textcolor{keyword}{operator} \mbox{\hyperlink{classtesting_1_1Action}{Action}}<U(Args...)>() \textcolor{keyword}{const} \{  \textcolor{comment}{// NOLINT}}
\DoxyCodeLine{947     \textcolor{keywordflow}{return} Impl<U>(value\_);}
\DoxyCodeLine{948   \}}
\DoxyCodeLine{949 }
\DoxyCodeLine{950  \textcolor{keyword}{private}:}
\DoxyCodeLine{951   \textcolor{comment}{// Implements the Return(x) action for a mock function that returns type U.}}
\DoxyCodeLine{952   \textcolor{keyword}{template} <\textcolor{keyword}{typename} U>}
\DoxyCodeLine{953   \textcolor{keyword}{class }Impl final \{}
\DoxyCodeLine{954    \textcolor{keyword}{public}:}
\DoxyCodeLine{955     \textcolor{comment}{// The constructor used when the return value is allowed to move from the}}
\DoxyCodeLine{956     \textcolor{comment}{// input value (i.e. we are converting to OnceAction).}}
\DoxyCodeLine{957     \textcolor{keyword}{explicit} Impl(R\&\& input\_value)}
\DoxyCodeLine{958         : state\_(\textcolor{keyword}{new} State(std::move(input\_value))) \{\}}
\DoxyCodeLine{959 }
\DoxyCodeLine{960     \textcolor{comment}{// The constructor used when the return value is not allowed to move from}}
\DoxyCodeLine{961     \textcolor{comment}{// the input value (i.e. we are converting to Action).}}
\DoxyCodeLine{962     \textcolor{keyword}{explicit} Impl(\textcolor{keyword}{const} R\& input\_value) : state\_(\textcolor{keyword}{new} State(input\_value)) \{\}}
\DoxyCodeLine{963 }
\DoxyCodeLine{964     U operator()() \&\& \{ \textcolor{keywordflow}{return} std::move(state\_-\/>value); \}}
\DoxyCodeLine{965     U operator()() \textcolor{keyword}{const}\& \{ \textcolor{keywordflow}{return} state\_-\/>value; \}}
\DoxyCodeLine{966 }
\DoxyCodeLine{967    \textcolor{keyword}{private}:}
\DoxyCodeLine{968     \textcolor{comment}{// We put our state on the heap so that the compiler-\/generated copy/move}}
\DoxyCodeLine{969     \textcolor{comment}{// constructors work correctly even when U is a reference-\/like type. This is}}
\DoxyCodeLine{970     \textcolor{comment}{// necessary only because we eagerly create State::value (see the note on}}
\DoxyCodeLine{971     \textcolor{comment}{// that symbol for details). If we instead had only the input value as a}}
\DoxyCodeLine{972     \textcolor{comment}{// member then the default constructors would work fine.}}
\DoxyCodeLine{973     \textcolor{comment}{//}}
\DoxyCodeLine{974     \textcolor{comment}{// For example, when R is std::string and U is std::string\_view, value is a}}
\DoxyCodeLine{975     \textcolor{comment}{// reference to the string backed by input\_value. The copy constructor would}}
\DoxyCodeLine{976     \textcolor{comment}{// copy both, so that we wind up with a new input\_value object (with the}}
\DoxyCodeLine{977     \textcolor{comment}{// same contents) and a reference to the *old* input\_value object rather}}
\DoxyCodeLine{978     \textcolor{comment}{// than the new one.}}
\DoxyCodeLine{979     \textcolor{keyword}{struct }State \{}
\DoxyCodeLine{980       \textcolor{keyword}{explicit} State(\textcolor{keyword}{const} R\& input\_value\_in)}
\DoxyCodeLine{981           : input\_value(input\_value\_in),}
\DoxyCodeLine{982             \textcolor{comment}{// Make an implicit conversion to Result before initializing the U}}
\DoxyCodeLine{983             \textcolor{comment}{// object we store, avoiding calling any explicit constructor of U}}
\DoxyCodeLine{984             \textcolor{comment}{// from R.}}
\DoxyCodeLine{985             \textcolor{comment}{//}}
\DoxyCodeLine{986             \textcolor{comment}{// This simulates the language rules: a function with return type U}}
\DoxyCodeLine{987             \textcolor{comment}{// that does `return R()` requires R to be implicitly convertible to}}
\DoxyCodeLine{988             \textcolor{comment}{// U, and uses that path for the conversion, even U Result has an}}
\DoxyCodeLine{989             \textcolor{comment}{// explicit constructor from R.}}
\DoxyCodeLine{990             value(ImplicitCast\_<U>(internal::as\_const(input\_value))) \{\}}
\DoxyCodeLine{991 }
\DoxyCodeLine{992       \textcolor{comment}{// As above, but for the case where we're moving from the ReturnAction}}
\DoxyCodeLine{993       \textcolor{comment}{// object because it's being used as a OnceAction.}}
\DoxyCodeLine{994       \textcolor{keyword}{explicit} State(R\&\& input\_value\_in)}
\DoxyCodeLine{995           : input\_value(std::move(input\_value\_in)),}
\DoxyCodeLine{996             \textcolor{comment}{// For the same reason as above we make an implicit conversion to U}}
\DoxyCodeLine{997             \textcolor{comment}{// before initializing the value.}}
\DoxyCodeLine{998             \textcolor{comment}{//}}
\DoxyCodeLine{999             \textcolor{comment}{// Unlike above we provide the input value as an rvalue to the}}
\DoxyCodeLine{1000             \textcolor{comment}{// implicit conversion because this is a OnceAction: it's fine if it}}
\DoxyCodeLine{1001             \textcolor{comment}{// wants to consume the input value.}}
\DoxyCodeLine{1002             value(ImplicitCast\_<U>(std::move(input\_value))) \{\}}
\DoxyCodeLine{1003 }
\DoxyCodeLine{1004       \textcolor{comment}{// A copy of the value originally provided by the user. We retain this in}}
\DoxyCodeLine{1005       \textcolor{comment}{// addition to the value of the mock function's result type below in case}}
\DoxyCodeLine{1006       \textcolor{comment}{// the latter is a reference-\/like type. See the std::string\_view example}}
\DoxyCodeLine{1007       \textcolor{comment}{// in the documentation on Return.}}
\DoxyCodeLine{1008       R input\_value;}
\DoxyCodeLine{1009 }
\DoxyCodeLine{1010       \textcolor{comment}{// The value we actually return, as the type returned by the mock function}}
\DoxyCodeLine{1011       \textcolor{comment}{// itself.}}
\DoxyCodeLine{1012       \textcolor{comment}{//}}
\DoxyCodeLine{1013       \textcolor{comment}{// We eagerly initialize this here, rather than lazily doing the implicit}}
\DoxyCodeLine{1014       \textcolor{comment}{// conversion automatically each time Perform is called, for historical}}
\DoxyCodeLine{1015       \textcolor{comment}{// reasons: in 2009-\/11, commit a070cbd91c (Google changelist 13540126)}}
\DoxyCodeLine{1016       \textcolor{comment}{// made the Action<U()> conversion operator eagerly convert the R value to}}
\DoxyCodeLine{1017       \textcolor{comment}{// U, but without keeping the R alive. This broke the use case discussed}}
\DoxyCodeLine{1018       \textcolor{comment}{// in the documentation for Return, making reference-\/like types such as}}
\DoxyCodeLine{1019       \textcolor{comment}{// std::string\_view not safe to use as U where the input type R is a}}
\DoxyCodeLine{1020       \textcolor{comment}{// value-\/like type such as std::string.}}
\DoxyCodeLine{1021       \textcolor{comment}{//}}
\DoxyCodeLine{1022       \textcolor{comment}{// The example the commit gave was not very clear, nor was the issue}}
\DoxyCodeLine{1023       \textcolor{comment}{// thread (https://github.com/google/googlemock/issues/86), but it seems}}
\DoxyCodeLine{1024       \textcolor{comment}{// the worry was about reference-\/like input types R that flatten to a}}
\DoxyCodeLine{1025       \textcolor{comment}{// value-\/like type U when being implicitly converted. An example of this}}
\DoxyCodeLine{1026       \textcolor{comment}{// is std::vector<bool>::reference, which is often a proxy type with an}}
\DoxyCodeLine{1027       \textcolor{comment}{// reference to the underlying vector:}}
\DoxyCodeLine{1028       \textcolor{comment}{//}}
\DoxyCodeLine{1029       \textcolor{comment}{//     // Helper method: have the mock function return bools according}}
\DoxyCodeLine{1030       \textcolor{comment}{//     // to the supplied script.}}
\DoxyCodeLine{1031       \textcolor{comment}{//     void SetActions(MockFunction<bool(size\_t)>\& mock,}}
\DoxyCodeLine{1032       \textcolor{comment}{//                     const std::vector<bool>\& script) \{}}
\DoxyCodeLine{1033       \textcolor{comment}{//       for (size\_t i = 0; i < script.size(); ++i) \{}}
\DoxyCodeLine{1034       \textcolor{comment}{//         EXPECT\_CALL(mock, Call(i)).WillOnce(Return(script[i]));}}
\DoxyCodeLine{1035       \textcolor{comment}{//       \}}}
\DoxyCodeLine{1036       \textcolor{comment}{//     \}}}
\DoxyCodeLine{1037       \textcolor{comment}{//}}
\DoxyCodeLine{1038       \textcolor{comment}{//     TEST(Foo, Bar) \{}}
\DoxyCodeLine{1039       \textcolor{comment}{//       // Set actions using a temporary vector, whose operator[]}}
\DoxyCodeLine{1040       \textcolor{comment}{//       // returns proxy objects that references that will be}}
\DoxyCodeLine{1041       \textcolor{comment}{//       // dangling once the call to SetActions finishes and the}}
\DoxyCodeLine{1042       \textcolor{comment}{//       // vector is destroyed.}}
\DoxyCodeLine{1043       \textcolor{comment}{//       MockFunction<bool(size\_t)> mock;}}
\DoxyCodeLine{1044       \textcolor{comment}{//       SetActions(mock, \{false, true\});}}
\DoxyCodeLine{1045       \textcolor{comment}{//}}
\DoxyCodeLine{1046       \textcolor{comment}{//       EXPECT\_FALSE(mock.AsStdFunction()(0));}}
\DoxyCodeLine{1047       \textcolor{comment}{//       EXPECT\_TRUE(mock.AsStdFunction()(1));}}
\DoxyCodeLine{1048       \textcolor{comment}{//     \}}}
\DoxyCodeLine{1049       \textcolor{comment}{//}}
\DoxyCodeLine{1050       \textcolor{comment}{// This eager conversion helps with a simple case like this, but doesn't}}
\DoxyCodeLine{1051       \textcolor{comment}{// fully make these types work in general. For example the following still}}
\DoxyCodeLine{1052       \textcolor{comment}{// uses a dangling reference:}}
\DoxyCodeLine{1053       \textcolor{comment}{//}}
\DoxyCodeLine{1054       \textcolor{comment}{//     TEST(Foo, Baz) \{}}
\DoxyCodeLine{1055       \textcolor{comment}{//       MockFunction<std::vector<std::string>()> mock;}}
\DoxyCodeLine{1056       \textcolor{comment}{//}}
\DoxyCodeLine{1057       \textcolor{comment}{//       // Return the same vector twice, and then the empty vector}}
\DoxyCodeLine{1058       \textcolor{comment}{//       // thereafter.}}
\DoxyCodeLine{1059       \textcolor{comment}{//       auto action = Return(std::initializer\_list<std::string>\{}}
\DoxyCodeLine{1060       \textcolor{comment}{//           "{}taco"{}, "{}burrito"{},}}
\DoxyCodeLine{1061       \textcolor{comment}{//       \});}}
\DoxyCodeLine{1062       \textcolor{comment}{//}}
\DoxyCodeLine{1063       \textcolor{comment}{//       EXPECT\_CALL(mock, Call)}}
\DoxyCodeLine{1064       \textcolor{comment}{//           .WillOnce(action)}}
\DoxyCodeLine{1065       \textcolor{comment}{//           .WillOnce(action)}}
\DoxyCodeLine{1066       \textcolor{comment}{//           .WillRepeatedly(Return(std::vector<std::string>\{\}));}}
\DoxyCodeLine{1067       \textcolor{comment}{//}}
\DoxyCodeLine{1068       \textcolor{comment}{//       EXPECT\_THAT(mock.AsStdFunction()(),}}
\DoxyCodeLine{1069       \textcolor{comment}{//                   ElementsAre("{}taco"{}, "{}burrito"{}));}}
\DoxyCodeLine{1070       \textcolor{comment}{//       EXPECT\_THAT(mock.AsStdFunction()(),}}
\DoxyCodeLine{1071       \textcolor{comment}{//                   ElementsAre("{}taco"{}, "{}burrito"{}));}}
\DoxyCodeLine{1072       \textcolor{comment}{//       EXPECT\_THAT(mock.AsStdFunction()(), IsEmpty());}}
\DoxyCodeLine{1073       \textcolor{comment}{//     \}}}
\DoxyCodeLine{1074       \textcolor{comment}{//}}
\DoxyCodeLine{1075       U value;}
\DoxyCodeLine{1076     \};}
\DoxyCodeLine{1077 }
\DoxyCodeLine{1078     \textcolor{keyword}{const} std::shared\_ptr<State> state\_;}
\DoxyCodeLine{1079   \};}
\DoxyCodeLine{1080 }
\DoxyCodeLine{1081   R value\_;}
\DoxyCodeLine{1082 \};}
\DoxyCodeLine{1083 }
\DoxyCodeLine{1084 \textcolor{comment}{// A specialization of ReturnAction<R> when R is ByMoveWrapper<T> for some T.}}
\DoxyCodeLine{1085 \textcolor{comment}{//}}
\DoxyCodeLine{1086 \textcolor{comment}{// This version applies the type system-\/defeating hack of moving from T even in}}
\DoxyCodeLine{1087 \textcolor{comment}{// the const call operator, checking at runtime that it isn't called more than}}
\DoxyCodeLine{1088 \textcolor{comment}{// once, since the user has declared their intent to do so by using ByMove.}}
\DoxyCodeLine{1089 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{1090 \textcolor{keyword}{class }\mbox{\hyperlink{classtesting_1_1internal_1_1ReturnAction}{ReturnAction}}<\mbox{\hyperlink{structtesting_1_1internal_1_1ByMoveWrapper}{ByMoveWrapper}}<T>> final \{}
\DoxyCodeLine{1091  \textcolor{keyword}{public}:}
\DoxyCodeLine{1092   \textcolor{keyword}{explicit} \mbox{\hyperlink{classtesting_1_1internal_1_1ReturnAction}{ReturnAction}}(\mbox{\hyperlink{structtesting_1_1internal_1_1ByMoveWrapper}{ByMoveWrapper<T>}} wrapper)}
\DoxyCodeLine{1093       : state\_(\textcolor{keyword}{new} State(std::move(wrapper.payload))) \{\}}
\DoxyCodeLine{1094 }
\DoxyCodeLine{1095   T operator()()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{1096     GTEST\_CHECK\_(!state\_-\/>called)}
\DoxyCodeLine{1097         << \textcolor{stringliteral}{"{}A ByMove() action must be performed at most once."{}};}
\DoxyCodeLine{1098 }
\DoxyCodeLine{1099     state\_-\/>called = \textcolor{keyword}{true};}
\DoxyCodeLine{1100     \textcolor{keywordflow}{return} std::move(state\_-\/>value);}
\DoxyCodeLine{1101   \}}
\DoxyCodeLine{1102 }
\DoxyCodeLine{1103  \textcolor{keyword}{private}:}
\DoxyCodeLine{1104   \textcolor{comment}{// We store our state on the heap so that we are copyable as required by}}
\DoxyCodeLine{1105   \textcolor{comment}{// Action, despite the fact that we are stateful and T may not be copyable.}}
\DoxyCodeLine{1106   \textcolor{keyword}{struct }State \{}
\DoxyCodeLine{1107     \textcolor{keyword}{explicit} State(T\&\& value\_in) : value(std::move(value\_in)) \{\}}
\DoxyCodeLine{1108 }
\DoxyCodeLine{1109     T value;}
\DoxyCodeLine{1110     \textcolor{keywordtype}{bool} called = \textcolor{keyword}{false};}
\DoxyCodeLine{1111   \};}
\DoxyCodeLine{1112 }
\DoxyCodeLine{1113   \textcolor{keyword}{const} std::shared\_ptr<State> state\_;}
\DoxyCodeLine{1114 \};}
\DoxyCodeLine{1115 }
\DoxyCodeLine{1116 \textcolor{comment}{// Implements the ReturnNull() action.}}
\DoxyCodeLine{1117 \textcolor{keyword}{class }\mbox{\hyperlink{classtesting_1_1internal_1_1ReturnNullAction}{ReturnNullAction}} \{}
\DoxyCodeLine{1118  \textcolor{keyword}{public}:}
\DoxyCodeLine{1119   \textcolor{comment}{// Allows ReturnNull() to be used in any pointer-\/returning function. In C++11}}
\DoxyCodeLine{1120   \textcolor{comment}{// this is enforced by returning nullptr, and in non-\/C++11 by asserting a}}
\DoxyCodeLine{1121   \textcolor{comment}{// pointer type on compile time.}}
\DoxyCodeLine{1122   \textcolor{keyword}{template} <\textcolor{keyword}{typename} Result, \textcolor{keyword}{typename} ArgumentTuple>}
\DoxyCodeLine{1123   \textcolor{keyword}{static} Result Perform(\textcolor{keyword}{const} ArgumentTuple\&) \{}
\DoxyCodeLine{1124     \textcolor{keywordflow}{return} \textcolor{keyword}{nullptr};}
\DoxyCodeLine{1125   \}}
\DoxyCodeLine{1126 \};}
\DoxyCodeLine{1127 }
\DoxyCodeLine{1128 \textcolor{comment}{// Implements the Return() action.}}
\DoxyCodeLine{1129 \textcolor{keyword}{class }\mbox{\hyperlink{classtesting_1_1internal_1_1ReturnVoidAction}{ReturnVoidAction}} \{}
\DoxyCodeLine{1130  \textcolor{keyword}{public}:}
\DoxyCodeLine{1131   \textcolor{comment}{// Allows Return() to be used in any void-\/returning function.}}
\DoxyCodeLine{1132   \textcolor{keyword}{template} <\textcolor{keyword}{typename} Result, \textcolor{keyword}{typename} ArgumentTuple>}
\DoxyCodeLine{1133   \textcolor{keyword}{static} \textcolor{keywordtype}{void} Perform(\textcolor{keyword}{const} ArgumentTuple\&) \{}
\DoxyCodeLine{1134     \textcolor{keyword}{static\_assert}(std::is\_void<Result>::value, \textcolor{stringliteral}{"{}Result should be void."{}});}
\DoxyCodeLine{1135   \}}
\DoxyCodeLine{1136 \};}
\DoxyCodeLine{1137 }
\DoxyCodeLine{1138 \textcolor{comment}{// Implements the polymorphic ReturnRef(x) action, which can be used}}
\DoxyCodeLine{1139 \textcolor{comment}{// in any function that returns a reference to the type of x,}}
\DoxyCodeLine{1140 \textcolor{comment}{// regardless of the argument types.}}
\DoxyCodeLine{1141 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{1142 \textcolor{keyword}{class }\mbox{\hyperlink{classtesting_1_1internal_1_1ReturnRefAction}{ReturnRefAction}} \{}
\DoxyCodeLine{1143  \textcolor{keyword}{public}:}
\DoxyCodeLine{1144   \textcolor{comment}{// Constructs a ReturnRefAction object from the reference to be returned.}}
\DoxyCodeLine{1145   \textcolor{keyword}{explicit} \mbox{\hyperlink{classtesting_1_1internal_1_1ReturnRefAction}{ReturnRefAction}}(T\& ref) : ref\_(ref) \{\}  \textcolor{comment}{// NOLINT}}
\DoxyCodeLine{1146 }
\DoxyCodeLine{1147   \textcolor{comment}{// This template type conversion operator allows ReturnRef(x) to be}}
\DoxyCodeLine{1148   \textcolor{comment}{// used in ANY function that returns a reference to x's type.}}
\DoxyCodeLine{1149   \textcolor{keyword}{template} <\textcolor{keyword}{typename} F>}
\DoxyCodeLine{1150   \textcolor{keyword}{operator} \mbox{\hyperlink{classtesting_1_1Action}{Action<F>}}()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{1151     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \mbox{\hyperlink{structtesting_1_1internal_1_1Function}{Function<F>::Result}} Result;}
\DoxyCodeLine{1152     \textcolor{comment}{// Asserts that the function return type is a reference.  This}}
\DoxyCodeLine{1153     \textcolor{comment}{// catches the user error of using ReturnRef(x) when Return(x)}}
\DoxyCodeLine{1154     \textcolor{comment}{// should be used, and generates some helpful error message.}}
\DoxyCodeLine{1155     \textcolor{keyword}{static\_assert}(std::is\_reference<Result>::value,}
\DoxyCodeLine{1156                   \textcolor{stringliteral}{"{}use Return instead of ReturnRef to return a value"{}});}
\DoxyCodeLine{1157     \textcolor{keywordflow}{return} \mbox{\hyperlink{classtesting_1_1Action}{Action<F>}}(\textcolor{keyword}{new} Impl<F>(ref\_));}
\DoxyCodeLine{1158   \}}
\DoxyCodeLine{1159 }
\DoxyCodeLine{1160  \textcolor{keyword}{private}:}
\DoxyCodeLine{1161   \textcolor{comment}{// Implements the ReturnRef(x) action for a particular function type F.}}
\DoxyCodeLine{1162   \textcolor{keyword}{template} <\textcolor{keyword}{typename} F>}
\DoxyCodeLine{1163   \textcolor{keyword}{class }Impl : \textcolor{keyword}{public} \mbox{\hyperlink{classtesting_1_1ActionInterface}{ActionInterface}}<F> \{}
\DoxyCodeLine{1164    \textcolor{keyword}{public}:}
\DoxyCodeLine{1165     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \mbox{\hyperlink{structtesting_1_1internal_1_1Function}{Function<F>::Result}} Result;}
\DoxyCodeLine{1166     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \mbox{\hyperlink{structtesting_1_1internal_1_1Function}{Function<F>::ArgumentTuple}} ArgumentTuple;}
\DoxyCodeLine{1167 }
\DoxyCodeLine{1168     \textcolor{keyword}{explicit} Impl(T\& ref) : ref\_(ref) \{\}  \textcolor{comment}{// NOLINT}}
\DoxyCodeLine{1169 }
\DoxyCodeLine{1170     Result Perform(\textcolor{keyword}{const} ArgumentTuple\&)\textcolor{keyword}{ override }\{ \textcolor{keywordflow}{return} ref\_; \}}
\DoxyCodeLine{1171 }
\DoxyCodeLine{1172    \textcolor{keyword}{private}:}
\DoxyCodeLine{1173     T\& ref\_;}
\DoxyCodeLine{1174   \};}
\DoxyCodeLine{1175 }
\DoxyCodeLine{1176   T\& ref\_;}
\DoxyCodeLine{1177 \};}
\DoxyCodeLine{1178 }
\DoxyCodeLine{1179 \textcolor{comment}{// Implements the polymorphic ReturnRefOfCopy(x) action, which can be}}
\DoxyCodeLine{1180 \textcolor{comment}{// used in any function that returns a reference to the type of x,}}
\DoxyCodeLine{1181 \textcolor{comment}{// regardless of the argument types.}}
\DoxyCodeLine{1182 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{1183 \textcolor{keyword}{class }\mbox{\hyperlink{classtesting_1_1internal_1_1ReturnRefOfCopyAction}{ReturnRefOfCopyAction}} \{}
\DoxyCodeLine{1184  \textcolor{keyword}{public}:}
\DoxyCodeLine{1185   \textcolor{comment}{// Constructs a ReturnRefOfCopyAction object from the reference to}}
\DoxyCodeLine{1186   \textcolor{comment}{// be returned.}}
\DoxyCodeLine{1187   \textcolor{keyword}{explicit} \mbox{\hyperlink{classtesting_1_1internal_1_1ReturnRefOfCopyAction}{ReturnRefOfCopyAction}}(\textcolor{keyword}{const} T\& value) : value\_(value) \{\}  \textcolor{comment}{// NOLINT}}
\DoxyCodeLine{1188 }
\DoxyCodeLine{1189   \textcolor{comment}{// This template type conversion operator allows ReturnRefOfCopy(x) to be}}
\DoxyCodeLine{1190   \textcolor{comment}{// used in ANY function that returns a reference to x's type.}}
\DoxyCodeLine{1191   \textcolor{keyword}{template} <\textcolor{keyword}{typename} F>}
\DoxyCodeLine{1192   \textcolor{keyword}{operator} \mbox{\hyperlink{classtesting_1_1Action}{Action<F>}}()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{1193     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \mbox{\hyperlink{structtesting_1_1internal_1_1Function}{Function<F>::Result}} Result;}
\DoxyCodeLine{1194     \textcolor{comment}{// Asserts that the function return type is a reference.  This}}
\DoxyCodeLine{1195     \textcolor{comment}{// catches the user error of using ReturnRefOfCopy(x) when Return(x)}}
\DoxyCodeLine{1196     \textcolor{comment}{// should be used, and generates some helpful error message.}}
\DoxyCodeLine{1197     \textcolor{keyword}{static\_assert}(std::is\_reference<Result>::value,}
\DoxyCodeLine{1198                   \textcolor{stringliteral}{"{}use Return instead of ReturnRefOfCopy to return a value"{}});}
\DoxyCodeLine{1199     \textcolor{keywordflow}{return} \mbox{\hyperlink{classtesting_1_1Action}{Action<F>}}(\textcolor{keyword}{new} Impl<F>(value\_));}
\DoxyCodeLine{1200   \}}
\DoxyCodeLine{1201 }
\DoxyCodeLine{1202  \textcolor{keyword}{private}:}
\DoxyCodeLine{1203   \textcolor{comment}{// Implements the ReturnRefOfCopy(x) action for a particular function type F.}}
\DoxyCodeLine{1204   \textcolor{keyword}{template} <\textcolor{keyword}{typename} F>}
\DoxyCodeLine{1205   \textcolor{keyword}{class }Impl : \textcolor{keyword}{public} \mbox{\hyperlink{classtesting_1_1ActionInterface}{ActionInterface}}<F> \{}
\DoxyCodeLine{1206    \textcolor{keyword}{public}:}
\DoxyCodeLine{1207     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \mbox{\hyperlink{structtesting_1_1internal_1_1Function}{Function<F>::Result}} Result;}
\DoxyCodeLine{1208     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \mbox{\hyperlink{structtesting_1_1internal_1_1Function}{Function<F>::ArgumentTuple}} ArgumentTuple;}
\DoxyCodeLine{1209 }
\DoxyCodeLine{1210     \textcolor{keyword}{explicit} Impl(\textcolor{keyword}{const} T\& value) : value\_(value) \{\}  \textcolor{comment}{// NOLINT}}
\DoxyCodeLine{1211 }
\DoxyCodeLine{1212     Result Perform(\textcolor{keyword}{const} ArgumentTuple\&)\textcolor{keyword}{ override }\{ \textcolor{keywordflow}{return} value\_; \}}
\DoxyCodeLine{1213 }
\DoxyCodeLine{1214    \textcolor{keyword}{private}:}
\DoxyCodeLine{1215     T value\_;}
\DoxyCodeLine{1216   \};}
\DoxyCodeLine{1217 }
\DoxyCodeLine{1218   \textcolor{keyword}{const} T value\_;}
\DoxyCodeLine{1219 \};}
\DoxyCodeLine{1220 }
\DoxyCodeLine{1221 \textcolor{comment}{// Implements the polymorphic ReturnRoundRobin(v) action, which can be}}
\DoxyCodeLine{1222 \textcolor{comment}{// used in any function that returns the element\_type of v.}}
\DoxyCodeLine{1223 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{1224 \textcolor{keyword}{class }\mbox{\hyperlink{classtesting_1_1internal_1_1ReturnRoundRobinAction}{ReturnRoundRobinAction}} \{}
\DoxyCodeLine{1225  \textcolor{keyword}{public}:}
\DoxyCodeLine{1226   \textcolor{keyword}{explicit} \mbox{\hyperlink{classtesting_1_1internal_1_1ReturnRoundRobinAction}{ReturnRoundRobinAction}}(std::vector<T> values) \{}
\DoxyCodeLine{1227     GTEST\_CHECK\_(!values.empty())}
\DoxyCodeLine{1228         << \textcolor{stringliteral}{"{}ReturnRoundRobin requires at least one element."{}};}
\DoxyCodeLine{1229     state\_-\/>values = std::move(values);}
\DoxyCodeLine{1230   \}}
\DoxyCodeLine{1231 }
\DoxyCodeLine{1232   \textcolor{keyword}{template} <\textcolor{keyword}{typename}... Args>}
\DoxyCodeLine{1233   T operator()(Args\&\&...)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{1234     \textcolor{keywordflow}{return} state\_-\/>Next();}
\DoxyCodeLine{1235   \}}
\DoxyCodeLine{1236 }
\DoxyCodeLine{1237  \textcolor{keyword}{private}:}
\DoxyCodeLine{1238   \textcolor{keyword}{struct }State \{}
\DoxyCodeLine{1239     T Next() \{}
\DoxyCodeLine{1240       T ret\_val = values[i++];}
\DoxyCodeLine{1241       \textcolor{keywordflow}{if} (i == values.size()) i = 0;}
\DoxyCodeLine{1242       \textcolor{keywordflow}{return} ret\_val;}
\DoxyCodeLine{1243     \}}
\DoxyCodeLine{1244 }
\DoxyCodeLine{1245     std::vector<T> values;}
\DoxyCodeLine{1246     \textcolor{keywordtype}{size\_t} i = 0;}
\DoxyCodeLine{1247   \};}
\DoxyCodeLine{1248   std::shared\_ptr<State> state\_ = std::make\_shared<State>();}
\DoxyCodeLine{1249 \};}
\DoxyCodeLine{1250 }
\DoxyCodeLine{1251 \textcolor{comment}{// Implements the polymorphic DoDefault() action.}}
\DoxyCodeLine{1252 \textcolor{keyword}{class }\mbox{\hyperlink{classtesting_1_1internal_1_1DoDefaultAction}{DoDefaultAction}} \{}
\DoxyCodeLine{1253  \textcolor{keyword}{public}:}
\DoxyCodeLine{1254   \textcolor{comment}{// This template type conversion operator allows DoDefault() to be}}
\DoxyCodeLine{1255   \textcolor{comment}{// used in any function.}}
\DoxyCodeLine{1256   \textcolor{keyword}{template} <\textcolor{keyword}{typename} F>}
\DoxyCodeLine{1257   \textcolor{keyword}{operator} \mbox{\hyperlink{classtesting_1_1Action}{Action<F>}}()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{1258     \textcolor{keywordflow}{return} \mbox{\hyperlink{classtesting_1_1Action}{Action<F>}}();}
\DoxyCodeLine{1259   \}  \textcolor{comment}{// NOLINT}}
\DoxyCodeLine{1260 \};}
\DoxyCodeLine{1261 }
\DoxyCodeLine{1262 \textcolor{comment}{// Implements the Assign action to set a given pointer referent to a}}
\DoxyCodeLine{1263 \textcolor{comment}{// particular value.}}
\DoxyCodeLine{1264 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T1, \textcolor{keyword}{typename} T2>}
\DoxyCodeLine{1265 \textcolor{keyword}{class }\mbox{\hyperlink{classtesting_1_1internal_1_1AssignAction}{AssignAction}} \{}
\DoxyCodeLine{1266  \textcolor{keyword}{public}:}
\DoxyCodeLine{1267   \mbox{\hyperlink{classtesting_1_1internal_1_1AssignAction}{AssignAction}}(T1* ptr, T2 value) : ptr\_(ptr), value\_(value) \{\}}
\DoxyCodeLine{1268 }
\DoxyCodeLine{1269   \textcolor{keyword}{template} <\textcolor{keyword}{typename} Result, \textcolor{keyword}{typename} ArgumentTuple>}
\DoxyCodeLine{1270   \textcolor{keywordtype}{void} Perform(\textcolor{keyword}{const} ArgumentTuple\& \textcolor{comment}{/* args */})\textcolor{keyword}{ const }\{}
\DoxyCodeLine{1271     *ptr\_ = value\_;}
\DoxyCodeLine{1272   \}}
\DoxyCodeLine{1273 }
\DoxyCodeLine{1274  \textcolor{keyword}{private}:}
\DoxyCodeLine{1275   T1* \textcolor{keyword}{const} ptr\_;}
\DoxyCodeLine{1276   \textcolor{keyword}{const} T2 value\_;}
\DoxyCodeLine{1277 \};}
\DoxyCodeLine{1278 }
\DoxyCodeLine{1279 \textcolor{preprocessor}{\#if !GTEST\_OS\_WINDOWS\_MOBILE}}
\DoxyCodeLine{1280 }
\DoxyCodeLine{1281 \textcolor{comment}{// Implements the SetErrnoAndReturn action to simulate return from}}
\DoxyCodeLine{1282 \textcolor{comment}{// various system calls and libc functions.}}
\DoxyCodeLine{1283 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{1284 \textcolor{keyword}{class }\mbox{\hyperlink{classtesting_1_1internal_1_1SetErrnoAndReturnAction}{SetErrnoAndReturnAction}} \{}
\DoxyCodeLine{1285  \textcolor{keyword}{public}:}
\DoxyCodeLine{1286   \mbox{\hyperlink{classtesting_1_1internal_1_1SetErrnoAndReturnAction}{SetErrnoAndReturnAction}}(\textcolor{keywordtype}{int} errno\_value, T result)}
\DoxyCodeLine{1287       : errno\_(errno\_value), result\_(result) \{\}}
\DoxyCodeLine{1288   \textcolor{keyword}{template} <\textcolor{keyword}{typename} Result, \textcolor{keyword}{typename} ArgumentTuple>}
\DoxyCodeLine{1289   Result Perform(\textcolor{keyword}{const} ArgumentTuple\& \textcolor{comment}{/* args */})\textcolor{keyword}{ const }\{}
\DoxyCodeLine{1290     errno = errno\_;}
\DoxyCodeLine{1291     \textcolor{keywordflow}{return} result\_;}
\DoxyCodeLine{1292   \}}
\DoxyCodeLine{1293 }
\DoxyCodeLine{1294  \textcolor{keyword}{private}:}
\DoxyCodeLine{1295   \textcolor{keyword}{const} \textcolor{keywordtype}{int} errno\_;}
\DoxyCodeLine{1296   \textcolor{keyword}{const} T result\_;}
\DoxyCodeLine{1297 \};}
\DoxyCodeLine{1298 }
\DoxyCodeLine{1299 \textcolor{preprocessor}{\#endif  }\textcolor{comment}{// !GTEST\_OS\_WINDOWS\_MOBILE}}
\DoxyCodeLine{1300 }
\DoxyCodeLine{1301 \textcolor{comment}{// Implements the SetArgumentPointee<N>(x) action for any function}}
\DoxyCodeLine{1302 \textcolor{comment}{// whose N-\/th argument (0-\/based) is a pointer to x's type.}}
\DoxyCodeLine{1303 \textcolor{keyword}{template} <\textcolor{keywordtype}{size\_t} N, \textcolor{keyword}{typename} A, \textcolor{keyword}{typename} = \textcolor{keywordtype}{void}>}
\DoxyCodeLine{1304 \textcolor{keyword}{struct }\mbox{\hyperlink{structtesting_1_1internal_1_1SetArgumentPointeeAction}{SetArgumentPointeeAction}} \{}
\DoxyCodeLine{1305   A value;}
\DoxyCodeLine{1306 }
\DoxyCodeLine{1307   \textcolor{keyword}{template} <\textcolor{keyword}{typename}... Args>}
\DoxyCodeLine{1308   \textcolor{keywordtype}{void} operator()(\textcolor{keyword}{const} Args\&... args)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{1309     *::std::get<N>(std::tie(args...)) = value;}
\DoxyCodeLine{1310   \}}
\DoxyCodeLine{1311 \};}
\DoxyCodeLine{1312 }
\DoxyCodeLine{1313 \textcolor{comment}{// Implements the Invoke(object\_ptr, \&Class::Method) action.}}
\DoxyCodeLine{1314 \textcolor{keyword}{template} <\textcolor{keyword}{class} Class, \textcolor{keyword}{typename} MethodPtr>}
\DoxyCodeLine{1315 \textcolor{keyword}{struct }\mbox{\hyperlink{structtesting_1_1internal_1_1InvokeMethodAction}{InvokeMethodAction}} \{}
\DoxyCodeLine{1316   Class* \textcolor{keyword}{const} obj\_ptr;}
\DoxyCodeLine{1317   \textcolor{keyword}{const} MethodPtr method\_ptr;}
\DoxyCodeLine{1318 }
\DoxyCodeLine{1319   \textcolor{keyword}{template} <\textcolor{keyword}{typename}... Args>}
\DoxyCodeLine{1320   \textcolor{keyword}{auto} operator()(Args\&\&... args) \textcolor{keyword}{const}}
\DoxyCodeLine{1321       -\/> \textcolor{keyword}{decltype}((obj\_ptr-\/>*method\_ptr)(std::forward<Args>(args)...)) \{}
\DoxyCodeLine{1322     \textcolor{keywordflow}{return} (obj\_ptr-\/>*method\_ptr)(std::forward<Args>(args)...);}
\DoxyCodeLine{1323   \}}
\DoxyCodeLine{1324 \};}
\DoxyCodeLine{1325 }
\DoxyCodeLine{1326 \textcolor{comment}{// Implements the InvokeWithoutArgs(f) action.  The template argument}}
\DoxyCodeLine{1327 \textcolor{comment}{// FunctionImpl is the implementation type of f, which can be either a}}
\DoxyCodeLine{1328 \textcolor{comment}{// function pointer or a functor.  InvokeWithoutArgs(f) can be used as an}}
\DoxyCodeLine{1329 \textcolor{comment}{// Action<F> as long as f's type is compatible with F.}}
\DoxyCodeLine{1330 \textcolor{keyword}{template} <\textcolor{keyword}{typename} FunctionImpl>}
\DoxyCodeLine{1331 \textcolor{keyword}{struct }\mbox{\hyperlink{structtesting_1_1internal_1_1InvokeWithoutArgsAction}{InvokeWithoutArgsAction}} \{}
\DoxyCodeLine{1332   FunctionImpl function\_impl;}
\DoxyCodeLine{1333 }
\DoxyCodeLine{1334   \textcolor{comment}{// Allows InvokeWithoutArgs(f) to be used as any action whose type is}}
\DoxyCodeLine{1335   \textcolor{comment}{// compatible with f.}}
\DoxyCodeLine{1336   \textcolor{keyword}{template} <\textcolor{keyword}{typename}... Args>}
\DoxyCodeLine{1337   \textcolor{keyword}{auto} operator()(\textcolor{keyword}{const} Args\&...) -\/> \textcolor{keyword}{decltype}(function\_impl()) \{}
\DoxyCodeLine{1338     \textcolor{keywordflow}{return} function\_impl();}
\DoxyCodeLine{1339   \}}
\DoxyCodeLine{1340 \};}
\DoxyCodeLine{1341 }
\DoxyCodeLine{1342 \textcolor{comment}{// Implements the InvokeWithoutArgs(object\_ptr, \&Class::Method) action.}}
\DoxyCodeLine{1343 \textcolor{keyword}{template} <\textcolor{keyword}{class} Class, \textcolor{keyword}{typename} MethodPtr>}
\DoxyCodeLine{1344 \textcolor{keyword}{struct }\mbox{\hyperlink{structtesting_1_1internal_1_1InvokeMethodWithoutArgsAction}{InvokeMethodWithoutArgsAction}} \{}
\DoxyCodeLine{1345   Class* \textcolor{keyword}{const} obj\_ptr;}
\DoxyCodeLine{1346   \textcolor{keyword}{const} MethodPtr method\_ptr;}
\DoxyCodeLine{1347 }
\DoxyCodeLine{1348   \textcolor{keyword}{using }ReturnType =}
\DoxyCodeLine{1349       \textcolor{keyword}{decltype}((std::declval<Class*>()-\/>*std::declval<MethodPtr>())());}
\DoxyCodeLine{1350 }
\DoxyCodeLine{1351   \textcolor{keyword}{template} <\textcolor{keyword}{typename}... Args>}
\DoxyCodeLine{1352   ReturnType operator()(\textcolor{keyword}{const} Args\&...)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{1353     \textcolor{keywordflow}{return} (obj\_ptr-\/>*method\_ptr)();}
\DoxyCodeLine{1354   \}}
\DoxyCodeLine{1355 \};}
\DoxyCodeLine{1356 }
\DoxyCodeLine{1357 \textcolor{comment}{// Implements the IgnoreResult(action) action.}}
\DoxyCodeLine{1358 \textcolor{keyword}{template} <\textcolor{keyword}{typename} A>}
\DoxyCodeLine{1359 \textcolor{keyword}{class }\mbox{\hyperlink{classtesting_1_1internal_1_1IgnoreResultAction}{IgnoreResultAction}} \{}
\DoxyCodeLine{1360  \textcolor{keyword}{public}:}
\DoxyCodeLine{1361   \textcolor{keyword}{explicit} \mbox{\hyperlink{classtesting_1_1internal_1_1IgnoreResultAction}{IgnoreResultAction}}(\textcolor{keyword}{const} A\& action) : action\_(action) \{\}}
\DoxyCodeLine{1362 }
\DoxyCodeLine{1363   \textcolor{keyword}{template} <\textcolor{keyword}{typename} F>}
\DoxyCodeLine{1364   \textcolor{keyword}{operator} \mbox{\hyperlink{classtesting_1_1Action}{Action<F>}}()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{1365     \textcolor{comment}{// Assert statement belongs here because this is the best place to verify}}
\DoxyCodeLine{1366     \textcolor{comment}{// conditions on F. It produces the clearest error messages}}
\DoxyCodeLine{1367     \textcolor{comment}{// in most compilers.}}
\DoxyCodeLine{1368     \textcolor{comment}{// Impl really belongs in this scope as a local class but can't}}
\DoxyCodeLine{1369     \textcolor{comment}{// because MSVC produces duplicate symbols in different translation units}}
\DoxyCodeLine{1370     \textcolor{comment}{// in this case. Until MS fixes that bug we put Impl into the class scope}}
\DoxyCodeLine{1371     \textcolor{comment}{// and put the typedef both here (for use in assert statement) and}}
\DoxyCodeLine{1372     \textcolor{comment}{// in the Impl class. But both definitions must be the same.}}
\DoxyCodeLine{1373     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \mbox{\hyperlink{structtesting_1_1internal_1_1Function}{internal::Function<F>::Result}} Result;}
\DoxyCodeLine{1374 }
\DoxyCodeLine{1375     \textcolor{comment}{// Asserts at compile time that F returns void.}}
\DoxyCodeLine{1376     \textcolor{keyword}{static\_assert}(std::is\_void<Result>::value, \textcolor{stringliteral}{"{}Result type should be void."{}});}
\DoxyCodeLine{1377 }
\DoxyCodeLine{1378     \textcolor{keywordflow}{return} \mbox{\hyperlink{classtesting_1_1Action}{Action<F>}}(\textcolor{keyword}{new} Impl<F>(action\_));}
\DoxyCodeLine{1379   \}}
\DoxyCodeLine{1380 }
\DoxyCodeLine{1381  \textcolor{keyword}{private}:}
\DoxyCodeLine{1382   \textcolor{keyword}{template} <\textcolor{keyword}{typename} F>}
\DoxyCodeLine{1383   \textcolor{keyword}{class }Impl : \textcolor{keyword}{public} \mbox{\hyperlink{classtesting_1_1ActionInterface}{ActionInterface}}<F> \{}
\DoxyCodeLine{1384    \textcolor{keyword}{public}:}
\DoxyCodeLine{1385     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \mbox{\hyperlink{structtesting_1_1internal_1_1Function}{internal::Function<F>::Result}} Result;}
\DoxyCodeLine{1386     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \mbox{\hyperlink{structtesting_1_1internal_1_1Function}{internal::Function<F>::ArgumentTuple}} ArgumentTuple;}
\DoxyCodeLine{1387 }
\DoxyCodeLine{1388     \textcolor{keyword}{explicit} Impl(\textcolor{keyword}{const} A\& action) : action\_(action) \{\}}
\DoxyCodeLine{1389 }
\DoxyCodeLine{1390     \textcolor{keywordtype}{void} Perform(\textcolor{keyword}{const} ArgumentTuple\& args)\textcolor{keyword}{ override }\{}
\DoxyCodeLine{1391       \textcolor{comment}{// Performs the action and ignores its result.}}
\DoxyCodeLine{1392       action\_.Perform(args);}
\DoxyCodeLine{1393     \}}
\DoxyCodeLine{1394 }
\DoxyCodeLine{1395    \textcolor{keyword}{private}:}
\DoxyCodeLine{1396     \textcolor{comment}{// Type OriginalFunction is the same as F except that its return}}
\DoxyCodeLine{1397     \textcolor{comment}{// type is IgnoredValue.}}
\DoxyCodeLine{1398     \textcolor{keyword}{typedef}}
\DoxyCodeLine{1399         \textcolor{keyword}{typename} \mbox{\hyperlink{structtesting_1_1internal_1_1Function}{internal::Function<F>::MakeResultIgnoredValue}} OriginalFunction;}
\DoxyCodeLine{1400 }
\DoxyCodeLine{1401     \textcolor{keyword}{const} \mbox{\hyperlink{classtesting_1_1Action}{Action<OriginalFunction>}} action\_;}
\DoxyCodeLine{1402   \};}
\DoxyCodeLine{1403 }
\DoxyCodeLine{1404   \textcolor{keyword}{const} A action\_;}
\DoxyCodeLine{1405 \};}
\DoxyCodeLine{1406 }
\DoxyCodeLine{1407 \textcolor{keyword}{template} <\textcolor{keyword}{typename} InnerAction, \textcolor{keywordtype}{size\_t}... I>}
\DoxyCodeLine{1408 \textcolor{keyword}{struct }\mbox{\hyperlink{structtesting_1_1internal_1_1WithArgsAction}{WithArgsAction}} \{}
\DoxyCodeLine{1409   InnerAction inner\_action;}
\DoxyCodeLine{1410 }
\DoxyCodeLine{1411   \textcolor{comment}{// The signature of the function as seen by the inner action, given an out}}
\DoxyCodeLine{1412   \textcolor{comment}{// action with the given result and argument types.}}
\DoxyCodeLine{1413   \textcolor{keyword}{template} <\textcolor{keyword}{typename} R, \textcolor{keyword}{typename}... Args>}
\DoxyCodeLine{1414   \textcolor{keyword}{using }InnerSignature =}
\DoxyCodeLine{1415       R(\textcolor{keyword}{typename} std::tuple\_element<I, std::tuple<Args...>>::type...);}
\DoxyCodeLine{1416 }
\DoxyCodeLine{1417   \textcolor{comment}{// Rather than a call operator, we must define conversion operators to}}
\DoxyCodeLine{1418   \textcolor{comment}{// particular action types. This is necessary for embedded actions like}}
\DoxyCodeLine{1419   \textcolor{comment}{// DoDefault(), which rely on an action conversion operators rather than}}
\DoxyCodeLine{1420   \textcolor{comment}{// providing a call operator because even with a particular set of arguments}}
\DoxyCodeLine{1421   \textcolor{comment}{// they don't have a fixed return type.}}
\DoxyCodeLine{1422 }
\DoxyCodeLine{1423   \textcolor{keyword}{template} <\textcolor{keyword}{typename} R, \textcolor{keyword}{typename}... Args,}
\DoxyCodeLine{1424             \textcolor{keyword}{typename} std::enable\_if<}
\DoxyCodeLine{1425                 std::is\_convertible<}
\DoxyCodeLine{1426                     InnerAction,}
\DoxyCodeLine{1427                     \textcolor{comment}{// Unfortunately we can't use the InnerSignature alias here;}}
\DoxyCodeLine{1428                     \textcolor{comment}{// MSVC complains about the I parameter pack not being}}
\DoxyCodeLine{1429                     \textcolor{comment}{// expanded (error C3520) despite it being expanded in the}}
\DoxyCodeLine{1430                     \textcolor{comment}{// type alias.}}
\DoxyCodeLine{1431                     \mbox{\hyperlink{classtesting_1_1OnceAction}{OnceAction}}<R(\textcolor{keyword}{typename} std::tuple\_element<}
\DoxyCodeLine{1432                                  I, std::tuple<Args...>>::type...)>>::value,}
\DoxyCodeLine{1433                 \textcolor{keywordtype}{int}>::type = 0>}
\DoxyCodeLine{1434   \textcolor{keyword}{operator} \mbox{\hyperlink{classtesting_1_1OnceAction}{OnceAction}}<R(Args...)>() \&\& \{  \textcolor{comment}{// NOLINT}}
\DoxyCodeLine{1435     \textcolor{keyword}{struct }OA \{}
\DoxyCodeLine{1436       \mbox{\hyperlink{classtesting_1_1OnceAction}{OnceAction}}<InnerSignature<R, Args...>> inner\_action;}
\DoxyCodeLine{1437 }
\DoxyCodeLine{1438       R operator()(Args\&\&... args) \&\& \{}
\DoxyCodeLine{1439         \textcolor{keywordflow}{return} std::move(inner\_action)}
\DoxyCodeLine{1440             .Call(std::get<I>(}
\DoxyCodeLine{1441                 std::forward\_as\_tuple(std::forward<Args>(args)...))...);}
\DoxyCodeLine{1442       \}}
\DoxyCodeLine{1443     \};}
\DoxyCodeLine{1444 }
\DoxyCodeLine{1445     \textcolor{keywordflow}{return} OA\{std::move(inner\_action)\};}
\DoxyCodeLine{1446   \}}
\DoxyCodeLine{1447 }
\DoxyCodeLine{1448   \textcolor{keyword}{template} <\textcolor{keyword}{typename} R, \textcolor{keyword}{typename}... Args,}
\DoxyCodeLine{1449             \textcolor{keyword}{typename} std::enable\_if<}
\DoxyCodeLine{1450                 std::is\_convertible<}
\DoxyCodeLine{1451                     \textcolor{keyword}{const} InnerAction\&,}
\DoxyCodeLine{1452                     \textcolor{comment}{// Unfortunately we can't use the InnerSignature alias here;}}
\DoxyCodeLine{1453                     \textcolor{comment}{// MSVC complains about the I parameter pack not being}}
\DoxyCodeLine{1454                     \textcolor{comment}{// expanded (error C3520) despite it being expanded in the}}
\DoxyCodeLine{1455                     \textcolor{comment}{// type alias.}}
\DoxyCodeLine{1456                     \mbox{\hyperlink{classtesting_1_1Action}{Action}}<R(\textcolor{keyword}{typename} std::tuple\_element<}
\DoxyCodeLine{1457                              I, std::tuple<Args...>>::type...)>>::value,}
\DoxyCodeLine{1458                 \textcolor{keywordtype}{int}>::type = 0>}
\DoxyCodeLine{1459   \textcolor{keyword}{operator} \mbox{\hyperlink{classtesting_1_1Action}{Action}}<R(Args...)>() \textcolor{keyword}{const} \{  \textcolor{comment}{// NOLINT}}
\DoxyCodeLine{1460     \mbox{\hyperlink{classtesting_1_1Action}{Action}}<InnerSignature<R, Args...>> converted(inner\_action);}
\DoxyCodeLine{1461 }
\DoxyCodeLine{1462     \textcolor{keywordflow}{return} [converted](Args\&\&... args) -\/> R \{}
\DoxyCodeLine{1463       \textcolor{keywordflow}{return} converted.Perform(std::forward\_as\_tuple(}
\DoxyCodeLine{1464           std::get<I>(std::forward\_as\_tuple(std::forward<Args>(args)...))...));}
\DoxyCodeLine{1465     \};}
\DoxyCodeLine{1466   \}}
\DoxyCodeLine{1467 \};}
\DoxyCodeLine{1468 }
\DoxyCodeLine{1469 \textcolor{keyword}{template} <\textcolor{keyword}{typename}... Actions>}
\DoxyCodeLine{1470 \textcolor{keyword}{class }\mbox{\hyperlink{classtesting_1_1internal_1_1DoAllAction}{DoAllAction}};}
\DoxyCodeLine{1471 }
\DoxyCodeLine{1472 \textcolor{comment}{// Base case: only a single action.}}
\DoxyCodeLine{1473 \textcolor{keyword}{template} <\textcolor{keyword}{typename} FinalAction>}
\DoxyCodeLine{1474 \textcolor{keyword}{class }\mbox{\hyperlink{classtesting_1_1internal_1_1DoAllAction}{DoAllAction}}<FinalAction> \{}
\DoxyCodeLine{1475  \textcolor{keyword}{public}:}
\DoxyCodeLine{1476   \textcolor{keyword}{struct }UserConstructorTag \{\};}
\DoxyCodeLine{1477 }
\DoxyCodeLine{1478   \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{1479   \textcolor{keyword}{explicit} \mbox{\hyperlink{classtesting_1_1internal_1_1DoAllAction}{DoAllAction}}(UserConstructorTag, T\&\& action)}
\DoxyCodeLine{1480       : final\_action\_(std::forward<T>(action)) \{\}}
\DoxyCodeLine{1481 }
\DoxyCodeLine{1482   \textcolor{comment}{// Rather than a call operator, we must define conversion operators to}}
\DoxyCodeLine{1483   \textcolor{comment}{// particular action types. This is necessary for embedded actions like}}
\DoxyCodeLine{1484   \textcolor{comment}{// DoDefault(), which rely on an action conversion operators rather than}}
\DoxyCodeLine{1485   \textcolor{comment}{// providing a call operator because even with a particular set of arguments}}
\DoxyCodeLine{1486   \textcolor{comment}{// they don't have a fixed return type.}}
\DoxyCodeLine{1487 }
\DoxyCodeLine{1488   \textcolor{keyword}{template} <\textcolor{keyword}{typename} R, \textcolor{keyword}{typename}... Args,}
\DoxyCodeLine{1489             \textcolor{keyword}{typename} std::enable\_if<}
\DoxyCodeLine{1490                 std::is\_convertible<FinalAction, \mbox{\hyperlink{classtesting_1_1OnceAction}{OnceAction}}<R(Args...)>>::value,}
\DoxyCodeLine{1491                 \textcolor{keywordtype}{int}>::type = 0>}
\DoxyCodeLine{1492   \textcolor{keyword}{operator} \mbox{\hyperlink{classtesting_1_1OnceAction}{OnceAction}}<R(Args...)>() \&\& \{  \textcolor{comment}{// NOLINT}}
\DoxyCodeLine{1493     \textcolor{keywordflow}{return} std::move(final\_action\_);}
\DoxyCodeLine{1494   \}}
\DoxyCodeLine{1495 }
\DoxyCodeLine{1496   \textcolor{keyword}{template} <}
\DoxyCodeLine{1497       \textcolor{keyword}{typename} R, \textcolor{keyword}{typename}... Args,}
\DoxyCodeLine{1498       \textcolor{keyword}{typename} std::enable\_if<}
\DoxyCodeLine{1499           std::is\_convertible<\textcolor{keyword}{const} FinalAction\&, \mbox{\hyperlink{classtesting_1_1Action}{Action}}<R(Args...)>>::value,}
\DoxyCodeLine{1500           \textcolor{keywordtype}{int}>::type = 0>}
\DoxyCodeLine{1501   \textcolor{keyword}{operator} \mbox{\hyperlink{classtesting_1_1Action}{Action}}<R(Args...)>() \textcolor{keyword}{const} \{  \textcolor{comment}{// NOLINT}}
\DoxyCodeLine{1502     \textcolor{keywordflow}{return} final\_action\_;}
\DoxyCodeLine{1503   \}}
\DoxyCodeLine{1504 }
\DoxyCodeLine{1505  \textcolor{keyword}{private}:}
\DoxyCodeLine{1506   FinalAction final\_action\_;}
\DoxyCodeLine{1507 \};}
\DoxyCodeLine{1508 }
\DoxyCodeLine{1509 \textcolor{comment}{// Recursive case: support N actions by calling the initial action and then}}
\DoxyCodeLine{1510 \textcolor{comment}{// calling through to the base class containing N-\/1 actions.}}
\DoxyCodeLine{1511 \textcolor{keyword}{template} <\textcolor{keyword}{typename} InitialAction, \textcolor{keyword}{typename}... OtherActions>}
\DoxyCodeLine{1512 \textcolor{keyword}{class }\mbox{\hyperlink{classtesting_1_1internal_1_1DoAllAction}{DoAllAction}}<InitialAction, OtherActions...>}
\DoxyCodeLine{1513     : \textcolor{keyword}{private} \mbox{\hyperlink{classtesting_1_1internal_1_1DoAllAction}{DoAllAction}}<OtherActions...> \{}
\DoxyCodeLine{1514  \textcolor{keyword}{private}:}
\DoxyCodeLine{1515   \textcolor{keyword}{using }\mbox{\hyperlink{classtesting_1_1internal_1_1DoAllAction}{Base}} = \mbox{\hyperlink{classtesting_1_1internal_1_1DoAllAction}{DoAllAction}}<OtherActions...>;}
\DoxyCodeLine{1516 }
\DoxyCodeLine{1517   \textcolor{comment}{// The type of reference that should be provided to an initial action for a}}
\DoxyCodeLine{1518   \textcolor{comment}{// mocked function parameter of type T.}}
\DoxyCodeLine{1519   \textcolor{comment}{//}}
\DoxyCodeLine{1520   \textcolor{comment}{// There are two quirks here:}}
\DoxyCodeLine{1521   \textcolor{comment}{//}}
\DoxyCodeLine{1522   \textcolor{comment}{//  *  Unlike most forwarding functions, we pass scalars through by value.}}
\DoxyCodeLine{1523   \textcolor{comment}{//     This isn't strictly necessary because an lvalue reference would work}}
\DoxyCodeLine{1524   \textcolor{comment}{//     fine too and be consistent with other non-\/reference types, but it's}}
\DoxyCodeLine{1525   \textcolor{comment}{//     perhaps less surprising.}}
\DoxyCodeLine{1526   \textcolor{comment}{//}}
\DoxyCodeLine{1527   \textcolor{comment}{//     For example if the mocked function has signature void(int), then it}}
\DoxyCodeLine{1528   \textcolor{comment}{//     might seem surprising for the user's initial action to need to be}}
\DoxyCodeLine{1529   \textcolor{comment}{//     convertible to Action<void(const int\&)>. This is perhaps less}}
\DoxyCodeLine{1530   \textcolor{comment}{//     surprising for a non-\/scalar type where there may be a performance}}
\DoxyCodeLine{1531   \textcolor{comment}{//     impact, or it might even be impossible, to pass by value.}}
\DoxyCodeLine{1532   \textcolor{comment}{//}}
\DoxyCodeLine{1533   \textcolor{comment}{//  *  More surprisingly, `const T\&` is often not a const reference type.}}
\DoxyCodeLine{1534   \textcolor{comment}{//     By the reference collapsing rules in C++17 [dcl.ref]/6, if T refers to}}
\DoxyCodeLine{1535   \textcolor{comment}{//     U\& or U\&\& for some non-\/scalar type U, then InitialActionArgType<T> is}}
\DoxyCodeLine{1536   \textcolor{comment}{//     U\&. In other words, we may hand over a non-\/const reference.}}
\DoxyCodeLine{1537   \textcolor{comment}{//}}
\DoxyCodeLine{1538   \textcolor{comment}{//     So for example, given some non-\/scalar type Obj we have the following}}
\DoxyCodeLine{1539   \textcolor{comment}{//     mappings:}}
\DoxyCodeLine{1540   \textcolor{comment}{//}}
\DoxyCodeLine{1541   \textcolor{comment}{//            T               InitialActionArgType<T>}}
\DoxyCodeLine{1542   \textcolor{comment}{//         -\/-\/-\/-\/-\/-\/-\/            -\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/}}
\DoxyCodeLine{1543   \textcolor{comment}{//         Obj                const Obj\&}}
\DoxyCodeLine{1544   \textcolor{comment}{//         Obj\&               Obj\&}}
\DoxyCodeLine{1545   \textcolor{comment}{//         Obj\&\&              Obj\&}}
\DoxyCodeLine{1546   \textcolor{comment}{//         const Obj          const Obj\&}}
\DoxyCodeLine{1547   \textcolor{comment}{//         const Obj\&         const Obj\&}}
\DoxyCodeLine{1548   \textcolor{comment}{//         const Obj\&\&        const Obj\&}}
\DoxyCodeLine{1549   \textcolor{comment}{//}}
\DoxyCodeLine{1550   \textcolor{comment}{//     In other words, the initial actions get a mutable view of an non-\/scalar}}
\DoxyCodeLine{1551   \textcolor{comment}{//     argument if and only if the mock function itself accepts a non-\/const}}
\DoxyCodeLine{1552   \textcolor{comment}{//     reference type. They are never given an rvalue reference to an}}
\DoxyCodeLine{1553   \textcolor{comment}{//     non-\/scalar type.}}
\DoxyCodeLine{1554   \textcolor{comment}{//}}
\DoxyCodeLine{1555   \textcolor{comment}{//     This situation makes sense if you imagine use with a matcher that is}}
\DoxyCodeLine{1556   \textcolor{comment}{//     designed to write through a reference. For example, if the caller wants}}
\DoxyCodeLine{1557   \textcolor{comment}{//     to fill in a reference argument and then return a canned value:}}
\DoxyCodeLine{1558   \textcolor{comment}{//}}
\DoxyCodeLine{1559   \textcolor{comment}{//         EXPECT\_CALL(mock, Call)}}
\DoxyCodeLine{1560   \textcolor{comment}{//             .WillOnce(DoAll(SetArgReferee<0>(17), Return(19)));}}
\DoxyCodeLine{1561   \textcolor{comment}{//}}
\DoxyCodeLine{1562   \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{1563   \textcolor{keyword}{using }InitialActionArgType =}
\DoxyCodeLine{1564       \textcolor{keyword}{typename} std::conditional<std::is\_scalar<T>::value, T, \textcolor{keyword}{const} T\&>::type;}
\DoxyCodeLine{1565 }
\DoxyCodeLine{1566  \textcolor{keyword}{public}:}
\DoxyCodeLine{1567   \textcolor{keyword}{struct }UserConstructorTag \{\};}
\DoxyCodeLine{1568 }
\DoxyCodeLine{1569   \textcolor{keyword}{template} <\textcolor{keyword}{typename} T, \textcolor{keyword}{typename}... U>}
\DoxyCodeLine{1570   \textcolor{keyword}{explicit} \mbox{\hyperlink{classtesting_1_1internal_1_1DoAllAction}{DoAllAction}}(UserConstructorTag, T\&\& initial\_action,}
\DoxyCodeLine{1571                        U\&\&... other\_actions)}
\DoxyCodeLine{1572       : \mbox{\hyperlink{classtesting_1_1internal_1_1DoAllAction}{Base}}(\{\}, std::forward<U>(other\_actions)...),}
\DoxyCodeLine{1573         initial\_action\_(std::forward<T>(initial\_action)) \{\}}
\DoxyCodeLine{1574 }
\DoxyCodeLine{1575   \textcolor{keyword}{template} <\textcolor{keyword}{typename} R, \textcolor{keyword}{typename}... Args,}
\DoxyCodeLine{1576             \textcolor{keyword}{typename} std::enable\_if<}
\DoxyCodeLine{1577                 conjunction<}
\DoxyCodeLine{1578                     \textcolor{comment}{// Both the initial action and the rest must support}}
\DoxyCodeLine{1579                     \textcolor{comment}{// conversion to OnceAction.}}
\DoxyCodeLine{1580                     std::is\_convertible<}
\DoxyCodeLine{1581                         InitialAction,}
\DoxyCodeLine{1582                         \mbox{\hyperlink{classtesting_1_1OnceAction}{OnceAction}}<void(InitialActionArgType<Args>...)>>,}
\DoxyCodeLine{1583                     std::is\_convertible<Base, \mbox{\hyperlink{classtesting_1_1OnceAction}{OnceAction}}<R(Args...)>>>::value,}
\DoxyCodeLine{1584                 \textcolor{keywordtype}{int}>::type = 0>}
\DoxyCodeLine{1585   \textcolor{keyword}{operator} \mbox{\hyperlink{classtesting_1_1OnceAction}{OnceAction}}<R(Args...)>() \&\& \{  \textcolor{comment}{// NOLINT}}
\DoxyCodeLine{1586     \textcolor{comment}{// Return an action that first calls the initial action with arguments}}
\DoxyCodeLine{1587     \textcolor{comment}{// filtered through InitialActionArgType, then forwards arguments directly}}
\DoxyCodeLine{1588     \textcolor{comment}{// to the base class to deal with the remaining actions.}}
\DoxyCodeLine{1589     \textcolor{keyword}{struct }OA \{}
\DoxyCodeLine{1590       \mbox{\hyperlink{classtesting_1_1OnceAction}{OnceAction}}<void(InitialActionArgType<Args>...)> initial\_action;}
\DoxyCodeLine{1591       \mbox{\hyperlink{classtesting_1_1OnceAction}{OnceAction}}<R(Args...)> remaining\_actions;}
\DoxyCodeLine{1592 }
\DoxyCodeLine{1593       R operator()(Args... args) \&\& \{}
\DoxyCodeLine{1594         std::move(initial\_action)}
\DoxyCodeLine{1595             .Call(\textcolor{keyword}{static\_cast<}InitialActionArgType<Args>\textcolor{keyword}{>}(args)...);}
\DoxyCodeLine{1596 }
\DoxyCodeLine{1597         \textcolor{keywordflow}{return} std::move(remaining\_actions).Call(std::forward<Args>(args)...);}
\DoxyCodeLine{1598       \}}
\DoxyCodeLine{1599     \};}
\DoxyCodeLine{1600 }
\DoxyCodeLine{1601     \textcolor{keywordflow}{return} OA\{}
\DoxyCodeLine{1602         std::move(initial\_action\_),}
\DoxyCodeLine{1603         std::move(\textcolor{keyword}{static\_cast<}\mbox{\hyperlink{classBase}{Base}}\&\textcolor{keyword}{>}(*\textcolor{keyword}{this})),}
\DoxyCodeLine{1604     \};}
\DoxyCodeLine{1605   \}}
\DoxyCodeLine{1606 }
\DoxyCodeLine{1607   \textcolor{keyword}{template} <}
\DoxyCodeLine{1608       \textcolor{keyword}{typename} R, \textcolor{keyword}{typename}... Args,}
\DoxyCodeLine{1609       \textcolor{keyword}{typename} std::enable\_if<}
\DoxyCodeLine{1610           conjunction<}
\DoxyCodeLine{1611               \textcolor{comment}{// Both the initial action and the rest must support conversion to}}
\DoxyCodeLine{1612               \textcolor{comment}{// Action.}}
\DoxyCodeLine{1613               std::is\_convertible<\textcolor{keyword}{const} InitialAction\&,}
\DoxyCodeLine{1614                                   Action<void(InitialActionArgType<Args>...)>>,}
\DoxyCodeLine{1615               std::is\_convertible<\textcolor{keyword}{const} \mbox{\hyperlink{classBase}{Base}}\&, Action<R(Args...)>>>::value,}
\DoxyCodeLine{1616           \textcolor{keywordtype}{int}>::type = 0>}
\DoxyCodeLine{1617   \textcolor{keyword}{operator} Action<R(Args...)>() \textcolor{keyword}{const} \{  \textcolor{comment}{// NOLINT}}
\DoxyCodeLine{1618     \textcolor{comment}{// Return an action that first calls the initial action with arguments}}
\DoxyCodeLine{1619     \textcolor{comment}{// filtered through InitialActionArgType, then forwards arguments directly}}
\DoxyCodeLine{1620     \textcolor{comment}{// to the base class to deal with the remaining actions.}}
\DoxyCodeLine{1621     \textcolor{keyword}{struct }OA \{}
\DoxyCodeLine{1622       Action<void(InitialActionArgType<Args>...)> initial\_action;}
\DoxyCodeLine{1623       Action<R(Args...)> remaining\_actions;}
\DoxyCodeLine{1624 }
\DoxyCodeLine{1625       R operator()(Args... args)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{1626         initial\_action.Perform(std::forward\_as\_tuple(}
\DoxyCodeLine{1627             \textcolor{keyword}{static\_cast<}InitialActionArgType<Args>\textcolor{keyword}{>}(args)...));}
\DoxyCodeLine{1628 }
\DoxyCodeLine{1629         \textcolor{keywordflow}{return} remaining\_actions.Perform(}
\DoxyCodeLine{1630             std::forward\_as\_tuple(std::forward<Args>(args)...));}
\DoxyCodeLine{1631       \}}
\DoxyCodeLine{1632     \};}
\DoxyCodeLine{1633 }
\DoxyCodeLine{1634     \textcolor{keywordflow}{return} OA\{}
\DoxyCodeLine{1635         initial\_action\_,}
\DoxyCodeLine{1636         \textcolor{keyword}{static\_cast<}\textcolor{keyword}{const }\mbox{\hyperlink{classBase}{Base}}\&\textcolor{keyword}{>}(*this),}
\DoxyCodeLine{1637     \};}
\DoxyCodeLine{1638   \}}
\DoxyCodeLine{1639 }
\DoxyCodeLine{1640  \textcolor{keyword}{private}:}
\DoxyCodeLine{1641   InitialAction initial\_action\_;}
\DoxyCodeLine{1642 \};}
\DoxyCodeLine{1643 }
\DoxyCodeLine{1644 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T, \textcolor{keyword}{typename}... Params>}
\DoxyCodeLine{1645 \textcolor{keyword}{struct }\mbox{\hyperlink{structtesting_1_1internal_1_1ReturnNewAction}{ReturnNewAction}} \{}
\DoxyCodeLine{1646   T* operator()()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{1647     \textcolor{keywordflow}{return} internal::Apply(}
\DoxyCodeLine{1648         [](\textcolor{keyword}{const} Params\&... unpacked\_params) \{}
\DoxyCodeLine{1649           \textcolor{keywordflow}{return} \textcolor{keyword}{new} T(unpacked\_params...);}
\DoxyCodeLine{1650         \},}
\DoxyCodeLine{1651         params);}
\DoxyCodeLine{1652   \}}
\DoxyCodeLine{1653   std::tuple<Params...> params;}
\DoxyCodeLine{1654 \};}
\DoxyCodeLine{1655 }
\DoxyCodeLine{1656 \textcolor{keyword}{template} <\textcolor{keywordtype}{size\_t} k>}
\DoxyCodeLine{1657 \textcolor{keyword}{struct }\mbox{\hyperlink{structtesting_1_1internal_1_1ReturnArgAction}{ReturnArgAction}} \{}
\DoxyCodeLine{1658   \textcolor{keyword}{template} <\textcolor{keyword}{typename}... Args,}
\DoxyCodeLine{1659             \textcolor{keyword}{typename} = \textcolor{keyword}{typename} std::enable\_if<(k < \textcolor{keyword}{sizeof}...(Args))>::type>}
\DoxyCodeLine{1660   \textcolor{keyword}{auto} operator()(Args\&\&... args) \textcolor{keyword}{const} -\/> \textcolor{keyword}{decltype}(std::get<k>(}
\DoxyCodeLine{1661       std::forward\_as\_tuple(std::forward<Args>(args)...))) \{}
\DoxyCodeLine{1662     \textcolor{keywordflow}{return} std::get<k>(std::forward\_as\_tuple(std::forward<Args>(args)...));}
\DoxyCodeLine{1663   \}}
\DoxyCodeLine{1664 \};}
\DoxyCodeLine{1665 }
\DoxyCodeLine{1666 \textcolor{keyword}{template} <\textcolor{keywordtype}{size\_t} k, \textcolor{keyword}{typename} Ptr>}
\DoxyCodeLine{1667 \textcolor{keyword}{struct }\mbox{\hyperlink{structtesting_1_1internal_1_1SaveArgAction}{SaveArgAction}} \{}
\DoxyCodeLine{1668   Ptr pointer;}
\DoxyCodeLine{1669 }
\DoxyCodeLine{1670   \textcolor{keyword}{template} <\textcolor{keyword}{typename}... Args>}
\DoxyCodeLine{1671   \textcolor{keywordtype}{void} operator()(\textcolor{keyword}{const} Args\&... args)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{1672     *pointer = std::get<k>(std::tie(args...));}
\DoxyCodeLine{1673   \}}
\DoxyCodeLine{1674 \};}
\DoxyCodeLine{1675 }
\DoxyCodeLine{1676 \textcolor{keyword}{template} <\textcolor{keywordtype}{size\_t} k, \textcolor{keyword}{typename} Ptr>}
\DoxyCodeLine{1677 \textcolor{keyword}{struct }\mbox{\hyperlink{structtesting_1_1internal_1_1SaveArgPointeeAction}{SaveArgPointeeAction}} \{}
\DoxyCodeLine{1678   Ptr pointer;}
\DoxyCodeLine{1679 }
\DoxyCodeLine{1680   \textcolor{keyword}{template} <\textcolor{keyword}{typename}... Args>}
\DoxyCodeLine{1681   \textcolor{keywordtype}{void} operator()(\textcolor{keyword}{const} Args\&... args)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{1682     *pointer = *std::get<k>(std::tie(args...));}
\DoxyCodeLine{1683   \}}
\DoxyCodeLine{1684 \};}
\DoxyCodeLine{1685 }
\DoxyCodeLine{1686 \textcolor{keyword}{template} <\textcolor{keywordtype}{size\_t} k, \textcolor{keyword}{typename} T>}
\DoxyCodeLine{1687 \textcolor{keyword}{struct }\mbox{\hyperlink{structtesting_1_1internal_1_1SetArgRefereeAction}{SetArgRefereeAction}} \{}
\DoxyCodeLine{1688   T value;}
\DoxyCodeLine{1689 }
\DoxyCodeLine{1690   \textcolor{keyword}{template} <\textcolor{keyword}{typename}... Args>}
\DoxyCodeLine{1691   \textcolor{keywordtype}{void} operator()(Args\&\&... args)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{1692     \textcolor{keyword}{using }argk\_type =}
\DoxyCodeLine{1693         typename ::std::tuple\_element<k, std::tuple<Args...>>::type;}
\DoxyCodeLine{1694     \textcolor{keyword}{static\_assert}(std::is\_lvalue\_reference<argk\_type>::value,}
\DoxyCodeLine{1695                   \textcolor{stringliteral}{"{}Argument must be a reference type."{}});}
\DoxyCodeLine{1696     std::get<k>(std::tie(args...)) = value;}
\DoxyCodeLine{1697   \}}
\DoxyCodeLine{1698 \};}
\DoxyCodeLine{1699 }
\DoxyCodeLine{1700 \textcolor{keyword}{template} <\textcolor{keywordtype}{size\_t} k, \textcolor{keyword}{typename} I1, \textcolor{keyword}{typename} I2>}
\DoxyCodeLine{1701 \textcolor{keyword}{struct }\mbox{\hyperlink{structtesting_1_1internal_1_1SetArrayArgumentAction}{SetArrayArgumentAction}} \{}
\DoxyCodeLine{1702   I1 first;}
\DoxyCodeLine{1703   I2 last;}
\DoxyCodeLine{1704 }
\DoxyCodeLine{1705   \textcolor{keyword}{template} <\textcolor{keyword}{typename}... Args>}
\DoxyCodeLine{1706   \textcolor{keywordtype}{void} operator()(\textcolor{keyword}{const} Args\&... args)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{1707     \textcolor{keyword}{auto} value = std::get<k>(std::tie(args...));}
\DoxyCodeLine{1708     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} it = first; it != last; ++it, (void)++value) \{}
\DoxyCodeLine{1709       *value = *it;}
\DoxyCodeLine{1710     \}}
\DoxyCodeLine{1711   \}}
\DoxyCodeLine{1712 \};}
\DoxyCodeLine{1713 }
\DoxyCodeLine{1714 \textcolor{keyword}{template} <\textcolor{keywordtype}{size\_t} k>}
\DoxyCodeLine{1715 \textcolor{keyword}{struct }\mbox{\hyperlink{structtesting_1_1internal_1_1DeleteArgAction}{DeleteArgAction}} \{}
\DoxyCodeLine{1716   \textcolor{keyword}{template} <\textcolor{keyword}{typename}... Args>}
\DoxyCodeLine{1717   \textcolor{keywordtype}{void} operator()(\textcolor{keyword}{const} Args\&... args)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{1718     \textcolor{keyword}{delete} std::get<k>(std::tie(args...));}
\DoxyCodeLine{1719   \}}
\DoxyCodeLine{1720 \};}
\DoxyCodeLine{1721 }
\DoxyCodeLine{1722 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Ptr>}
\DoxyCodeLine{1723 \textcolor{keyword}{struct }\mbox{\hyperlink{structtesting_1_1internal_1_1ReturnPointeeAction}{ReturnPointeeAction}} \{}
\DoxyCodeLine{1724   Ptr pointer;}
\DoxyCodeLine{1725   \textcolor{keyword}{template} <\textcolor{keyword}{typename}... Args>}
\DoxyCodeLine{1726   \textcolor{keyword}{auto} operator()(\textcolor{keyword}{const} Args\&...) \textcolor{keyword}{const} -\/> \textcolor{keyword}{decltype}(*pointer) \{}
\DoxyCodeLine{1727     \textcolor{keywordflow}{return} *pointer;}
\DoxyCodeLine{1728   \}}
\DoxyCodeLine{1729 \};}
\DoxyCodeLine{1730 }
\DoxyCodeLine{1731 \textcolor{preprocessor}{\#if GTEST\_HAS\_EXCEPTIONS}}
\DoxyCodeLine{1732 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{1733 \textcolor{keyword}{struct }ThrowAction \{}
\DoxyCodeLine{1734   T exception;}
\DoxyCodeLine{1735   \textcolor{comment}{// We use a conversion operator to adapt to any return type.}}
\DoxyCodeLine{1736   \textcolor{keyword}{template} <\textcolor{keyword}{typename} R, \textcolor{keyword}{typename}... Args>}
\DoxyCodeLine{1737   \textcolor{keyword}{operator} \mbox{\hyperlink{classtesting_1_1Action}{Action}}<R(Args...)>() \textcolor{keyword}{const} \{  \textcolor{comment}{// NOLINT}}
\DoxyCodeLine{1738     T copy = exception;}
\DoxyCodeLine{1739     \textcolor{keywordflow}{return} [copy](Args...) -\/> R \{ \textcolor{keywordflow}{throw} copy; \};}
\DoxyCodeLine{1740   \}}
\DoxyCodeLine{1741 \};}
\DoxyCodeLine{1742 \textcolor{preprocessor}{\#endif  }\textcolor{comment}{// GTEST\_HAS\_EXCEPTIONS}}
\DoxyCodeLine{1743 }
\DoxyCodeLine{1744 \}  \textcolor{comment}{// namespace internal}}
\DoxyCodeLine{1745 }
\DoxyCodeLine{1746 \textcolor{comment}{// An Unused object can be implicitly constructed from ANY value.}}
\DoxyCodeLine{1747 \textcolor{comment}{// This is handy when defining actions that ignore some or all of the}}
\DoxyCodeLine{1748 \textcolor{comment}{// mock function arguments.  For example, given}}
\DoxyCodeLine{1749 \textcolor{comment}{//}}
\DoxyCodeLine{1750 \textcolor{comment}{//   MOCK\_METHOD3(Foo, double(const string\& label, double x, double y));}}
\DoxyCodeLine{1751 \textcolor{comment}{//   MOCK\_METHOD3(Bar, double(int index, double x, double y));}}
\DoxyCodeLine{1752 \textcolor{comment}{//}}
\DoxyCodeLine{1753 \textcolor{comment}{// instead of}}
\DoxyCodeLine{1754 \textcolor{comment}{//}}
\DoxyCodeLine{1755 \textcolor{comment}{//   double DistanceToOriginWithLabel(const string\& label, double x, double y) \{}}
\DoxyCodeLine{1756 \textcolor{comment}{//     return sqrt(x*x + y*y);}}
\DoxyCodeLine{1757 \textcolor{comment}{//   \}}}
\DoxyCodeLine{1758 \textcolor{comment}{//   double DistanceToOriginWithIndex(int index, double x, double y) \{}}
\DoxyCodeLine{1759 \textcolor{comment}{//     return sqrt(x*x + y*y);}}
\DoxyCodeLine{1760 \textcolor{comment}{//   \}}}
\DoxyCodeLine{1761 \textcolor{comment}{//   ...}}
\DoxyCodeLine{1762 \textcolor{comment}{//   EXPECT\_CALL(mock, Foo("{}abc"{}, \_, \_))}}
\DoxyCodeLine{1763 \textcolor{comment}{//       .WillOnce(Invoke(DistanceToOriginWithLabel));}}
\DoxyCodeLine{1764 \textcolor{comment}{//   EXPECT\_CALL(mock, Bar(5, \_, \_))}}
\DoxyCodeLine{1765 \textcolor{comment}{//       .WillOnce(Invoke(DistanceToOriginWithIndex));}}
\DoxyCodeLine{1766 \textcolor{comment}{//}}
\DoxyCodeLine{1767 \textcolor{comment}{// you could write}}
\DoxyCodeLine{1768 \textcolor{comment}{//}}
\DoxyCodeLine{1769 \textcolor{comment}{//   // We can declare any uninteresting argument as Unused.}}
\DoxyCodeLine{1770 \textcolor{comment}{//   double DistanceToOrigin(Unused, double x, double y) \{}}
\DoxyCodeLine{1771 \textcolor{comment}{//     return sqrt(x*x + y*y);}}
\DoxyCodeLine{1772 \textcolor{comment}{//   \}}}
\DoxyCodeLine{1773 \textcolor{comment}{//   ...}}
\DoxyCodeLine{1774 \textcolor{comment}{//   EXPECT\_CALL(mock, Foo("{}abc"{}, \_, \_)).WillOnce(Invoke(DistanceToOrigin));}}
\DoxyCodeLine{1775 \textcolor{comment}{//   EXPECT\_CALL(mock, Bar(5, \_, \_)).WillOnce(Invoke(DistanceToOrigin));}}
\DoxyCodeLine{1776 \textcolor{keyword}{typedef} internal::IgnoredValue Unused;}
\DoxyCodeLine{1777 }
\DoxyCodeLine{1778 \textcolor{comment}{// Creates an action that does actions a1, a2, ..., sequentially in}}
\DoxyCodeLine{1779 \textcolor{comment}{// each invocation. All but the last action will have a readonly view of the}}
\DoxyCodeLine{1780 \textcolor{comment}{// arguments.}}
\DoxyCodeLine{1781 \textcolor{keyword}{template} <\textcolor{keyword}{typename}... Action>}
\DoxyCodeLine{1782 internal::DoAllAction<typename std::decay<Action>::type...> DoAll(}
\DoxyCodeLine{1783     Action\&\&... action) \{}
\DoxyCodeLine{1784   \textcolor{keywordflow}{return} internal::DoAllAction<typename std::decay<Action>::type...>(}
\DoxyCodeLine{1785       \{\}, std::forward<Action>(action)...);}
\DoxyCodeLine{1786 \}}
\DoxyCodeLine{1787 }
\DoxyCodeLine{1788 \textcolor{comment}{// WithArg<k>(an\_action) creates an action that passes the k-\/th}}
\DoxyCodeLine{1789 \textcolor{comment}{// (0-\/based) argument of the mock function to an\_action and performs}}
\DoxyCodeLine{1790 \textcolor{comment}{// it.  It adapts an action accepting one argument to one that accepts}}
\DoxyCodeLine{1791 \textcolor{comment}{// multiple arguments.  For convenience, we also provide}}
\DoxyCodeLine{1792 \textcolor{comment}{// WithArgs<k>(an\_action) (defined below) as a synonym.}}
\DoxyCodeLine{1793 \textcolor{keyword}{template} <\textcolor{keywordtype}{size\_t} k, \textcolor{keyword}{typename} InnerAction>}
\DoxyCodeLine{1794 internal::WithArgsAction<typename std::decay<InnerAction>::type, k> WithArg(}
\DoxyCodeLine{1795     InnerAction\&\& action) \{}
\DoxyCodeLine{1796   \textcolor{keywordflow}{return} \{std::forward<InnerAction>(action)\};}
\DoxyCodeLine{1797 \}}
\DoxyCodeLine{1798 }
\DoxyCodeLine{1799 \textcolor{comment}{// WithArgs<N1, N2, ..., Nk>(an\_action) creates an action that passes}}
\DoxyCodeLine{1800 \textcolor{comment}{// the selected arguments of the mock function to an\_action and}}
\DoxyCodeLine{1801 \textcolor{comment}{// performs it.  It serves as an adaptor between actions with}}
\DoxyCodeLine{1802 \textcolor{comment}{// different argument lists.}}
\DoxyCodeLine{1803 \textcolor{keyword}{template} <\textcolor{keywordtype}{size\_t} k, \textcolor{keywordtype}{size\_t}... ks, \textcolor{keyword}{typename} InnerAction>}
\DoxyCodeLine{1804 internal::WithArgsAction<typename std::decay<InnerAction>::type, k, ks...>}
\DoxyCodeLine{1805 WithArgs(InnerAction\&\& action) \{}
\DoxyCodeLine{1806   \textcolor{keywordflow}{return} \{std::forward<InnerAction>(action)\};}
\DoxyCodeLine{1807 \}}
\DoxyCodeLine{1808 }
\DoxyCodeLine{1809 \textcolor{comment}{// WithoutArgs(inner\_action) can be used in a mock function with a}}
\DoxyCodeLine{1810 \textcolor{comment}{// non-\/empty argument list to perform inner\_action, which takes no}}
\DoxyCodeLine{1811 \textcolor{comment}{// argument.  In other words, it adapts an action accepting no}}
\DoxyCodeLine{1812 \textcolor{comment}{// argument to one that accepts (and ignores) arguments.}}
\DoxyCodeLine{1813 \textcolor{keyword}{template} <\textcolor{keyword}{typename} InnerAction>}
\DoxyCodeLine{1814 internal::WithArgsAction<typename std::decay<InnerAction>::type> WithoutArgs(}
\DoxyCodeLine{1815     InnerAction\&\& action) \{}
\DoxyCodeLine{1816   \textcolor{keywordflow}{return} \{std::forward<InnerAction>(action)\};}
\DoxyCodeLine{1817 \}}
\DoxyCodeLine{1818 }
\DoxyCodeLine{1819 \textcolor{comment}{// Creates an action that returns a value.}}
\DoxyCodeLine{1820 \textcolor{comment}{//}}
\DoxyCodeLine{1821 \textcolor{comment}{// The returned type can be used with a mock function returning a non-\/void,}}
\DoxyCodeLine{1822 \textcolor{comment}{// non-\/reference type U as follows:}}
\DoxyCodeLine{1823 \textcolor{comment}{//}}
\DoxyCodeLine{1824 \textcolor{comment}{//  *  If R is convertible to U and U is move-\/constructible, then the action can}}
\DoxyCodeLine{1825 \textcolor{comment}{//     be used with WillOnce.}}
\DoxyCodeLine{1826 \textcolor{comment}{//}}
\DoxyCodeLine{1827 \textcolor{comment}{//  *  If const R\& is convertible to U and U is copy-\/constructible, then the}}
\DoxyCodeLine{1828 \textcolor{comment}{//     action can be used with both WillOnce and WillRepeatedly.}}
\DoxyCodeLine{1829 \textcolor{comment}{//}}
\DoxyCodeLine{1830 \textcolor{comment}{// The mock expectation contains the R value from which the U return value is}}
\DoxyCodeLine{1831 \textcolor{comment}{// constructed (a move/copy of the argument to Return). This means that the R}}
\DoxyCodeLine{1832 \textcolor{comment}{// value will survive at least until the mock object's expectations are cleared}}
\DoxyCodeLine{1833 \textcolor{comment}{// or the mock object is destroyed, meaning that U can safely be a}}
\DoxyCodeLine{1834 \textcolor{comment}{// reference-\/like type such as std::string\_view:}}
\DoxyCodeLine{1835 \textcolor{comment}{//}}
\DoxyCodeLine{1836 \textcolor{comment}{//     // The mock function returns a view of a copy of the string fed to}}
\DoxyCodeLine{1837 \textcolor{comment}{//     // Return. The view is valid even after the action is performed.}}
\DoxyCodeLine{1838 \textcolor{comment}{//     MockFunction<std::string\_view()> mock;}}
\DoxyCodeLine{1839 \textcolor{comment}{//     EXPECT\_CALL(mock, Call).WillOnce(Return(std::string("{}taco"{})));}}
\DoxyCodeLine{1840 \textcolor{comment}{//     const std::string\_view result = mock.AsStdFunction()();}}
\DoxyCodeLine{1841 \textcolor{comment}{//     EXPECT\_EQ("{}taco"{}, result);}}
\DoxyCodeLine{1842 \textcolor{comment}{//}}
\DoxyCodeLine{1843 \textcolor{keyword}{template} <\textcolor{keyword}{typename} R>}
\DoxyCodeLine{1844 internal::ReturnAction<R> Return(R value) \{}
\DoxyCodeLine{1845   \textcolor{keywordflow}{return} internal::ReturnAction<R>(std::move(value));}
\DoxyCodeLine{1846 \}}
\DoxyCodeLine{1847 }
\DoxyCodeLine{1848 \textcolor{comment}{// Creates an action that returns NULL.}}
\DoxyCodeLine{1849 \textcolor{keyword}{inline} PolymorphicAction<internal::ReturnNullAction> ReturnNull() \{}
\DoxyCodeLine{1850   \textcolor{keywordflow}{return} MakePolymorphicAction(internal::ReturnNullAction());}
\DoxyCodeLine{1851 \}}
\DoxyCodeLine{1852 }
\DoxyCodeLine{1853 \textcolor{comment}{// Creates an action that returns from a void function.}}
\DoxyCodeLine{1854 \textcolor{keyword}{inline} PolymorphicAction<internal::ReturnVoidAction> Return() \{}
\DoxyCodeLine{1855   \textcolor{keywordflow}{return} MakePolymorphicAction(internal::ReturnVoidAction());}
\DoxyCodeLine{1856 \}}
\DoxyCodeLine{1857 }
\DoxyCodeLine{1858 \textcolor{comment}{// Creates an action that returns the reference to a variable.}}
\DoxyCodeLine{1859 \textcolor{keyword}{template} <\textcolor{keyword}{typename} R>}
\DoxyCodeLine{1860 \textcolor{keyword}{inline} internal::ReturnRefAction<R> ReturnRef(R\& x) \{  \textcolor{comment}{// NOLINT}}
\DoxyCodeLine{1861   \textcolor{keywordflow}{return} internal::ReturnRefAction<R>(x);}
\DoxyCodeLine{1862 \}}
\DoxyCodeLine{1863 }
\DoxyCodeLine{1864 \textcolor{comment}{// Prevent using ReturnRef on reference to temporary.}}
\DoxyCodeLine{1865 \textcolor{keyword}{template} <\textcolor{keyword}{typename} R, R* = \textcolor{keywordtype}{nullptr}>}
\DoxyCodeLine{1866 internal::ReturnRefAction<R> ReturnRef(R\&\&) = \textcolor{keyword}{delete};}
\DoxyCodeLine{1867 }
\DoxyCodeLine{1868 \textcolor{comment}{// Creates an action that returns the reference to a copy of the}}
\DoxyCodeLine{1869 \textcolor{comment}{// argument.  The copy is created when the action is constructed and}}
\DoxyCodeLine{1870 \textcolor{comment}{// lives as long as the action.}}
\DoxyCodeLine{1871 \textcolor{keyword}{template} <\textcolor{keyword}{typename} R>}
\DoxyCodeLine{1872 \textcolor{keyword}{inline} internal::ReturnRefOfCopyAction<R> ReturnRefOfCopy(\textcolor{keyword}{const} R\& x) \{}
\DoxyCodeLine{1873   \textcolor{keywordflow}{return} internal::ReturnRefOfCopyAction<R>(x);}
\DoxyCodeLine{1874 \}}
\DoxyCodeLine{1875 }
\DoxyCodeLine{1876 \textcolor{comment}{// DEPRECATED: use Return(x) directly with WillOnce.}}
\DoxyCodeLine{1877 \textcolor{comment}{//}}
\DoxyCodeLine{1878 \textcolor{comment}{// Modifies the parent action (a Return() action) to perform a move of the}}
\DoxyCodeLine{1879 \textcolor{comment}{// argument instead of a copy.}}
\DoxyCodeLine{1880 \textcolor{comment}{// Return(ByMove()) actions can only be executed once and will assert this}}
\DoxyCodeLine{1881 \textcolor{comment}{// invariant.}}
\DoxyCodeLine{1882 \textcolor{keyword}{template} <\textcolor{keyword}{typename} R>}
\DoxyCodeLine{1883 internal::ByMoveWrapper<R> ByMove(R x) \{}
\DoxyCodeLine{1884   \textcolor{keywordflow}{return} internal::ByMoveWrapper<R>(std::move(x));}
\DoxyCodeLine{1885 \}}
\DoxyCodeLine{1886 }
\DoxyCodeLine{1887 \textcolor{comment}{// Creates an action that returns an element of `vals`. Calling this action will}}
\DoxyCodeLine{1888 \textcolor{comment}{// repeatedly return the next value from `vals` until it reaches the end and}}
\DoxyCodeLine{1889 \textcolor{comment}{// will restart from the beginning.}}
\DoxyCodeLine{1890 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{1891 internal::ReturnRoundRobinAction<T> ReturnRoundRobin(std::vector<T> vals) \{}
\DoxyCodeLine{1892   \textcolor{keywordflow}{return} internal::ReturnRoundRobinAction<T>(std::move(vals));}
\DoxyCodeLine{1893 \}}
\DoxyCodeLine{1894 }
\DoxyCodeLine{1895 \textcolor{comment}{// Creates an action that returns an element of `vals`. Calling this action will}}
\DoxyCodeLine{1896 \textcolor{comment}{// repeatedly return the next value from `vals` until it reaches the end and}}
\DoxyCodeLine{1897 \textcolor{comment}{// will restart from the beginning.}}
\DoxyCodeLine{1898 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{1899 internal::ReturnRoundRobinAction<T> ReturnRoundRobin(}
\DoxyCodeLine{1900     std::initializer\_list<T> vals) \{}
\DoxyCodeLine{1901   \textcolor{keywordflow}{return} internal::ReturnRoundRobinAction<T>(std::vector<T>(vals));}
\DoxyCodeLine{1902 \}}
\DoxyCodeLine{1903 }
\DoxyCodeLine{1904 \textcolor{comment}{// Creates an action that does the default action for the give mock function.}}
\DoxyCodeLine{1905 \textcolor{keyword}{inline} internal::DoDefaultAction DoDefault() \{}
\DoxyCodeLine{1906   \textcolor{keywordflow}{return} internal::DoDefaultAction();}
\DoxyCodeLine{1907 \}}
\DoxyCodeLine{1908 }
\DoxyCodeLine{1909 \textcolor{comment}{// Creates an action that sets the variable pointed by the N-\/th}}
\DoxyCodeLine{1910 \textcolor{comment}{// (0-\/based) function argument to 'value'.}}
\DoxyCodeLine{1911 \textcolor{keyword}{template} <\textcolor{keywordtype}{size\_t} N, \textcolor{keyword}{typename} T>}
\DoxyCodeLine{1912 internal::SetArgumentPointeeAction<N, T> SetArgPointee(T value) \{}
\DoxyCodeLine{1913   \textcolor{keywordflow}{return} \{std::move(value)\};}
\DoxyCodeLine{1914 \}}
\DoxyCodeLine{1915 }
\DoxyCodeLine{1916 \textcolor{comment}{// The following version is DEPRECATED.}}
\DoxyCodeLine{1917 \textcolor{keyword}{template} <\textcolor{keywordtype}{size\_t} N, \textcolor{keyword}{typename} T>}
\DoxyCodeLine{1918 internal::SetArgumentPointeeAction<N, T> SetArgumentPointee(T value) \{}
\DoxyCodeLine{1919   \textcolor{keywordflow}{return} \{std::move(value)\};}
\DoxyCodeLine{1920 \}}
\DoxyCodeLine{1921 }
\DoxyCodeLine{1922 \textcolor{comment}{// Creates an action that sets a pointer referent to a given value.}}
\DoxyCodeLine{1923 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T1, \textcolor{keyword}{typename} T2>}
\DoxyCodeLine{1924 PolymorphicAction<internal::AssignAction<T1, T2>> Assign(T1* ptr, T2 val) \{}
\DoxyCodeLine{1925   \textcolor{keywordflow}{return} MakePolymorphicAction(internal::AssignAction<T1, T2>(ptr, val));}
\DoxyCodeLine{1926 \}}
\DoxyCodeLine{1927 }
\DoxyCodeLine{1928 \textcolor{preprocessor}{\#if !GTEST\_OS\_WINDOWS\_MOBILE}}
\DoxyCodeLine{1929 }
\DoxyCodeLine{1930 \textcolor{comment}{// Creates an action that sets errno and returns the appropriate error.}}
\DoxyCodeLine{1931 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{1932 PolymorphicAction<internal::SetErrnoAndReturnAction<T>> SetErrnoAndReturn(}
\DoxyCodeLine{1933     \textcolor{keywordtype}{int} errval, T result) \{}
\DoxyCodeLine{1934   \textcolor{keywordflow}{return} MakePolymorphicAction(}
\DoxyCodeLine{1935       internal::SetErrnoAndReturnAction<T>(errval, result));}
\DoxyCodeLine{1936 \}}
\DoxyCodeLine{1937 }
\DoxyCodeLine{1938 \textcolor{preprocessor}{\#endif  }\textcolor{comment}{// !GTEST\_OS\_WINDOWS\_MOBILE}}
\DoxyCodeLine{1939 }
\DoxyCodeLine{1940 \textcolor{comment}{// Various overloads for Invoke().}}
\DoxyCodeLine{1941 }
\DoxyCodeLine{1942 \textcolor{comment}{// Legacy function.}}
\DoxyCodeLine{1943 \textcolor{comment}{// Actions can now be implicitly constructed from callables. No need to create}}
\DoxyCodeLine{1944 \textcolor{comment}{// wrapper objects.}}
\DoxyCodeLine{1945 \textcolor{comment}{// This function exists for backwards compatibility.}}
\DoxyCodeLine{1946 \textcolor{keyword}{template} <\textcolor{keyword}{typename} FunctionImpl>}
\DoxyCodeLine{1947 \textcolor{keyword}{typename} std::decay<FunctionImpl>::type Invoke(FunctionImpl\&\& function\_impl) \{}
\DoxyCodeLine{1948   \textcolor{keywordflow}{return} std::forward<FunctionImpl>(function\_impl);}
\DoxyCodeLine{1949 \}}
\DoxyCodeLine{1950 }
\DoxyCodeLine{1951 \textcolor{comment}{// Creates an action that invokes the given method on the given object}}
\DoxyCodeLine{1952 \textcolor{comment}{// with the mock function's arguments.}}
\DoxyCodeLine{1953 \textcolor{keyword}{template} <\textcolor{keyword}{class} Class, \textcolor{keyword}{typename} MethodPtr>}
\DoxyCodeLine{1954 internal::InvokeMethodAction<Class, MethodPtr> Invoke(Class* obj\_ptr,}
\DoxyCodeLine{1955                                                       MethodPtr method\_ptr) \{}
\DoxyCodeLine{1956   \textcolor{keywordflow}{return} \{obj\_ptr, method\_ptr\};}
\DoxyCodeLine{1957 \}}
\DoxyCodeLine{1958 }
\DoxyCodeLine{1959 \textcolor{comment}{// Creates an action that invokes 'function\_impl' with no argument.}}
\DoxyCodeLine{1960 \textcolor{keyword}{template} <\textcolor{keyword}{typename} FunctionImpl>}
\DoxyCodeLine{1961 internal::InvokeWithoutArgsAction<typename std::decay<FunctionImpl>::type>}
\DoxyCodeLine{1962 InvokeWithoutArgs(FunctionImpl function\_impl) \{}
\DoxyCodeLine{1963   \textcolor{keywordflow}{return} \{std::move(function\_impl)\};}
\DoxyCodeLine{1964 \}}
\DoxyCodeLine{1965 }
\DoxyCodeLine{1966 \textcolor{comment}{// Creates an action that invokes the given method on the given object}}
\DoxyCodeLine{1967 \textcolor{comment}{// with no argument.}}
\DoxyCodeLine{1968 \textcolor{keyword}{template} <\textcolor{keyword}{class} Class, \textcolor{keyword}{typename} MethodPtr>}
\DoxyCodeLine{1969 internal::InvokeMethodWithoutArgsAction<Class, MethodPtr> InvokeWithoutArgs(}
\DoxyCodeLine{1970     Class* obj\_ptr, MethodPtr method\_ptr) \{}
\DoxyCodeLine{1971   \textcolor{keywordflow}{return} \{obj\_ptr, method\_ptr\};}
\DoxyCodeLine{1972 \}}
\DoxyCodeLine{1973 }
\DoxyCodeLine{1974 \textcolor{comment}{// Creates an action that performs an\_action and throws away its}}
\DoxyCodeLine{1975 \textcolor{comment}{// result.  In other words, it changes the return type of an\_action to}}
\DoxyCodeLine{1976 \textcolor{comment}{// void.  an\_action MUST NOT return void, or the code won't compile.}}
\DoxyCodeLine{1977 \textcolor{keyword}{template} <\textcolor{keyword}{typename} A>}
\DoxyCodeLine{1978 \textcolor{keyword}{inline} internal::IgnoreResultAction<A> IgnoreResult(\textcolor{keyword}{const} A\& an\_action) \{}
\DoxyCodeLine{1979   \textcolor{keywordflow}{return} internal::IgnoreResultAction<A>(an\_action);}
\DoxyCodeLine{1980 \}}
\DoxyCodeLine{1981 }
\DoxyCodeLine{1982 \textcolor{comment}{// Creates a reference wrapper for the given L-\/value.  If necessary,}}
\DoxyCodeLine{1983 \textcolor{comment}{// you can explicitly specify the type of the reference.  For example,}}
\DoxyCodeLine{1984 \textcolor{comment}{// suppose 'derived' is an object of type Derived, ByRef(derived)}}
\DoxyCodeLine{1985 \textcolor{comment}{// would wrap a Derived\&.  If you want to wrap a const Base\& instead,}}
\DoxyCodeLine{1986 \textcolor{comment}{// where Base is a base class of Derived, just write:}}
\DoxyCodeLine{1987 \textcolor{comment}{//}}
\DoxyCodeLine{1988 \textcolor{comment}{//   ByRef<const Base>(derived)}}
\DoxyCodeLine{1989 \textcolor{comment}{//}}
\DoxyCodeLine{1990 \textcolor{comment}{// N.B. ByRef is redundant with std::ref, std::cref and std::reference\_wrapper.}}
\DoxyCodeLine{1991 \textcolor{comment}{// However, it may still be used for consistency with ByMove().}}
\DoxyCodeLine{1992 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{1993 inline ::std::reference\_wrapper<T> ByRef(T\& l\_value) \{  \textcolor{comment}{// NOLINT}}
\DoxyCodeLine{1994   return ::std::reference\_wrapper<T>(l\_value);}
\DoxyCodeLine{1995 \}}
\DoxyCodeLine{1996 }
\DoxyCodeLine{1997 \textcolor{comment}{// The ReturnNew<T>(a1, a2, ..., a\_k) action returns a pointer to a new}}
\DoxyCodeLine{1998 \textcolor{comment}{// instance of type T, constructed on the heap with constructor arguments}}
\DoxyCodeLine{1999 \textcolor{comment}{// a1, a2, ..., and a\_k. The caller assumes ownership of the returned value.}}
\DoxyCodeLine{2000 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T, \textcolor{keyword}{typename}... Params>}
\DoxyCodeLine{2001 internal::ReturnNewAction<T, typename std::decay<Params>::type...> ReturnNew(}
\DoxyCodeLine{2002     Params\&\&... params) \{}
\DoxyCodeLine{2003   \textcolor{keywordflow}{return} \{std::forward\_as\_tuple(std::forward<Params>(params)...)\};}
\DoxyCodeLine{2004 \}}
\DoxyCodeLine{2005 }
\DoxyCodeLine{2006 \textcolor{comment}{// Action ReturnArg<k>() returns the k-\/th argument of the mock function.}}
\DoxyCodeLine{2007 \textcolor{keyword}{template} <\textcolor{keywordtype}{size\_t} k>}
\DoxyCodeLine{2008 internal::ReturnArgAction<k> ReturnArg() \{}
\DoxyCodeLine{2009   \textcolor{keywordflow}{return} \{\};}
\DoxyCodeLine{2010 \}}
\DoxyCodeLine{2011 }
\DoxyCodeLine{2012 \textcolor{comment}{// Action SaveArg<k>(pointer) saves the k-\/th (0-\/based) argument of the}}
\DoxyCodeLine{2013 \textcolor{comment}{// mock function to *pointer.}}
\DoxyCodeLine{2014 \textcolor{keyword}{template} <\textcolor{keywordtype}{size\_t} k, \textcolor{keyword}{typename} Ptr>}
\DoxyCodeLine{2015 internal::SaveArgAction<k, Ptr> SaveArg(Ptr pointer) \{}
\DoxyCodeLine{2016   \textcolor{keywordflow}{return} \{pointer\};}
\DoxyCodeLine{2017 \}}
\DoxyCodeLine{2018 }
\DoxyCodeLine{2019 \textcolor{comment}{// Action SaveArgPointee<k>(pointer) saves the value pointed to}}
\DoxyCodeLine{2020 \textcolor{comment}{// by the k-\/th (0-\/based) argument of the mock function to *pointer.}}
\DoxyCodeLine{2021 \textcolor{keyword}{template} <\textcolor{keywordtype}{size\_t} k, \textcolor{keyword}{typename} Ptr>}
\DoxyCodeLine{2022 internal::SaveArgPointeeAction<k, Ptr> SaveArgPointee(Ptr pointer) \{}
\DoxyCodeLine{2023   \textcolor{keywordflow}{return} \{pointer\};}
\DoxyCodeLine{2024 \}}
\DoxyCodeLine{2025 }
\DoxyCodeLine{2026 \textcolor{comment}{// Action SetArgReferee<k>(value) assigns 'value' to the variable}}
\DoxyCodeLine{2027 \textcolor{comment}{// referenced by the k-\/th (0-\/based) argument of the mock function.}}
\DoxyCodeLine{2028 \textcolor{keyword}{template} <\textcolor{keywordtype}{size\_t} k, \textcolor{keyword}{typename} T>}
\DoxyCodeLine{2029 internal::SetArgRefereeAction<k, typename std::decay<T>::type> SetArgReferee(}
\DoxyCodeLine{2030     T\&\& value) \{}
\DoxyCodeLine{2031   \textcolor{keywordflow}{return} \{std::forward<T>(value)\};}
\DoxyCodeLine{2032 \}}
\DoxyCodeLine{2033 }
\DoxyCodeLine{2034 \textcolor{comment}{// Action SetArrayArgument<k>(first, last) copies the elements in}}
\DoxyCodeLine{2035 \textcolor{comment}{// source range [first, last) to the array pointed to by the k-\/th}}
\DoxyCodeLine{2036 \textcolor{comment}{// (0-\/based) argument, which can be either a pointer or an}}
\DoxyCodeLine{2037 \textcolor{comment}{// iterator. The action does not take ownership of the elements in the}}
\DoxyCodeLine{2038 \textcolor{comment}{// source range.}}
\DoxyCodeLine{2039 \textcolor{keyword}{template} <\textcolor{keywordtype}{size\_t} k, \textcolor{keyword}{typename} I1, \textcolor{keyword}{typename} I2>}
\DoxyCodeLine{2040 internal::SetArrayArgumentAction<k, I1, I2> SetArrayArgument(I1 first,}
\DoxyCodeLine{2041                                                              I2 last) \{}
\DoxyCodeLine{2042   \textcolor{keywordflow}{return} \{first, last\};}
\DoxyCodeLine{2043 \}}
\DoxyCodeLine{2044 }
\DoxyCodeLine{2045 \textcolor{comment}{// Action DeleteArg<k>() deletes the k-\/th (0-\/based) argument of the mock}}
\DoxyCodeLine{2046 \textcolor{comment}{// function.}}
\DoxyCodeLine{2047 \textcolor{keyword}{template} <\textcolor{keywordtype}{size\_t} k>}
\DoxyCodeLine{2048 internal::DeleteArgAction<k> DeleteArg() \{}
\DoxyCodeLine{2049   \textcolor{keywordflow}{return} \{\};}
\DoxyCodeLine{2050 \}}
\DoxyCodeLine{2051 }
\DoxyCodeLine{2052 \textcolor{comment}{// This action returns the value pointed to by 'pointer'.}}
\DoxyCodeLine{2053 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Ptr>}
\DoxyCodeLine{2054 internal::ReturnPointeeAction<Ptr> ReturnPointee(Ptr pointer) \{}
\DoxyCodeLine{2055   \textcolor{keywordflow}{return} \{pointer\};}
\DoxyCodeLine{2056 \}}
\DoxyCodeLine{2057 }
\DoxyCodeLine{2058 \textcolor{comment}{// Action Throw(exception) can be used in a mock function of any type}}
\DoxyCodeLine{2059 \textcolor{comment}{// to throw the given exception.  Any copyable value can be thrown.}}
\DoxyCodeLine{2060 \textcolor{preprocessor}{\#if GTEST\_HAS\_EXCEPTIONS}}
\DoxyCodeLine{2061 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{2062 internal::ThrowAction<typename std::decay<T>::type> Throw(T\&\& exception) \{}
\DoxyCodeLine{2063   \textcolor{keywordflow}{return} \{std::forward<T>(exception)\};}
\DoxyCodeLine{2064 \}}
\DoxyCodeLine{2065 \textcolor{preprocessor}{\#endif  }\textcolor{comment}{// GTEST\_HAS\_EXCEPTIONS}}
\DoxyCodeLine{2066 }
\DoxyCodeLine{2067 \textcolor{keyword}{namespace }internal \{}
\DoxyCodeLine{2068 }
\DoxyCodeLine{2069 \textcolor{comment}{// A macro from the ACTION* family (defined later in gmock-\/generated-\/actions.h)}}
\DoxyCodeLine{2070 \textcolor{comment}{// defines an action that can be used in a mock function.  Typically,}}
\DoxyCodeLine{2071 \textcolor{comment}{// these actions only care about a subset of the arguments of the mock}}
\DoxyCodeLine{2072 \textcolor{comment}{// function.  For example, if such an action only uses the second}}
\DoxyCodeLine{2073 \textcolor{comment}{// argument, it can be used in any mock function that takes >= 2}}
\DoxyCodeLine{2074 \textcolor{comment}{// arguments where the type of the second argument is compatible.}}
\DoxyCodeLine{2075 \textcolor{comment}{//}}
\DoxyCodeLine{2076 \textcolor{comment}{// Therefore, the action implementation must be prepared to take more}}
\DoxyCodeLine{2077 \textcolor{comment}{// arguments than it needs.  The ExcessiveArg type is used to}}
\DoxyCodeLine{2078 \textcolor{comment}{// represent those excessive arguments.  In order to keep the compiler}}
\DoxyCodeLine{2079 \textcolor{comment}{// error messages tractable, we define it in the testing namespace}}
\DoxyCodeLine{2080 \textcolor{comment}{// instead of testing::internal.  However, this is an INTERNAL TYPE}}
\DoxyCodeLine{2081 \textcolor{comment}{// and subject to change without notice, so a user MUST NOT USE THIS}}
\DoxyCodeLine{2082 \textcolor{comment}{// TYPE DIRECTLY.}}
\DoxyCodeLine{2083 \textcolor{keyword}{struct }\mbox{\hyperlink{structtesting_1_1internal_1_1ExcessiveArg}{ExcessiveArg}} \{\};}
\DoxyCodeLine{2084 }
\DoxyCodeLine{2085 \textcolor{comment}{// Builds an implementation of an Action<> for some particular signature, using}}
\DoxyCodeLine{2086 \textcolor{comment}{// a class defined by an ACTION* macro.}}
\DoxyCodeLine{2087 \textcolor{keyword}{template} <\textcolor{keyword}{typename} F, \textcolor{keyword}{typename} Impl>}
\DoxyCodeLine{2088 \textcolor{keyword}{struct }\mbox{\hyperlink{structtesting_1_1internal_1_1ActionImpl}{ActionImpl}};}
\DoxyCodeLine{2089 }
\DoxyCodeLine{2090 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Impl>}
\DoxyCodeLine{2091 \textcolor{keyword}{struct }\mbox{\hyperlink{structtesting_1_1internal_1_1ImplBase}{ImplBase}} \{}
\DoxyCodeLine{2092   \textcolor{keyword}{struct }\mbox{\hyperlink{structtesting_1_1internal_1_1ImplBase_1_1Holder}{Holder}} \{}
\DoxyCodeLine{2093     \textcolor{comment}{// Allows each copy of the Action<> to get to the Impl.}}
\DoxyCodeLine{2094     \textcolor{keyword}{explicit} \textcolor{keyword}{operator} \textcolor{keyword}{const} Impl\&() \textcolor{keyword}{const} \{ \textcolor{keywordflow}{return} *ptr; \}}
\DoxyCodeLine{2095     std::shared\_ptr<Impl> ptr;}
\DoxyCodeLine{2096   \};}
\DoxyCodeLine{2097   \textcolor{keyword}{using }type = \textcolor{keyword}{typename} std::conditional<std::is\_constructible<Impl>::value,}
\DoxyCodeLine{2098                                          Impl, \mbox{\hyperlink{structtesting_1_1internal_1_1ImplBase_1_1Holder}{Holder}}>::type;}
\DoxyCodeLine{2099 \};}
\DoxyCodeLine{2100 }
\DoxyCodeLine{2101 \textcolor{keyword}{template} <\textcolor{keyword}{typename} R, \textcolor{keyword}{typename}... Args, \textcolor{keyword}{typename} Impl>}
\DoxyCodeLine{2102 \textcolor{keyword}{struct }\mbox{\hyperlink{structtesting_1_1internal_1_1ActionImpl}{ActionImpl}}<R(Args...), Impl> : \mbox{\hyperlink{structtesting_1_1internal_1_1ImplBase}{ImplBase}}<Impl>::type \{}
\DoxyCodeLine{2103   \textcolor{keyword}{using }\mbox{\hyperlink{classBase}{Base}} = \textcolor{keyword}{typename} ImplBase<Impl>::type;}
\DoxyCodeLine{2104   \textcolor{keyword}{using }function\_type = R(Args...);}
\DoxyCodeLine{2105   \textcolor{keyword}{using }args\_type = std::tuple<Args...>;}
\DoxyCodeLine{2106 }
\DoxyCodeLine{2107   \mbox{\hyperlink{structtesting_1_1internal_1_1ActionImpl}{ActionImpl}}() = \textcolor{keywordflow}{default};  \textcolor{comment}{// Only defined if appropriate for Base.}}
\DoxyCodeLine{2108   \textcolor{keyword}{explicit} \mbox{\hyperlink{structtesting_1_1internal_1_1ActionImpl}{ActionImpl}}(std::shared\_ptr<Impl> impl) : \mbox{\hyperlink{classBase}{Base}}\{std::move(impl)\} \{\}}
\DoxyCodeLine{2109 }
\DoxyCodeLine{2110   R operator()(Args\&\&... arg)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{2111     \textcolor{keyword}{static} \textcolor{keyword}{constexpr} \textcolor{keywordtype}{size\_t} kMaxArgs =}
\DoxyCodeLine{2112         \textcolor{keyword}{sizeof}...(Args) <= 10 ? \textcolor{keyword}{sizeof}...(Args) : 10;}
\DoxyCodeLine{2113     \textcolor{keywordflow}{return} Apply(MakeIndexSequence<kMaxArgs>\{\},}
\DoxyCodeLine{2114                  MakeIndexSequence<10 -\/ kMaxArgs>\{\},}
\DoxyCodeLine{2115                  args\_type\{std::forward<Args>(arg)...\});}
\DoxyCodeLine{2116   \}}
\DoxyCodeLine{2117 }
\DoxyCodeLine{2118   \textcolor{keyword}{template} <std::size\_t... arg\_id, std::size\_t... excess\_id>}
\DoxyCodeLine{2119   R Apply(\mbox{\hyperlink{structtesting_1_1internal_1_1IndexSequence}{IndexSequence<arg\_id...>}}, \mbox{\hyperlink{structtesting_1_1internal_1_1IndexSequence}{IndexSequence<excess\_id...>}},}
\DoxyCodeLine{2120           \textcolor{keyword}{const} args\_type\& args)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{2121     \textcolor{comment}{// Impl need not be specific to the signature of action being implemented;}}
\DoxyCodeLine{2122     \textcolor{comment}{// only the implementing function body needs to have all of the specific}}
\DoxyCodeLine{2123     \textcolor{comment}{// types instantiated.  Up to 10 of the args that are provided by the}}
\DoxyCodeLine{2124     \textcolor{comment}{// args\_type get passed, followed by a dummy of unspecified type for the}}
\DoxyCodeLine{2125     \textcolor{comment}{// remainder up to 10 explicit args.}}
\DoxyCodeLine{2126     \textcolor{keyword}{static} \textcolor{keyword}{constexpr} \mbox{\hyperlink{structtesting_1_1internal_1_1ExcessiveArg}{ExcessiveArg}} kExcessArg\{\};}
\DoxyCodeLine{2127     \textcolor{keywordflow}{return} \textcolor{keyword}{static\_cast<}\textcolor{keyword}{const }Impl\&\textcolor{keyword}{>}(*this)}
\DoxyCodeLine{2128         .template gmock\_PerformImpl<}
\DoxyCodeLine{2129             \textcolor{comment}{/*function\_type=*/}function\_type, \textcolor{comment}{/*return\_type=*/}R,}
\DoxyCodeLine{2130             \textcolor{comment}{/*args\_type=*/}args\_type,}
\DoxyCodeLine{2131             \textcolor{comment}{/*argN\_type=*/}}
\DoxyCodeLine{2132             \textcolor{keyword}{typename} std::tuple\_element<arg\_id, args\_type>::type...>(}
\DoxyCodeLine{2133             \textcolor{comment}{/*args=*/}args, std::get<arg\_id>(args)...,}
\DoxyCodeLine{2134             ((void)excess\_id, kExcessArg)...);}
\DoxyCodeLine{2135   \}}
\DoxyCodeLine{2136 \};}
\DoxyCodeLine{2137 }
\DoxyCodeLine{2138 \textcolor{comment}{// Stores a default-\/constructed Impl as part of the Action<>'s}}
\DoxyCodeLine{2139 \textcolor{comment}{// std::function<>. The Impl should be trivial to copy.}}
\DoxyCodeLine{2140 \textcolor{keyword}{template} <\textcolor{keyword}{typename} F, \textcolor{keyword}{typename} Impl>}
\DoxyCodeLine{2141 \mbox{\hyperlink{classtesting_1_1Action}{::testing::Action<F>}} MakeAction() \{}
\DoxyCodeLine{2142   return ::testing::Action<F>(\mbox{\hyperlink{structtesting_1_1internal_1_1ActionImpl}{ActionImpl<F, Impl>}}());}
\DoxyCodeLine{2143 \}}
\DoxyCodeLine{2144 }
\DoxyCodeLine{2145 \textcolor{comment}{// Stores just the one given instance of Impl.}}
\DoxyCodeLine{2146 \textcolor{keyword}{template} <\textcolor{keyword}{typename} F, \textcolor{keyword}{typename} Impl>}
\DoxyCodeLine{2147 \mbox{\hyperlink{classtesting_1_1Action}{::testing::Action<F>}} MakeAction(std::shared\_ptr<Impl> impl) \{}
\DoxyCodeLine{2148   return ::testing::Action<F>(ActionImpl<F, Impl>(std::move(impl)));}
\DoxyCodeLine{2149 \}}
\DoxyCodeLine{2150 }
\DoxyCodeLine{2151 \textcolor{preprocessor}{\#define GMOCK\_INTERNAL\_ARG\_UNUSED(i, data, el) \(\backslash\)}}
\DoxyCodeLine{2152 \textcolor{preprocessor}{  , const arg\#\#i\#\#\_type\& arg\#\#i GTEST\_ATTRIBUTE\_UNUSED\_}}
\DoxyCodeLine{2153 \textcolor{preprocessor}{\#define GMOCK\_ACTION\_ARG\_TYPES\_AND\_NAMES\_UNUSED\_                 \(\backslash\)}}
\DoxyCodeLine{2154 \textcolor{preprocessor}{  const args\_type\& args GTEST\_ATTRIBUTE\_UNUSED\_ GMOCK\_PP\_REPEAT( \(\backslash\)}}
\DoxyCodeLine{2155 \textcolor{preprocessor}{      GMOCK\_INTERNAL\_ARG\_UNUSED, , 10)}}
\DoxyCodeLine{2156 }
\DoxyCodeLine{2157 \textcolor{preprocessor}{\#define GMOCK\_INTERNAL\_ARG(i, data, el) , const arg\#\#i\#\#\_type\& arg\#\#i}}
\DoxyCodeLine{2158 \textcolor{preprocessor}{\#define GMOCK\_ACTION\_ARG\_TYPES\_AND\_NAMES\_ \(\backslash\)}}
\DoxyCodeLine{2159 \textcolor{preprocessor}{  const args\_type\& args GMOCK\_PP\_REPEAT(GMOCK\_INTERNAL\_ARG, , 10)}}
\DoxyCodeLine{2160 }
\DoxyCodeLine{2161 \textcolor{preprocessor}{\#define GMOCK\_INTERNAL\_TEMPLATE\_ARG(i, data, el) , typename arg\#\#i\#\#\_type}}
\DoxyCodeLine{2162 \textcolor{preprocessor}{\#define GMOCK\_ACTION\_TEMPLATE\_ARGS\_NAMES\_ \(\backslash\)}}
\DoxyCodeLine{2163 \textcolor{preprocessor}{  GMOCK\_PP\_TAIL(GMOCK\_PP\_REPEAT(GMOCK\_INTERNAL\_TEMPLATE\_ARG, , 10))}}
\DoxyCodeLine{2164 }
\DoxyCodeLine{2165 \textcolor{preprocessor}{\#define GMOCK\_INTERNAL\_TYPENAME\_PARAM(i, data, param) , typename param\#\#\_type}}
\DoxyCodeLine{2166 \textcolor{preprocessor}{\#define GMOCK\_ACTION\_TYPENAME\_PARAMS\_(params) \(\backslash\)}}
\DoxyCodeLine{2167 \textcolor{preprocessor}{  GMOCK\_PP\_TAIL(GMOCK\_PP\_FOR\_EACH(GMOCK\_INTERNAL\_TYPENAME\_PARAM, , params))}}
\DoxyCodeLine{2168 }
\DoxyCodeLine{2169 \textcolor{preprocessor}{\#define GMOCK\_INTERNAL\_TYPE\_PARAM(i, data, param) , param\#\#\_type}}
\DoxyCodeLine{2170 \textcolor{preprocessor}{\#define GMOCK\_ACTION\_TYPE\_PARAMS\_(params) \(\backslash\)}}
\DoxyCodeLine{2171 \textcolor{preprocessor}{  GMOCK\_PP\_TAIL(GMOCK\_PP\_FOR\_EACH(GMOCK\_INTERNAL\_TYPE\_PARAM, , params))}}
\DoxyCodeLine{2172 }
\DoxyCodeLine{2173 \textcolor{preprocessor}{\#define GMOCK\_INTERNAL\_TYPE\_GVALUE\_PARAM(i, data, param) \(\backslash\)}}
\DoxyCodeLine{2174 \textcolor{preprocessor}{  , param\#\#\_type gmock\_p\#\#i}}
\DoxyCodeLine{2175 \textcolor{preprocessor}{\#define GMOCK\_ACTION\_TYPE\_GVALUE\_PARAMS\_(params) \(\backslash\)}}
\DoxyCodeLine{2176 \textcolor{preprocessor}{  GMOCK\_PP\_TAIL(GMOCK\_PP\_FOR\_EACH(GMOCK\_INTERNAL\_TYPE\_GVALUE\_PARAM, , params))}}
\DoxyCodeLine{2177 }
\DoxyCodeLine{2178 \textcolor{preprocessor}{\#define GMOCK\_INTERNAL\_GVALUE\_PARAM(i, data, param) \(\backslash\)}}
\DoxyCodeLine{2179 \textcolor{preprocessor}{  , std::forward<param\#\#\_type>(gmock\_p\#\#i)}}
\DoxyCodeLine{2180 \textcolor{preprocessor}{\#define GMOCK\_ACTION\_GVALUE\_PARAMS\_(params) \(\backslash\)}}
\DoxyCodeLine{2181 \textcolor{preprocessor}{  GMOCK\_PP\_TAIL(GMOCK\_PP\_FOR\_EACH(GMOCK\_INTERNAL\_GVALUE\_PARAM, , params))}}
\DoxyCodeLine{2182 }
\DoxyCodeLine{2183 \textcolor{preprocessor}{\#define GMOCK\_INTERNAL\_INIT\_PARAM(i, data, param) \(\backslash\)}}
\DoxyCodeLine{2184 \textcolor{preprocessor}{  , param(::std::forward<param\#\#\_type>(gmock\_p\#\#i))}}
\DoxyCodeLine{2185 \textcolor{preprocessor}{\#define GMOCK\_ACTION\_INIT\_PARAMS\_(params) \(\backslash\)}}
\DoxyCodeLine{2186 \textcolor{preprocessor}{  GMOCK\_PP\_TAIL(GMOCK\_PP\_FOR\_EACH(GMOCK\_INTERNAL\_INIT\_PARAM, , params))}}
\DoxyCodeLine{2187 }
\DoxyCodeLine{2188 \textcolor{preprocessor}{\#define GMOCK\_INTERNAL\_FIELD\_PARAM(i, data, param) param\#\#\_type param;}}
\DoxyCodeLine{2189 \textcolor{preprocessor}{\#define GMOCK\_ACTION\_FIELD\_PARAMS\_(params) \(\backslash\)}}
\DoxyCodeLine{2190 \textcolor{preprocessor}{  GMOCK\_PP\_FOR\_EACH(GMOCK\_INTERNAL\_FIELD\_PARAM, , params)}}
\DoxyCodeLine{2191 }
\DoxyCodeLine{2192 \textcolor{preprocessor}{\#define GMOCK\_INTERNAL\_ACTION(name, full\_name, params)                         \(\backslash\)}}
\DoxyCodeLine{2193 \textcolor{preprocessor}{  template <GMOCK\_ACTION\_TYPENAME\_PARAMS\_(params)>                             \(\backslash\)}}
\DoxyCodeLine{2194 \textcolor{preprocessor}{  class full\_name \{                                                            \(\backslash\)}}
\DoxyCodeLine{2195 \textcolor{preprocessor}{   public:                                                                     \(\backslash\)}}
\DoxyCodeLine{2196 \textcolor{preprocessor}{    explicit full\_name(GMOCK\_ACTION\_TYPE\_GVALUE\_PARAMS\_(params))               \(\backslash\)}}
\DoxyCodeLine{2197 \textcolor{preprocessor}{        : impl\_(std::make\_shared<gmock\_Impl>(                                  \(\backslash\)}}
\DoxyCodeLine{2198 \textcolor{preprocessor}{              GMOCK\_ACTION\_GVALUE\_PARAMS\_(params))) \{\}                         \(\backslash\)}}
\DoxyCodeLine{2199 \textcolor{preprocessor}{    full\_name(const full\_name\&) = default;                                     \(\backslash\)}}
\DoxyCodeLine{2200 \textcolor{preprocessor}{    full\_name(full\_name\&\&) noexcept = default;                                 \(\backslash\)}}
\DoxyCodeLine{2201 \textcolor{preprocessor}{    template <typename F>                                                      \(\backslash\)}}
\DoxyCodeLine{2202 \textcolor{preprocessor}{    operator ::testing::Action<F>() const \{                                    \(\backslash\)}}
\DoxyCodeLine{2203 \textcolor{preprocessor}{      return ::testing::internal::MakeAction<F>(impl\_);                        \(\backslash\)}}
\DoxyCodeLine{2204 \textcolor{preprocessor}{    \}                                                                          \(\backslash\)}}
\DoxyCodeLine{2205 \textcolor{preprocessor}{                                                                               \(\backslash\)}}
\DoxyCodeLine{2206 \textcolor{preprocessor}{   private:                                                                    \(\backslash\)}}
\DoxyCodeLine{2207 \textcolor{preprocessor}{    class gmock\_Impl \{                                                         \(\backslash\)}}
\DoxyCodeLine{2208 \textcolor{preprocessor}{     public:                                                                   \(\backslash\)}}
\DoxyCodeLine{2209 \textcolor{preprocessor}{      explicit gmock\_Impl(GMOCK\_ACTION\_TYPE\_GVALUE\_PARAMS\_(params))            \(\backslash\)}}
\DoxyCodeLine{2210 \textcolor{preprocessor}{          : GMOCK\_ACTION\_INIT\_PARAMS\_(params) \{\}                               \(\backslash\)}}
\DoxyCodeLine{2211 \textcolor{preprocessor}{      template <typename function\_type, typename return\_type,                  \(\backslash\)}}
\DoxyCodeLine{2212 \textcolor{preprocessor}{                typename args\_type, GMOCK\_ACTION\_TEMPLATE\_ARGS\_NAMES\_>         \(\backslash\)}}
\DoxyCodeLine{2213 \textcolor{preprocessor}{      return\_type gmock\_PerformImpl(GMOCK\_ACTION\_ARG\_TYPES\_AND\_NAMES\_) const;  \(\backslash\)}}
\DoxyCodeLine{2214 \textcolor{preprocessor}{      GMOCK\_ACTION\_FIELD\_PARAMS\_(params)                                       \(\backslash\)}}
\DoxyCodeLine{2215 \textcolor{preprocessor}{    \};                                                                         \(\backslash\)}}
\DoxyCodeLine{2216 \textcolor{preprocessor}{    std::shared\_ptr<const gmock\_Impl> impl\_;                                   \(\backslash\)}}
\DoxyCodeLine{2217 \textcolor{preprocessor}{  \};                                                                           \(\backslash\)}}
\DoxyCodeLine{2218 \textcolor{preprocessor}{  template <GMOCK\_ACTION\_TYPENAME\_PARAMS\_(params)>                             \(\backslash\)}}
\DoxyCodeLine{2219 \textcolor{preprocessor}{  inline full\_name<GMOCK\_ACTION\_TYPE\_PARAMS\_(params)> name(                    \(\backslash\)}}
\DoxyCodeLine{2220 \textcolor{preprocessor}{      GMOCK\_ACTION\_TYPE\_GVALUE\_PARAMS\_(params)) GTEST\_MUST\_USE\_RESULT\_;        \(\backslash\)}}
\DoxyCodeLine{2221 \textcolor{preprocessor}{  template <GMOCK\_ACTION\_TYPENAME\_PARAMS\_(params)>                             \(\backslash\)}}
\DoxyCodeLine{2222 \textcolor{preprocessor}{  inline full\_name<GMOCK\_ACTION\_TYPE\_PARAMS\_(params)> name(                    \(\backslash\)}}
\DoxyCodeLine{2223 \textcolor{preprocessor}{      GMOCK\_ACTION\_TYPE\_GVALUE\_PARAMS\_(params)) \{                              \(\backslash\)}}
\DoxyCodeLine{2224 \textcolor{preprocessor}{    return full\_name<GMOCK\_ACTION\_TYPE\_PARAMS\_(params)>(                       \(\backslash\)}}
\DoxyCodeLine{2225 \textcolor{preprocessor}{        GMOCK\_ACTION\_GVALUE\_PARAMS\_(params));                                  \(\backslash\)}}
\DoxyCodeLine{2226 \textcolor{preprocessor}{  \}                                                                            \(\backslash\)}}
\DoxyCodeLine{2227 \textcolor{preprocessor}{  template <GMOCK\_ACTION\_TYPENAME\_PARAMS\_(params)>                             \(\backslash\)}}
\DoxyCodeLine{2228 \textcolor{preprocessor}{  template <typename function\_type, typename return\_type, typename args\_type,  \(\backslash\)}}
\DoxyCodeLine{2229 \textcolor{preprocessor}{            GMOCK\_ACTION\_TEMPLATE\_ARGS\_NAMES\_>                                 \(\backslash\)}}
\DoxyCodeLine{2230 \textcolor{preprocessor}{  return\_type                                                                  \(\backslash\)}}
\DoxyCodeLine{2231 \textcolor{preprocessor}{  full\_name<GMOCK\_ACTION\_TYPE\_PARAMS\_(params)>::gmock\_Impl::gmock\_PerformImpl( \(\backslash\)}}
\DoxyCodeLine{2232 \textcolor{preprocessor}{      GMOCK\_ACTION\_ARG\_TYPES\_AND\_NAMES\_UNUSED\_) const}}
\DoxyCodeLine{2233 }
\DoxyCodeLine{2234 \}  \textcolor{comment}{// namespace internal}}
\DoxyCodeLine{2235 }
\DoxyCodeLine{2236 \textcolor{comment}{// Similar to GMOCK\_INTERNAL\_ACTION, but no bound parameters are stored.}}
\DoxyCodeLine{2237 \textcolor{preprocessor}{\#define ACTION(name)                                                          \(\backslash\)}}
\DoxyCodeLine{2238 \textcolor{preprocessor}{  class name\#\#Action \{                                                        \(\backslash\)}}
\DoxyCodeLine{2239 \textcolor{preprocessor}{   public:                                                                    \(\backslash\)}}
\DoxyCodeLine{2240 \textcolor{preprocessor}{    explicit name\#\#Action() noexcept \{\}                                       \(\backslash\)}}
\DoxyCodeLine{2241 \textcolor{preprocessor}{    name\#\#Action(const name\#\#Action\&) noexcept \{\}                             \(\backslash\)}}
\DoxyCodeLine{2242 \textcolor{preprocessor}{    template <typename F>                                                     \(\backslash\)}}
\DoxyCodeLine{2243 \textcolor{preprocessor}{    operator ::testing::Action<F>() const \{                                   \(\backslash\)}}
\DoxyCodeLine{2244 \textcolor{preprocessor}{      return ::testing::internal::MakeAction<F, gmock\_Impl>();                \(\backslash\)}}
\DoxyCodeLine{2245 \textcolor{preprocessor}{    \}                                                                         \(\backslash\)}}
\DoxyCodeLine{2246 \textcolor{preprocessor}{                                                                              \(\backslash\)}}
\DoxyCodeLine{2247 \textcolor{preprocessor}{   private:                                                                   \(\backslash\)}}
\DoxyCodeLine{2248 \textcolor{preprocessor}{    class gmock\_Impl \{                                                        \(\backslash\)}}
\DoxyCodeLine{2249 \textcolor{preprocessor}{     public:                                                                  \(\backslash\)}}
\DoxyCodeLine{2250 \textcolor{preprocessor}{      template <typename function\_type, typename return\_type,                 \(\backslash\)}}
\DoxyCodeLine{2251 \textcolor{preprocessor}{                typename args\_type, GMOCK\_ACTION\_TEMPLATE\_ARGS\_NAMES\_>        \(\backslash\)}}
\DoxyCodeLine{2252 \textcolor{preprocessor}{      return\_type gmock\_PerformImpl(GMOCK\_ACTION\_ARG\_TYPES\_AND\_NAMES\_) const; \(\backslash\)}}
\DoxyCodeLine{2253 \textcolor{preprocessor}{    \};                                                                        \(\backslash\)}}
\DoxyCodeLine{2254 \textcolor{preprocessor}{  \};                                                                          \(\backslash\)}}
\DoxyCodeLine{2255 \textcolor{preprocessor}{  inline name\#\#Action name() GTEST\_MUST\_USE\_RESULT\_;                          \(\backslash\)}}
\DoxyCodeLine{2256 \textcolor{preprocessor}{  inline name\#\#Action name() \{ return name\#\#Action(); \}                       \(\backslash\)}}
\DoxyCodeLine{2257 \textcolor{preprocessor}{  template <typename function\_type, typename return\_type, typename args\_type, \(\backslash\)}}
\DoxyCodeLine{2258 \textcolor{preprocessor}{            GMOCK\_ACTION\_TEMPLATE\_ARGS\_NAMES\_>                                \(\backslash\)}}
\DoxyCodeLine{2259 \textcolor{preprocessor}{  return\_type name\#\#Action::gmock\_Impl::gmock\_PerformImpl(                    \(\backslash\)}}
\DoxyCodeLine{2260 \textcolor{preprocessor}{      GMOCK\_ACTION\_ARG\_TYPES\_AND\_NAMES\_UNUSED\_) const}}
\DoxyCodeLine{2261 }
\DoxyCodeLine{2262 \textcolor{preprocessor}{\#define ACTION\_P(name, ...) \(\backslash\)}}
\DoxyCodeLine{2263 \textcolor{preprocessor}{  GMOCK\_INTERNAL\_ACTION(name, name\#\#ActionP, (\_\_VA\_ARGS\_\_))}}
\DoxyCodeLine{2264 }
\DoxyCodeLine{2265 \textcolor{preprocessor}{\#define ACTION\_P2(name, ...) \(\backslash\)}}
\DoxyCodeLine{2266 \textcolor{preprocessor}{  GMOCK\_INTERNAL\_ACTION(name, name\#\#ActionP2, (\_\_VA\_ARGS\_\_))}}
\DoxyCodeLine{2267 }
\DoxyCodeLine{2268 \textcolor{preprocessor}{\#define ACTION\_P3(name, ...) \(\backslash\)}}
\DoxyCodeLine{2269 \textcolor{preprocessor}{  GMOCK\_INTERNAL\_ACTION(name, name\#\#ActionP3, (\_\_VA\_ARGS\_\_))}}
\DoxyCodeLine{2270 }
\DoxyCodeLine{2271 \textcolor{preprocessor}{\#define ACTION\_P4(name, ...) \(\backslash\)}}
\DoxyCodeLine{2272 \textcolor{preprocessor}{  GMOCK\_INTERNAL\_ACTION(name, name\#\#ActionP4, (\_\_VA\_ARGS\_\_))}}
\DoxyCodeLine{2273 }
\DoxyCodeLine{2274 \textcolor{preprocessor}{\#define ACTION\_P5(name, ...) \(\backslash\)}}
\DoxyCodeLine{2275 \textcolor{preprocessor}{  GMOCK\_INTERNAL\_ACTION(name, name\#\#ActionP5, (\_\_VA\_ARGS\_\_))}}
\DoxyCodeLine{2276 }
\DoxyCodeLine{2277 \textcolor{preprocessor}{\#define ACTION\_P6(name, ...) \(\backslash\)}}
\DoxyCodeLine{2278 \textcolor{preprocessor}{  GMOCK\_INTERNAL\_ACTION(name, name\#\#ActionP6, (\_\_VA\_ARGS\_\_))}}
\DoxyCodeLine{2279 }
\DoxyCodeLine{2280 \textcolor{preprocessor}{\#define ACTION\_P7(name, ...) \(\backslash\)}}
\DoxyCodeLine{2281 \textcolor{preprocessor}{  GMOCK\_INTERNAL\_ACTION(name, name\#\#ActionP7, (\_\_VA\_ARGS\_\_))}}
\DoxyCodeLine{2282 }
\DoxyCodeLine{2283 \textcolor{preprocessor}{\#define ACTION\_P8(name, ...) \(\backslash\)}}
\DoxyCodeLine{2284 \textcolor{preprocessor}{  GMOCK\_INTERNAL\_ACTION(name, name\#\#ActionP8, (\_\_VA\_ARGS\_\_))}}
\DoxyCodeLine{2285 }
\DoxyCodeLine{2286 \textcolor{preprocessor}{\#define ACTION\_P9(name, ...) \(\backslash\)}}
\DoxyCodeLine{2287 \textcolor{preprocessor}{  GMOCK\_INTERNAL\_ACTION(name, name\#\#ActionP9, (\_\_VA\_ARGS\_\_))}}
\DoxyCodeLine{2288 }
\DoxyCodeLine{2289 \textcolor{preprocessor}{\#define ACTION\_P10(name, ...) \(\backslash\)}}
\DoxyCodeLine{2290 \textcolor{preprocessor}{  GMOCK\_INTERNAL\_ACTION(name, name\#\#ActionP10, (\_\_VA\_ARGS\_\_))}}
\DoxyCodeLine{2291 }
\DoxyCodeLine{2292 \}  \textcolor{comment}{// namespace testing}}
\DoxyCodeLine{2293 }
\DoxyCodeLine{2294 \textcolor{preprocessor}{\#ifdef \_MSC\_VER}}
\DoxyCodeLine{2295 \textcolor{preprocessor}{\#pragma warning(pop)}}
\DoxyCodeLine{2296 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{2297 }
\DoxyCodeLine{2298 \textcolor{preprocessor}{\#endif  }\textcolor{comment}{// GOOGLEMOCK\_INCLUDE\_GMOCK\_GMOCK\_ACTIONS\_H\_}}

\end{DoxyCode}
