\hypertarget{gtest-internal_8h_source}{}\doxysection{gtest-\/internal.h}
\label{gtest-internal_8h_source}\index{build/\_deps/googletest-\/src/googletest/include/gtest/internal/gtest-\/internal.h@{build/\_deps/googletest-\/src/googletest/include/gtest/internal/gtest-\/internal.h}}

\begin{DoxyCode}{0}
\DoxyCodeLine{1 \textcolor{comment}{// Copyright 2005, Google Inc.}}
\DoxyCodeLine{2 \textcolor{comment}{// All rights reserved.}}
\DoxyCodeLine{3 \textcolor{comment}{//}}
\DoxyCodeLine{4 \textcolor{comment}{// Redistribution and use in source and binary forms, with or without}}
\DoxyCodeLine{5 \textcolor{comment}{// modification, are permitted provided that the following conditions are}}
\DoxyCodeLine{6 \textcolor{comment}{// met:}}
\DoxyCodeLine{7 \textcolor{comment}{//}}
\DoxyCodeLine{8 \textcolor{comment}{//     * Redistributions of source code must retain the above copyright}}
\DoxyCodeLine{9 \textcolor{comment}{// notice, this list of conditions and the following disclaimer.}}
\DoxyCodeLine{10 \textcolor{comment}{//     * Redistributions in binary form must reproduce the above}}
\DoxyCodeLine{11 \textcolor{comment}{// copyright notice, this list of conditions and the following disclaimer}}
\DoxyCodeLine{12 \textcolor{comment}{// in the documentation and/or other materials provided with the}}
\DoxyCodeLine{13 \textcolor{comment}{// distribution.}}
\DoxyCodeLine{14 \textcolor{comment}{//     * Neither the name of Google Inc. nor the names of its}}
\DoxyCodeLine{15 \textcolor{comment}{// contributors may be used to endorse or promote products derived from}}
\DoxyCodeLine{16 \textcolor{comment}{// this software without specific prior written permission.}}
\DoxyCodeLine{17 \textcolor{comment}{//}}
\DoxyCodeLine{18 \textcolor{comment}{// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS}}
\DoxyCodeLine{19 \textcolor{comment}{// "{}AS IS"{} AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT}}
\DoxyCodeLine{20 \textcolor{comment}{// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR}}
\DoxyCodeLine{21 \textcolor{comment}{// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT}}
\DoxyCodeLine{22 \textcolor{comment}{// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,}}
\DoxyCodeLine{23 \textcolor{comment}{// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT}}
\DoxyCodeLine{24 \textcolor{comment}{// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,}}
\DoxyCodeLine{25 \textcolor{comment}{// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY}}
\DoxyCodeLine{26 \textcolor{comment}{// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT}}
\DoxyCodeLine{27 \textcolor{comment}{// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE}}
\DoxyCodeLine{28 \textcolor{comment}{// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.}}
\DoxyCodeLine{29 }
\DoxyCodeLine{30 \textcolor{comment}{// The Google C++ Testing and Mocking Framework (Google Test)}}
\DoxyCodeLine{31 \textcolor{comment}{//}}
\DoxyCodeLine{32 \textcolor{comment}{// This header file declares functions and macros used internally by}}
\DoxyCodeLine{33 \textcolor{comment}{// Google Test.  They are subject to change without notice.}}
\DoxyCodeLine{34 }
\DoxyCodeLine{35 \textcolor{comment}{// IWYU pragma: private, include "{}gtest/gtest.h"{}}}
\DoxyCodeLine{36 \textcolor{comment}{// IWYU pragma: friend gtest/.*}}
\DoxyCodeLine{37 \textcolor{comment}{// IWYU pragma: friend gmock/.*}}
\DoxyCodeLine{38 }
\DoxyCodeLine{39 \textcolor{preprocessor}{\#ifndef GOOGLETEST\_INCLUDE\_GTEST\_INTERNAL\_GTEST\_INTERNAL\_H\_}}
\DoxyCodeLine{40 \textcolor{preprocessor}{\#define GOOGLETEST\_INCLUDE\_GTEST\_INTERNAL\_GTEST\_INTERNAL\_H\_}}
\DoxyCodeLine{41 }
\DoxyCodeLine{42 \textcolor{preprocessor}{\#include "{}gtest/internal/gtest-\/port.h"{}}}
\DoxyCodeLine{43 }
\DoxyCodeLine{44 \textcolor{preprocessor}{\#if GTEST\_OS\_LINUX}}
\DoxyCodeLine{45 \textcolor{preprocessor}{\#include <stdlib.h>}}
\DoxyCodeLine{46 \textcolor{preprocessor}{\#include <sys/types.h>}}
\DoxyCodeLine{47 \textcolor{preprocessor}{\#include <sys/wait.h>}}
\DoxyCodeLine{48 \textcolor{preprocessor}{\#include <unistd.h>}}
\DoxyCodeLine{49 \textcolor{preprocessor}{\#endif  }\textcolor{comment}{// GTEST\_OS\_LINUX}}
\DoxyCodeLine{50 }
\DoxyCodeLine{51 \textcolor{preprocessor}{\#if GTEST\_HAS\_EXCEPTIONS}}
\DoxyCodeLine{52 \textcolor{preprocessor}{\#include <stdexcept>}}
\DoxyCodeLine{53 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{54 }
\DoxyCodeLine{55 \textcolor{preprocessor}{\#include <ctype.h>}}
\DoxyCodeLine{56 \textcolor{preprocessor}{\#include <float.h>}}
\DoxyCodeLine{57 \textcolor{preprocessor}{\#include <string.h>}}
\DoxyCodeLine{58 }
\DoxyCodeLine{59 \textcolor{preprocessor}{\#include <cstdint>}}
\DoxyCodeLine{60 \textcolor{preprocessor}{\#include <iomanip>}}
\DoxyCodeLine{61 \textcolor{preprocessor}{\#include <limits>}}
\DoxyCodeLine{62 \textcolor{preprocessor}{\#include <map>}}
\DoxyCodeLine{63 \textcolor{preprocessor}{\#include <set>}}
\DoxyCodeLine{64 \textcolor{preprocessor}{\#include <string>}}
\DoxyCodeLine{65 \textcolor{preprocessor}{\#include <type\_traits>}}
\DoxyCodeLine{66 \textcolor{preprocessor}{\#include <vector>}}
\DoxyCodeLine{67 }
\DoxyCodeLine{68 \textcolor{preprocessor}{\#include "{}gtest/gtest-\/message.h"{}}}
\DoxyCodeLine{69 \textcolor{preprocessor}{\#include "{}gtest/internal/gtest-\/filepath.h"{}}}
\DoxyCodeLine{70 \textcolor{preprocessor}{\#include "{}gtest/internal/gtest-\/string.h"{}}}
\DoxyCodeLine{71 \textcolor{preprocessor}{\#include "{}gtest/internal/gtest-\/type-\/util.h"{}}}
\DoxyCodeLine{72 }
\DoxyCodeLine{73 \textcolor{comment}{// Due to C++ preprocessor weirdness, we need double indirection to}}
\DoxyCodeLine{74 \textcolor{comment}{// concatenate two tokens when one of them is \_\_LINE\_\_.  Writing}}
\DoxyCodeLine{75 \textcolor{comment}{//}}
\DoxyCodeLine{76 \textcolor{comment}{//   foo \#\# \_\_LINE\_\_}}
\DoxyCodeLine{77 \textcolor{comment}{//}}
\DoxyCodeLine{78 \textcolor{comment}{// will result in the token foo\_\_LINE\_\_, instead of foo followed by}}
\DoxyCodeLine{79 \textcolor{comment}{// the current line number.  For more details, see}}
\DoxyCodeLine{80 \textcolor{comment}{// http://www.parashift.com/c++-\/faq-\/lite/misc-\/technical-\/issues.html\#faq-\/39.6}}
\DoxyCodeLine{81 \textcolor{preprocessor}{\#define GTEST\_CONCAT\_TOKEN\_(foo, bar) GTEST\_CONCAT\_TOKEN\_IMPL\_(foo, bar)}}
\DoxyCodeLine{82 \textcolor{preprocessor}{\#define GTEST\_CONCAT\_TOKEN\_IMPL\_(foo, bar) foo\#\#bar}}
\DoxyCodeLine{83 }
\DoxyCodeLine{84 \textcolor{comment}{// Stringifies its argument.}}
\DoxyCodeLine{85 \textcolor{comment}{// Work around a bug in visual studio which doesn't accept code like this:}}
\DoxyCodeLine{86 \textcolor{comment}{//}}
\DoxyCodeLine{87 \textcolor{comment}{//   \#define GTEST\_STRINGIFY\_(name) \#name}}
\DoxyCodeLine{88 \textcolor{comment}{//   \#define MACRO(a, b, c) ... GTEST\_STRINGIFY\_(a) ...}}
\DoxyCodeLine{89 \textcolor{comment}{//   MACRO(, x, y)}}
\DoxyCodeLine{90 \textcolor{comment}{//}}
\DoxyCodeLine{91 \textcolor{comment}{// Complaining about the argument to GTEST\_STRINGIFY\_ being empty.}}
\DoxyCodeLine{92 \textcolor{comment}{// This is allowed by the spec.}}
\DoxyCodeLine{93 \textcolor{preprocessor}{\#define GTEST\_STRINGIFY\_HELPER\_(name, ...) \#name}}
\DoxyCodeLine{94 \textcolor{preprocessor}{\#define GTEST\_STRINGIFY\_(...) GTEST\_STRINGIFY\_HELPER\_(\_\_VA\_ARGS\_\_, )}}
\DoxyCodeLine{95 }
\DoxyCodeLine{96 \textcolor{keyword}{namespace }proto2 \{}
\DoxyCodeLine{97 \textcolor{keyword}{class }MessageLite;}
\DoxyCodeLine{98 \}}
\DoxyCodeLine{99 }
\DoxyCodeLine{100 \textcolor{keyword}{namespace }testing \{}
\DoxyCodeLine{101 }
\DoxyCodeLine{102 \textcolor{comment}{// Forward declarations.}}
\DoxyCodeLine{103 }
\DoxyCodeLine{104 \textcolor{keyword}{class }AssertionResult;  \textcolor{comment}{// Result of an assertion.}}
\DoxyCodeLine{105 \textcolor{keyword}{class }Message;          \textcolor{comment}{// Represents a failure message.}}
\DoxyCodeLine{106 \textcolor{keyword}{class }Test;             \textcolor{comment}{// Represents a test.}}
\DoxyCodeLine{107 \textcolor{keyword}{class }TestInfo;         \textcolor{comment}{// Information about a test.}}
\DoxyCodeLine{108 \textcolor{keyword}{class }TestPartResult;   \textcolor{comment}{// Result of a test part.}}
\DoxyCodeLine{109 \textcolor{keyword}{class }UnitTest;         \textcolor{comment}{// A collection of test suites.}}
\DoxyCodeLine{110 }
\DoxyCodeLine{111 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{112 ::std::string PrintToString(\textcolor{keyword}{const} T\& value);}
\DoxyCodeLine{113 }
\DoxyCodeLine{114 \textcolor{keyword}{namespace }internal \{}
\DoxyCodeLine{115 }
\DoxyCodeLine{116 \textcolor{keyword}{struct }TraceInfo;    \textcolor{comment}{// Information about a trace point.}}
\DoxyCodeLine{117 \textcolor{keyword}{class }TestInfoImpl;  \textcolor{comment}{// Opaque implementation of TestInfo}}
\DoxyCodeLine{118 \textcolor{keyword}{class }UnitTestImpl;  \textcolor{comment}{// Opaque implementation of UnitTest}}
\DoxyCodeLine{119 }
\DoxyCodeLine{120 \textcolor{comment}{// The text used in failure messages to indicate the start of the}}
\DoxyCodeLine{121 \textcolor{comment}{// stack trace.}}
\DoxyCodeLine{122 GTEST\_API\_ \textcolor{keyword}{extern} \textcolor{keyword}{const} \textcolor{keywordtype}{char} kStackTraceMarker[];}
\DoxyCodeLine{123 }
\DoxyCodeLine{124 \textcolor{comment}{// An IgnoredValue object can be implicitly constructed from ANY value.}}
\DoxyCodeLine{125 \textcolor{keyword}{class }\mbox{\hyperlink{classtesting_1_1internal_1_1IgnoredValue}{IgnoredValue}} \{}
\DoxyCodeLine{126   \textcolor{keyword}{struct }Sink \{\};}
\DoxyCodeLine{127 }
\DoxyCodeLine{128  \textcolor{keyword}{public}:}
\DoxyCodeLine{129   \textcolor{comment}{// This constructor template allows any value to be implicitly}}
\DoxyCodeLine{130   \textcolor{comment}{// converted to IgnoredValue.  The object has no data member and}}
\DoxyCodeLine{131   \textcolor{comment}{// doesn't try to remember anything about the argument.  We}}
\DoxyCodeLine{132   \textcolor{comment}{// deliberately omit the 'explicit' keyword in order to allow the}}
\DoxyCodeLine{133   \textcolor{comment}{// conversion to be implicit.}}
\DoxyCodeLine{134   \textcolor{comment}{// Disable the conversion if T already has a magical conversion operator.}}
\DoxyCodeLine{135   \textcolor{comment}{// Otherwise we get ambiguity.}}
\DoxyCodeLine{136   \textcolor{keyword}{template} <\textcolor{keyword}{typename} T,}
\DoxyCodeLine{137             \textcolor{keyword}{typename} std::enable\_if<!std::is\_convertible<T, Sink>::value,}
\DoxyCodeLine{138                                     \textcolor{keywordtype}{int}>::type = 0>}
\DoxyCodeLine{139   \mbox{\hyperlink{classtesting_1_1internal_1_1IgnoredValue}{IgnoredValue}}(\textcolor{keyword}{const} T\& \textcolor{comment}{/* ignored */}) \{\}  \textcolor{comment}{// NOLINT(runtime/explicit)}}
\DoxyCodeLine{140 \};}
\DoxyCodeLine{141 }
\DoxyCodeLine{142 \textcolor{comment}{// Appends the user-\/supplied message to the Google-\/Test-\/generated message.}}
\DoxyCodeLine{143 GTEST\_API\_ std::string AppendUserMessage(\textcolor{keyword}{const} std::string\& gtest\_msg,}
\DoxyCodeLine{144                                          \textcolor{keyword}{const} \mbox{\hyperlink{classtesting_1_1Message}{Message}}\& user\_msg);}
\DoxyCodeLine{145 }
\DoxyCodeLine{146 \textcolor{preprocessor}{\#if GTEST\_HAS\_EXCEPTIONS}}
\DoxyCodeLine{147 }
\DoxyCodeLine{148 GTEST\_DISABLE\_MSC\_WARNINGS\_PUSH\_(}
\DoxyCodeLine{149     4275 \textcolor{comment}{/* an exported class was derived from a class that was not exported */})}
\DoxyCodeLine{150 }
\DoxyCodeLine{151 \textcolor{comment}{// This exception is thrown by (and only by) a failed Google Test}}
\DoxyCodeLine{152 \textcolor{comment}{// assertion when GTEST\_FLAG(throw\_on\_failure) is true (if exceptions}}
\DoxyCodeLine{153 \textcolor{comment}{// are enabled).  We derive it from std::runtime\_error, which is for}}
\DoxyCodeLine{154 \textcolor{comment}{// errors presumably detectable only at run time.  Since}}
\DoxyCodeLine{155 \textcolor{comment}{// std::runtime\_error inherits from std::exception, many testing}}
\DoxyCodeLine{156 \textcolor{comment}{// frameworks know how to extract and print the message inside it.}}
\DoxyCodeLine{157 class GTEST\_API\_ GoogleTestFailureException : public ::std::runtime\_error \{}
\DoxyCodeLine{158  \textcolor{keyword}{public}:}
\DoxyCodeLine{159   \textcolor{keyword}{explicit} GoogleTestFailureException(\textcolor{keyword}{const} TestPartResult\& failure);}
\DoxyCodeLine{160 \};}
\DoxyCodeLine{161 }
\DoxyCodeLine{162 GTEST\_DISABLE\_MSC\_WARNINGS\_POP\_()  \textcolor{comment}{//  4275}}
\DoxyCodeLine{163 }
\DoxyCodeLine{164 \textcolor{preprocessor}{\#endif  }\textcolor{comment}{// GTEST\_HAS\_EXCEPTIONS}}
\DoxyCodeLine{165 }
\DoxyCodeLine{166 \textcolor{keyword}{namespace }edit\_distance \{}
\DoxyCodeLine{167 \textcolor{comment}{// Returns the optimal edits to go from 'left' to 'right'.}}
\DoxyCodeLine{168 \textcolor{comment}{// All edits cost the same, with replace having lower priority than}}
\DoxyCodeLine{169 \textcolor{comment}{// add/remove.}}
\DoxyCodeLine{170 \textcolor{comment}{// Simple implementation of the Wagner-\/Fischer algorithm.}}
\DoxyCodeLine{171 \textcolor{comment}{// See http://en.wikipedia.org/wiki/Wagner-\/Fischer\_algorithm}}
\DoxyCodeLine{172 \textcolor{keyword}{enum} EditType \{ kMatch, kAdd, kRemove, kReplace \};}
\DoxyCodeLine{173 GTEST\_API\_ std::vector<EditType> CalculateOptimalEdits(}
\DoxyCodeLine{174     \textcolor{keyword}{const} std::vector<size\_t>\& left, \textcolor{keyword}{const} std::vector<size\_t>\& right);}
\DoxyCodeLine{175 }
\DoxyCodeLine{176 \textcolor{comment}{// Same as above, but the input is represented as strings.}}
\DoxyCodeLine{177 GTEST\_API\_ std::vector<EditType> CalculateOptimalEdits(}
\DoxyCodeLine{178     \textcolor{keyword}{const} std::vector<std::string>\& left,}
\DoxyCodeLine{179     \textcolor{keyword}{const} std::vector<std::string>\& right);}
\DoxyCodeLine{180 }
\DoxyCodeLine{181 \textcolor{comment}{// Create a diff of the input strings in Unified diff format.}}
\DoxyCodeLine{182 GTEST\_API\_ std::string CreateUnifiedDiff(\textcolor{keyword}{const} std::vector<std::string>\& left,}
\DoxyCodeLine{183                                          \textcolor{keyword}{const} std::vector<std::string>\& right,}
\DoxyCodeLine{184                                          \textcolor{keywordtype}{size\_t} context = 2);}
\DoxyCodeLine{185 }
\DoxyCodeLine{186 \}  \textcolor{comment}{// namespace edit\_distance}}
\DoxyCodeLine{187 }
\DoxyCodeLine{188 \textcolor{comment}{// Constructs and returns the message for an equality assertion}}
\DoxyCodeLine{189 \textcolor{comment}{// (e.g. ASSERT\_EQ, EXPECT\_STREQ, etc) failure.}}
\DoxyCodeLine{190 \textcolor{comment}{//}}
\DoxyCodeLine{191 \textcolor{comment}{// The first four parameters are the expressions used in the assertion}}
\DoxyCodeLine{192 \textcolor{comment}{// and their values, as strings.  For example, for ASSERT\_EQ(foo, bar)}}
\DoxyCodeLine{193 \textcolor{comment}{// where foo is 5 and bar is 6, we have:}}
\DoxyCodeLine{194 \textcolor{comment}{//}}
\DoxyCodeLine{195 \textcolor{comment}{//   expected\_expression: "{}foo"{}}}
\DoxyCodeLine{196 \textcolor{comment}{//   actual\_expression:   "{}bar"{}}}
\DoxyCodeLine{197 \textcolor{comment}{//   expected\_value:      "{}5"{}}}
\DoxyCodeLine{198 \textcolor{comment}{//   actual\_value:        "{}6"{}}}
\DoxyCodeLine{199 \textcolor{comment}{//}}
\DoxyCodeLine{200 \textcolor{comment}{// The ignoring\_case parameter is true if and only if the assertion is a}}
\DoxyCodeLine{201 \textcolor{comment}{// *\_STRCASEEQ*.  When it's true, the string "{} (ignoring case)"{} will}}
\DoxyCodeLine{202 \textcolor{comment}{// be inserted into the message.}}
\DoxyCodeLine{203 GTEST\_API\_ AssertionResult EqFailure(\textcolor{keyword}{const} \textcolor{keywordtype}{char}* expected\_expression,}
\DoxyCodeLine{204                                      \textcolor{keyword}{const} \textcolor{keywordtype}{char}* actual\_expression,}
\DoxyCodeLine{205                                      \textcolor{keyword}{const} std::string\& expected\_value,}
\DoxyCodeLine{206                                      \textcolor{keyword}{const} std::string\& actual\_value,}
\DoxyCodeLine{207                                      \textcolor{keywordtype}{bool} ignoring\_case);}
\DoxyCodeLine{208 }
\DoxyCodeLine{209 \textcolor{comment}{// Constructs a failure message for Boolean assertions such as EXPECT\_TRUE.}}
\DoxyCodeLine{210 GTEST\_API\_ std::string GetBoolAssertionFailureMessage(}
\DoxyCodeLine{211     \textcolor{keyword}{const} AssertionResult\& assertion\_result, \textcolor{keyword}{const} \textcolor{keywordtype}{char}* expression\_text,}
\DoxyCodeLine{212     \textcolor{keyword}{const} \textcolor{keywordtype}{char}* actual\_predicate\_value, \textcolor{keyword}{const} \textcolor{keywordtype}{char}* expected\_predicate\_value);}
\DoxyCodeLine{213 }
\DoxyCodeLine{214 \textcolor{comment}{// This template class represents an IEEE floating-\/point number}}
\DoxyCodeLine{215 \textcolor{comment}{// (either single-\/precision or double-\/precision, depending on the}}
\DoxyCodeLine{216 \textcolor{comment}{// template parameters).}}
\DoxyCodeLine{217 \textcolor{comment}{//}}
\DoxyCodeLine{218 \textcolor{comment}{// The purpose of this class is to do more sophisticated number}}
\DoxyCodeLine{219 \textcolor{comment}{// comparison.  (Due to round-\/off error, etc, it's very unlikely that}}
\DoxyCodeLine{220 \textcolor{comment}{// two floating-\/points will be equal exactly.  Hence a naive}}
\DoxyCodeLine{221 \textcolor{comment}{// comparison by the == operation often doesn't work.)}}
\DoxyCodeLine{222 \textcolor{comment}{//}}
\DoxyCodeLine{223 \textcolor{comment}{// Format of IEEE floating-\/point:}}
\DoxyCodeLine{224 \textcolor{comment}{//}}
\DoxyCodeLine{225 \textcolor{comment}{//   The most-\/significant bit being the leftmost, an IEEE}}
\DoxyCodeLine{226 \textcolor{comment}{//   floating-\/point looks like}}
\DoxyCodeLine{227 \textcolor{comment}{//}}
\DoxyCodeLine{228 \textcolor{comment}{//     sign\_bit exponent\_bits fraction\_bits}}
\DoxyCodeLine{229 \textcolor{comment}{//}}
\DoxyCodeLine{230 \textcolor{comment}{//   Here, sign\_bit is a single bit that designates the sign of the}}
\DoxyCodeLine{231 \textcolor{comment}{//   number.}}
\DoxyCodeLine{232 \textcolor{comment}{//}}
\DoxyCodeLine{233 \textcolor{comment}{//   For float, there are 8 exponent bits and 23 fraction bits.}}
\DoxyCodeLine{234 \textcolor{comment}{//}}
\DoxyCodeLine{235 \textcolor{comment}{//   For double, there are 11 exponent bits and 52 fraction bits.}}
\DoxyCodeLine{236 \textcolor{comment}{//}}
\DoxyCodeLine{237 \textcolor{comment}{//   More details can be found at}}
\DoxyCodeLine{238 \textcolor{comment}{//   http://en.wikipedia.org/wiki/IEEE\_floating-\/point\_standard.}}
\DoxyCodeLine{239 \textcolor{comment}{//}}
\DoxyCodeLine{240 \textcolor{comment}{// Template parameter:}}
\DoxyCodeLine{241 \textcolor{comment}{//}}
\DoxyCodeLine{242 \textcolor{comment}{//   RawType: the raw floating-\/point type (either float or double)}}
\DoxyCodeLine{243 \textcolor{keyword}{template} <\textcolor{keyword}{typename} RawType>}
\DoxyCodeLine{244 \textcolor{keyword}{class }\mbox{\hyperlink{classtesting_1_1internal_1_1FloatingPoint}{FloatingPoint}} \{}
\DoxyCodeLine{245  \textcolor{keyword}{public}:}
\DoxyCodeLine{246   \textcolor{comment}{// Defines the unsigned integer type that has the same size as the}}
\DoxyCodeLine{247   \textcolor{comment}{// floating point number.}}
\DoxyCodeLine{248   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \mbox{\hyperlink{classtesting_1_1internal_1_1TypeWithSize}{TypeWithSize}}<\textcolor{keyword}{sizeof}(RawType)>::UInt Bits;}
\DoxyCodeLine{249 }
\DoxyCodeLine{250   \textcolor{comment}{// Constants.}}
\DoxyCodeLine{251 }
\DoxyCodeLine{252   \textcolor{comment}{// \# of bits in a number.}}
\DoxyCodeLine{253   \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{size\_t} kBitCount = 8 * \textcolor{keyword}{sizeof}(RawType);}
\DoxyCodeLine{254 }
\DoxyCodeLine{255   \textcolor{comment}{// \# of fraction bits in a number.}}
\DoxyCodeLine{256   \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{size\_t} kFractionBitCount =}
\DoxyCodeLine{257       std::numeric\_limits<RawType>::digits -\/ 1;}
\DoxyCodeLine{258 }
\DoxyCodeLine{259   \textcolor{comment}{// \# of exponent bits in a number.}}
\DoxyCodeLine{260   \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{size\_t} kExponentBitCount = kBitCount -\/ 1 -\/ kFractionBitCount;}
\DoxyCodeLine{261 }
\DoxyCodeLine{262   \textcolor{comment}{// The mask for the sign bit.}}
\DoxyCodeLine{263   \textcolor{keyword}{static} \textcolor{keyword}{const} Bits kSignBitMask = \textcolor{keyword}{static\_cast<}Bits\textcolor{keyword}{>}(1) << (kBitCount -\/ 1);}
\DoxyCodeLine{264 }
\DoxyCodeLine{265   \textcolor{comment}{// The mask for the fraction bits.}}
\DoxyCodeLine{266   \textcolor{keyword}{static} \textcolor{keyword}{const} Bits kFractionBitMask = \string~static\_cast<Bits>(0) >>}
\DoxyCodeLine{267                                        (kExponentBitCount + 1);}
\DoxyCodeLine{268 }
\DoxyCodeLine{269   \textcolor{comment}{// The mask for the exponent bits.}}
\DoxyCodeLine{270   \textcolor{keyword}{static} \textcolor{keyword}{const} Bits kExponentBitMask = \string~(kSignBitMask | kFractionBitMask);}
\DoxyCodeLine{271 }
\DoxyCodeLine{272   \textcolor{comment}{// How many ULP's (Units in the Last Place) we want to tolerate when}}
\DoxyCodeLine{273   \textcolor{comment}{// comparing two numbers.  The larger the value, the more error we}}
\DoxyCodeLine{274   \textcolor{comment}{// allow.  A 0 value means that two numbers must be exactly the same}}
\DoxyCodeLine{275   \textcolor{comment}{// to be considered equal.}}
\DoxyCodeLine{276   \textcolor{comment}{//}}
\DoxyCodeLine{277   \textcolor{comment}{// The maximum error of a single floating-\/point operation is 0.5}}
\DoxyCodeLine{278   \textcolor{comment}{// units in the last place.  On Intel CPU's, all floating-\/point}}
\DoxyCodeLine{279   \textcolor{comment}{// calculations are done with 80-\/bit precision, while double has 64}}
\DoxyCodeLine{280   \textcolor{comment}{// bits.  Therefore, 4 should be enough for ordinary use.}}
\DoxyCodeLine{281   \textcolor{comment}{//}}
\DoxyCodeLine{282   \textcolor{comment}{// See the following article for more details on ULP:}}
\DoxyCodeLine{283   \textcolor{comment}{// http://randomascii.wordpress.com/2012/02/25/comparing-\/floating-\/point-\/numbers-\/2012-\/edition/}}
\DoxyCodeLine{284   \textcolor{keyword}{static} \textcolor{keyword}{const} uint32\_t kMaxUlps = 4;}
\DoxyCodeLine{285 }
\DoxyCodeLine{286   \textcolor{comment}{// Constructs a FloatingPoint from a raw floating-\/point number.}}
\DoxyCodeLine{287   \textcolor{comment}{//}}
\DoxyCodeLine{288   \textcolor{comment}{// On an Intel CPU, passing a non-\/normalized NAN (Not a Number)}}
\DoxyCodeLine{289   \textcolor{comment}{// around may change its bits, although the new value is guaranteed}}
\DoxyCodeLine{290   \textcolor{comment}{// to be also a NAN.  Therefore, don't expect this constructor to}}
\DoxyCodeLine{291   \textcolor{comment}{// preserve the bits in x when x is a NAN.}}
\DoxyCodeLine{292   \textcolor{keyword}{explicit} \mbox{\hyperlink{classtesting_1_1internal_1_1FloatingPoint}{FloatingPoint}}(\textcolor{keyword}{const} RawType\& x) \{ u\_.value\_ = x; \}}
\DoxyCodeLine{293 }
\DoxyCodeLine{294   \textcolor{comment}{// Static methods}}
\DoxyCodeLine{295 }
\DoxyCodeLine{296   \textcolor{comment}{// Reinterprets a bit pattern as a floating-\/point number.}}
\DoxyCodeLine{297   \textcolor{comment}{//}}
\DoxyCodeLine{298   \textcolor{comment}{// This function is needed to test the AlmostEquals() method.}}
\DoxyCodeLine{299   \textcolor{keyword}{static} RawType ReinterpretBits(\textcolor{keyword}{const} Bits bits) \{}
\DoxyCodeLine{300     \mbox{\hyperlink{classtesting_1_1internal_1_1FloatingPoint}{FloatingPoint}} fp(0);}
\DoxyCodeLine{301     fp.u\_.bits\_ = bits;}
\DoxyCodeLine{302     \textcolor{keywordflow}{return} fp.u\_.value\_;}
\DoxyCodeLine{303   \}}
\DoxyCodeLine{304 }
\DoxyCodeLine{305   \textcolor{comment}{// Returns the floating-\/point number that represent positive infinity.}}
\DoxyCodeLine{306   \textcolor{keyword}{static} RawType Infinity() \{ \textcolor{keywordflow}{return} ReinterpretBits(kExponentBitMask); \}}
\DoxyCodeLine{307 }
\DoxyCodeLine{308   \textcolor{comment}{// Returns the maximum representable finite floating-\/point number.}}
\DoxyCodeLine{309   \textcolor{keyword}{static} RawType Max();}
\DoxyCodeLine{310 }
\DoxyCodeLine{311   \textcolor{comment}{// Non-\/static methods}}
\DoxyCodeLine{312 }
\DoxyCodeLine{313   \textcolor{comment}{// Returns the bits that represents this number.}}
\DoxyCodeLine{314   \textcolor{keyword}{const} Bits\& bits()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} u\_.bits\_; \}}
\DoxyCodeLine{315 }
\DoxyCodeLine{316   \textcolor{comment}{// Returns the exponent bits of this number.}}
\DoxyCodeLine{317   Bits exponent\_bits()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} kExponentBitMask \& u\_.bits\_; \}}
\DoxyCodeLine{318 }
\DoxyCodeLine{319   \textcolor{comment}{// Returns the fraction bits of this number.}}
\DoxyCodeLine{320   Bits fraction\_bits()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} kFractionBitMask \& u\_.bits\_; \}}
\DoxyCodeLine{321 }
\DoxyCodeLine{322   \textcolor{comment}{// Returns the sign bit of this number.}}
\DoxyCodeLine{323   Bits sign\_bit()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} kSignBitMask \& u\_.bits\_; \}}
\DoxyCodeLine{324 }
\DoxyCodeLine{325   \textcolor{comment}{// Returns true if and only if this is NAN (not a number).}}
\DoxyCodeLine{326   \textcolor{keywordtype}{bool} is\_nan()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{327     \textcolor{comment}{// It's a NAN if the exponent bits are all ones and the fraction}}
\DoxyCodeLine{328     \textcolor{comment}{// bits are not entirely zeros.}}
\DoxyCodeLine{329     \textcolor{keywordflow}{return} (exponent\_bits() == kExponentBitMask) \&\& (fraction\_bits() != 0);}
\DoxyCodeLine{330   \}}
\DoxyCodeLine{331 }
\DoxyCodeLine{332   \textcolor{comment}{// Returns true if and only if this number is at most kMaxUlps ULP's away}}
\DoxyCodeLine{333   \textcolor{comment}{// from rhs.  In particular, this function:}}
\DoxyCodeLine{334   \textcolor{comment}{//}}
\DoxyCodeLine{335   \textcolor{comment}{//   -\/ returns false if either number is (or both are) NAN.}}
\DoxyCodeLine{336   \textcolor{comment}{//   -\/ treats really large numbers as almost equal to infinity.}}
\DoxyCodeLine{337   \textcolor{comment}{//   -\/ thinks +0.0 and -\/0.0 are 0 DLP's apart.}}
\DoxyCodeLine{338   \textcolor{keywordtype}{bool} AlmostEquals(\textcolor{keyword}{const} \mbox{\hyperlink{classtesting_1_1internal_1_1FloatingPoint}{FloatingPoint}}\& rhs)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{339     \textcolor{comment}{// The IEEE standard says that any comparison operation involving}}
\DoxyCodeLine{340     \textcolor{comment}{// a NAN must return false.}}
\DoxyCodeLine{341     \textcolor{keywordflow}{if} (is\_nan() || rhs.is\_nan()) \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{342 }
\DoxyCodeLine{343     \textcolor{keywordflow}{return} DistanceBetweenSignAndMagnitudeNumbers(u\_.bits\_, rhs.u\_.bits\_) <=}
\DoxyCodeLine{344            kMaxUlps;}
\DoxyCodeLine{345   \}}
\DoxyCodeLine{346 }
\DoxyCodeLine{347  \textcolor{keyword}{private}:}
\DoxyCodeLine{348   \textcolor{comment}{// The data type used to store the actual floating-\/point number.}}
\DoxyCodeLine{349   \textcolor{keyword}{union }FloatingPointUnion \{}
\DoxyCodeLine{350     RawType value\_;  \textcolor{comment}{// The raw floating-\/point number.}}
\DoxyCodeLine{351     Bits bits\_;      \textcolor{comment}{// The bits that represent the number.}}
\DoxyCodeLine{352   \};}
\DoxyCodeLine{353 }
\DoxyCodeLine{354   \textcolor{comment}{// Converts an integer from the sign-\/and-\/magnitude representation to}}
\DoxyCodeLine{355   \textcolor{comment}{// the biased representation.  More precisely, let N be 2 to the}}
\DoxyCodeLine{356   \textcolor{comment}{// power of (kBitCount -\/ 1), an integer x is represented by the}}
\DoxyCodeLine{357   \textcolor{comment}{// unsigned number x + N.}}
\DoxyCodeLine{358   \textcolor{comment}{//}}
\DoxyCodeLine{359   \textcolor{comment}{// For instance,}}
\DoxyCodeLine{360   \textcolor{comment}{//}}
\DoxyCodeLine{361   \textcolor{comment}{//   -\/N + 1 (the most negative number representable using}}
\DoxyCodeLine{362   \textcolor{comment}{//          sign-\/and-\/magnitude) is represented by 1;}}
\DoxyCodeLine{363   \textcolor{comment}{//   0      is represented by N; and}}
\DoxyCodeLine{364   \textcolor{comment}{//   N -\/ 1  (the biggest number representable using}}
\DoxyCodeLine{365   \textcolor{comment}{//          sign-\/and-\/magnitude) is represented by 2N -\/ 1.}}
\DoxyCodeLine{366   \textcolor{comment}{//}}
\DoxyCodeLine{367   \textcolor{comment}{// Read http://en.wikipedia.org/wiki/Signed\_number\_representations}}
\DoxyCodeLine{368   \textcolor{comment}{// for more details on signed number representations.}}
\DoxyCodeLine{369   \textcolor{keyword}{static} Bits SignAndMagnitudeToBiased(\textcolor{keyword}{const} Bits\& sam) \{}
\DoxyCodeLine{370     \textcolor{keywordflow}{if} (kSignBitMask \& sam) \{}
\DoxyCodeLine{371       \textcolor{comment}{// sam represents a negative number.}}
\DoxyCodeLine{372       \textcolor{keywordflow}{return} \string~sam + 1;}
\DoxyCodeLine{373     \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{374       \textcolor{comment}{// sam represents a positive number.}}
\DoxyCodeLine{375       \textcolor{keywordflow}{return} kSignBitMask | sam;}
\DoxyCodeLine{376     \}}
\DoxyCodeLine{377   \}}
\DoxyCodeLine{378 }
\DoxyCodeLine{379   \textcolor{comment}{// Given two numbers in the sign-\/and-\/magnitude representation,}}
\DoxyCodeLine{380   \textcolor{comment}{// returns the distance between them as an unsigned number.}}
\DoxyCodeLine{381   \textcolor{keyword}{static} Bits DistanceBetweenSignAndMagnitudeNumbers(\textcolor{keyword}{const} Bits\& sam1,}
\DoxyCodeLine{382                                                      \textcolor{keyword}{const} Bits\& sam2) \{}
\DoxyCodeLine{383     \textcolor{keyword}{const} Bits biased1 = SignAndMagnitudeToBiased(sam1);}
\DoxyCodeLine{384     \textcolor{keyword}{const} Bits biased2 = SignAndMagnitudeToBiased(sam2);}
\DoxyCodeLine{385     \textcolor{keywordflow}{return} (biased1 >= biased2) ? (biased1 -\/ biased2) : (biased2 -\/ biased1);}
\DoxyCodeLine{386   \}}
\DoxyCodeLine{387 }
\DoxyCodeLine{388   FloatingPointUnion u\_;}
\DoxyCodeLine{389 \};}
\DoxyCodeLine{390 }
\DoxyCodeLine{391 \textcolor{comment}{// We cannot use std::numeric\_limits<T>::max() as it clashes with the max()}}
\DoxyCodeLine{392 \textcolor{comment}{// macro defined by <windows.h>.}}
\DoxyCodeLine{393 \textcolor{keyword}{template} <>}
\DoxyCodeLine{394 \textcolor{keyword}{inline} \textcolor{keywordtype}{float} \mbox{\hyperlink{classtesting_1_1internal_1_1FloatingPoint}{FloatingPoint<float>::Max}}() \{}
\DoxyCodeLine{395   \textcolor{keywordflow}{return} FLT\_MAX;}
\DoxyCodeLine{396 \}}
\DoxyCodeLine{397 \textcolor{keyword}{template} <>}
\DoxyCodeLine{398 \textcolor{keyword}{inline} \textcolor{keywordtype}{double} FloatingPoint<double>::Max() \{}
\DoxyCodeLine{399   \textcolor{keywordflow}{return} DBL\_MAX;}
\DoxyCodeLine{400 \}}
\DoxyCodeLine{401 }
\DoxyCodeLine{402 \textcolor{comment}{// Typedefs the instances of the FloatingPoint template class that we}}
\DoxyCodeLine{403 \textcolor{comment}{// care to use.}}
\DoxyCodeLine{404 \textcolor{keyword}{typedef} FloatingPoint<float> Float;}
\DoxyCodeLine{405 \textcolor{keyword}{typedef} FloatingPoint<double> Double;}
\DoxyCodeLine{406 }
\DoxyCodeLine{407 \textcolor{comment}{// In order to catch the mistake of putting tests that use different}}
\DoxyCodeLine{408 \textcolor{comment}{// test fixture classes in the same test suite, we need to assign}}
\DoxyCodeLine{409 \textcolor{comment}{// unique IDs to fixture classes and compare them.  The TypeId type is}}
\DoxyCodeLine{410 \textcolor{comment}{// used to hold such IDs.  The user should treat TypeId as an opaque}}
\DoxyCodeLine{411 \textcolor{comment}{// type: the only operation allowed on TypeId values is to compare}}
\DoxyCodeLine{412 \textcolor{comment}{// them for equality using the == operator.}}
\DoxyCodeLine{413 \textcolor{keyword}{typedef} \textcolor{keyword}{const} \textcolor{keywordtype}{void}* TypeId;}
\DoxyCodeLine{414 }
\DoxyCodeLine{415 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{416 \textcolor{keyword}{class }\mbox{\hyperlink{classtesting_1_1internal_1_1TypeIdHelper}{TypeIdHelper}} \{}
\DoxyCodeLine{417  \textcolor{keyword}{public}:}
\DoxyCodeLine{418   \textcolor{comment}{// dummy\_ must not have a const type.  Otherwise an overly eager}}
\DoxyCodeLine{419   \textcolor{comment}{// compiler (e.g. MSVC 7.1 \& 8.0) may try to merge}}
\DoxyCodeLine{420   \textcolor{comment}{// TypeIdHelper<T>::dummy\_ for different Ts as an "{}optimization"{}.}}
\DoxyCodeLine{421   \textcolor{keyword}{static} \textcolor{keywordtype}{bool} dummy\_;}
\DoxyCodeLine{422 \};}
\DoxyCodeLine{423 }
\DoxyCodeLine{424 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{425 \textcolor{keywordtype}{bool} \mbox{\hyperlink{classtesting_1_1internal_1_1TypeIdHelper}{TypeIdHelper<T>::dummy\_}} = \textcolor{keyword}{false};}
\DoxyCodeLine{426 }
\DoxyCodeLine{427 \textcolor{comment}{// GetTypeId<T>() returns the ID of type T.  Different values will be}}
\DoxyCodeLine{428 \textcolor{comment}{// returned for different types.  Calling the function twice with the}}
\DoxyCodeLine{429 \textcolor{comment}{// same type argument is guaranteed to return the same ID.}}
\DoxyCodeLine{430 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{431 TypeId GetTypeId() \{}
\DoxyCodeLine{432   \textcolor{comment}{// The compiler is required to allocate a different}}
\DoxyCodeLine{433   \textcolor{comment}{// TypeIdHelper<T>::dummy\_ variable for each T used to instantiate}}
\DoxyCodeLine{434   \textcolor{comment}{// the template.  Therefore, the address of dummy\_ is guaranteed to}}
\DoxyCodeLine{435   \textcolor{comment}{// be unique.}}
\DoxyCodeLine{436   \textcolor{keywordflow}{return} \&(\mbox{\hyperlink{classtesting_1_1internal_1_1TypeIdHelper}{TypeIdHelper<T>::dummy\_}});}
\DoxyCodeLine{437 \}}
\DoxyCodeLine{438 }
\DoxyCodeLine{439 \textcolor{comment}{// Returns the type ID of ::testing::Test.  Always call this instead}}
\DoxyCodeLine{440 \textcolor{comment}{// of GetTypeId< ::testing::Test>() to get the type ID of}}
\DoxyCodeLine{441 \textcolor{comment}{// ::testing::Test, as the latter may give the wrong result due to a}}
\DoxyCodeLine{442 \textcolor{comment}{// suspected linker bug when compiling Google Test as a Mac OS X}}
\DoxyCodeLine{443 \textcolor{comment}{// framework.}}
\DoxyCodeLine{444 GTEST\_API\_ TypeId GetTestTypeId();}
\DoxyCodeLine{445 }
\DoxyCodeLine{446 \textcolor{comment}{// Defines the abstract factory interface that creates instances}}
\DoxyCodeLine{447 \textcolor{comment}{// of a Test object.}}
\DoxyCodeLine{448 \textcolor{keyword}{class }\mbox{\hyperlink{classtesting_1_1internal_1_1TestFactoryBase}{TestFactoryBase}} \{}
\DoxyCodeLine{449  \textcolor{keyword}{public}:}
\DoxyCodeLine{450   \textcolor{keyword}{virtual} \mbox{\hyperlink{classtesting_1_1internal_1_1TestFactoryBase}{\string~TestFactoryBase}}() \{\}}
\DoxyCodeLine{451 }
\DoxyCodeLine{452   \textcolor{comment}{// Creates a test instance to run. The instance is both created and destroyed}}
\DoxyCodeLine{453   \textcolor{comment}{// within TestInfoImpl::Run()}}
\DoxyCodeLine{454   \textcolor{keyword}{virtual} \mbox{\hyperlink{classtesting_1_1Test}{Test}}* CreateTest() = 0;}
\DoxyCodeLine{455 }
\DoxyCodeLine{456  \textcolor{keyword}{protected}:}
\DoxyCodeLine{457   \mbox{\hyperlink{classtesting_1_1internal_1_1TestFactoryBase}{TestFactoryBase}}() \{\}}
\DoxyCodeLine{458 }
\DoxyCodeLine{459  \textcolor{keyword}{private}:}
\DoxyCodeLine{460   \mbox{\hyperlink{classtesting_1_1internal_1_1TestFactoryBase}{TestFactoryBase}}(\textcolor{keyword}{const} \mbox{\hyperlink{classtesting_1_1internal_1_1TestFactoryBase}{TestFactoryBase}}\&) = \textcolor{keyword}{delete};}
\DoxyCodeLine{461   \mbox{\hyperlink{classtesting_1_1internal_1_1TestFactoryBase}{TestFactoryBase}}\& operator=(\textcolor{keyword}{const} \mbox{\hyperlink{classtesting_1_1internal_1_1TestFactoryBase}{TestFactoryBase}}\&) = \textcolor{keyword}{delete};}
\DoxyCodeLine{462 \};}
\DoxyCodeLine{463 }
\DoxyCodeLine{464 \textcolor{comment}{// This class provides implementation of TeastFactoryBase interface.}}
\DoxyCodeLine{465 \textcolor{comment}{// It is used in TEST and TEST\_F macros.}}
\DoxyCodeLine{466 \textcolor{keyword}{template} <\textcolor{keyword}{class} TestClass>}
\DoxyCodeLine{467 \textcolor{keyword}{class }\mbox{\hyperlink{classtesting_1_1internal_1_1TestFactoryImpl}{TestFactoryImpl}} : \textcolor{keyword}{public} \mbox{\hyperlink{classtesting_1_1internal_1_1TestFactoryBase}{TestFactoryBase}} \{}
\DoxyCodeLine{468  \textcolor{keyword}{public}:}
\DoxyCodeLine{469   \mbox{\hyperlink{classtesting_1_1Test}{Test}}* CreateTest()\textcolor{keyword}{ override }\{ \textcolor{keywordflow}{return} \textcolor{keyword}{new} TestClass; \}}
\DoxyCodeLine{470 \};}
\DoxyCodeLine{471 }
\DoxyCodeLine{472 \textcolor{preprocessor}{\#if GTEST\_OS\_WINDOWS}}
\DoxyCodeLine{473 }
\DoxyCodeLine{474 \textcolor{comment}{// Predicate-\/formatters for implementing the HRESULT checking macros}}
\DoxyCodeLine{475 \textcolor{comment}{// \{ASSERT|EXPECT\}\_HRESULT\_\{SUCCEEDED|FAILED\}}}
\DoxyCodeLine{476 \textcolor{comment}{// We pass a long instead of HRESULT to avoid causing an}}
\DoxyCodeLine{477 \textcolor{comment}{// include dependency for the HRESULT type.}}
\DoxyCodeLine{478 GTEST\_API\_ AssertionResult IsHRESULTSuccess(\textcolor{keyword}{const} \textcolor{keywordtype}{char}* expr,}
\DoxyCodeLine{479                                             \textcolor{keywordtype}{long} hr);  \textcolor{comment}{// NOLINT}}
\DoxyCodeLine{480 GTEST\_API\_ AssertionResult IsHRESULTFailure(\textcolor{keyword}{const} \textcolor{keywordtype}{char}* expr,}
\DoxyCodeLine{481                                             \textcolor{keywordtype}{long} hr);  \textcolor{comment}{// NOLINT}}
\DoxyCodeLine{482 }
\DoxyCodeLine{483 \textcolor{preprocessor}{\#endif  }\textcolor{comment}{// GTEST\_OS\_WINDOWS}}
\DoxyCodeLine{484 }
\DoxyCodeLine{485 \textcolor{comment}{// Types of SetUpTestSuite() and TearDownTestSuite() functions.}}
\DoxyCodeLine{486 \textcolor{keyword}{using }SetUpTestSuiteFunc = void (*)();}
\DoxyCodeLine{487 \textcolor{keyword}{using }TearDownTestSuiteFunc = void (*)();}
\DoxyCodeLine{488 }
\DoxyCodeLine{489 \textcolor{keyword}{struct }\mbox{\hyperlink{structtesting_1_1internal_1_1CodeLocation}{CodeLocation}} \{}
\DoxyCodeLine{490   \mbox{\hyperlink{structtesting_1_1internal_1_1CodeLocation}{CodeLocation}}(\textcolor{keyword}{const} std::string\& a\_file, \textcolor{keywordtype}{int} a\_line)}
\DoxyCodeLine{491       : file(a\_file), line(a\_line) \{\}}
\DoxyCodeLine{492 }
\DoxyCodeLine{493   std::string file;}
\DoxyCodeLine{494   \textcolor{keywordtype}{int} line;}
\DoxyCodeLine{495 \};}
\DoxyCodeLine{496 }
\DoxyCodeLine{497 \textcolor{comment}{//  Helper to identify which setup function for TestCase / TestSuite to call.}}
\DoxyCodeLine{498 \textcolor{comment}{//  Only one function is allowed, either TestCase or TestSute but not both.}}
\DoxyCodeLine{499 }
\DoxyCodeLine{500 \textcolor{comment}{// Utility functions to help SuiteApiResolver}}
\DoxyCodeLine{501 \textcolor{keyword}{using }SetUpTearDownSuiteFuncType = void (*)();}
\DoxyCodeLine{502 }
\DoxyCodeLine{503 \textcolor{keyword}{inline} SetUpTearDownSuiteFuncType GetNotDefaultOrNull(}
\DoxyCodeLine{504     SetUpTearDownSuiteFuncType a, SetUpTearDownSuiteFuncType def) \{}
\DoxyCodeLine{505   \textcolor{keywordflow}{return} a == def ? nullptr : a;}
\DoxyCodeLine{506 \}}
\DoxyCodeLine{507 }
\DoxyCodeLine{508 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{509 \textcolor{comment}{//  Note that SuiteApiResolver inherits from T because}}
\DoxyCodeLine{510 \textcolor{comment}{//  SetUpTestSuite()/TearDownTestSuite() could be protected. This way}}
\DoxyCodeLine{511 \textcolor{comment}{//  SuiteApiResolver can access them.}}
\DoxyCodeLine{512 \textcolor{keyword}{struct }\mbox{\hyperlink{structtesting_1_1internal_1_1SuiteApiResolver}{SuiteApiResolver}} : T \{}
\DoxyCodeLine{513   \textcolor{comment}{// testing::Test is only forward declared at this point. So we make it a}}
\DoxyCodeLine{514   \textcolor{comment}{// dependent class for the compiler to be OK with it.}}
\DoxyCodeLine{515   \textcolor{keyword}{using }Test =}
\DoxyCodeLine{516       \textcolor{keyword}{typename} std::conditional<\textcolor{keyword}{sizeof}(T) != 0, \mbox{\hyperlink{classtesting_1_1Test}{::testing::Test}}, \textcolor{keywordtype}{void}>::type;}
\DoxyCodeLine{517 }
\DoxyCodeLine{518   \textcolor{keyword}{static} SetUpTearDownSuiteFuncType GetSetUpCaseOrSuite(\textcolor{keyword}{const} \textcolor{keywordtype}{char}* filename,}
\DoxyCodeLine{519                                                         \textcolor{keywordtype}{int} line\_num) \{}
\DoxyCodeLine{520 \textcolor{preprocessor}{\#ifndef GTEST\_REMOVE\_LEGACY\_TEST\_CASEAPI\_}}
\DoxyCodeLine{521     SetUpTearDownSuiteFuncType test\_case\_fp =}
\DoxyCodeLine{522         GetNotDefaultOrNull(\&T::SetUpTestCase, \&Test::SetUpTestCase);}
\DoxyCodeLine{523     SetUpTearDownSuiteFuncType test\_suite\_fp =}
\DoxyCodeLine{524         GetNotDefaultOrNull(\&T::SetUpTestSuite, \&Test::SetUpTestSuite);}
\DoxyCodeLine{525 }
\DoxyCodeLine{526     GTEST\_CHECK\_(!test\_case\_fp || !test\_suite\_fp)}
\DoxyCodeLine{527         << \textcolor{stringliteral}{"{}Test can not provide both SetUpTestSuite and SetUpTestCase, please "{}}}
\DoxyCodeLine{528            \textcolor{stringliteral}{"{}make sure there is only one present at "{}}}
\DoxyCodeLine{529         << filename << \textcolor{stringliteral}{"{}:"{}} << line\_num;}
\DoxyCodeLine{530 }
\DoxyCodeLine{531     \textcolor{keywordflow}{return} test\_case\_fp != \textcolor{keyword}{nullptr} ? test\_case\_fp : test\_suite\_fp;}
\DoxyCodeLine{532 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{533     (void)(filename);}
\DoxyCodeLine{534     (void)(line\_num);}
\DoxyCodeLine{535     \textcolor{keywordflow}{return} \&T::SetUpTestSuite;}
\DoxyCodeLine{536 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{537   \}}
\DoxyCodeLine{538 }
\DoxyCodeLine{539   \textcolor{keyword}{static} SetUpTearDownSuiteFuncType GetTearDownCaseOrSuite(\textcolor{keyword}{const} \textcolor{keywordtype}{char}* filename,}
\DoxyCodeLine{540                                                            \textcolor{keywordtype}{int} line\_num) \{}
\DoxyCodeLine{541 \textcolor{preprocessor}{\#ifndef GTEST\_REMOVE\_LEGACY\_TEST\_CASEAPI\_}}
\DoxyCodeLine{542     SetUpTearDownSuiteFuncType test\_case\_fp =}
\DoxyCodeLine{543         GetNotDefaultOrNull(\&T::TearDownTestCase, \&Test::TearDownTestCase);}
\DoxyCodeLine{544     SetUpTearDownSuiteFuncType test\_suite\_fp =}
\DoxyCodeLine{545         GetNotDefaultOrNull(\&T::TearDownTestSuite, \&Test::TearDownTestSuite);}
\DoxyCodeLine{546 }
\DoxyCodeLine{547     GTEST\_CHECK\_(!test\_case\_fp || !test\_suite\_fp)}
\DoxyCodeLine{548         << \textcolor{stringliteral}{"{}Test can not provide both TearDownTestSuite and TearDownTestCase,"{}}}
\DoxyCodeLine{549            \textcolor{stringliteral}{"{} please make sure there is only one present at"{}}}
\DoxyCodeLine{550         << filename << \textcolor{stringliteral}{"{}:"{}} << line\_num;}
\DoxyCodeLine{551 }
\DoxyCodeLine{552     \textcolor{keywordflow}{return} test\_case\_fp != \textcolor{keyword}{nullptr} ? test\_case\_fp : test\_suite\_fp;}
\DoxyCodeLine{553 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{554     (void)(filename);}
\DoxyCodeLine{555     (void)(line\_num);}
\DoxyCodeLine{556     \textcolor{keywordflow}{return} \&T::TearDownTestSuite;}
\DoxyCodeLine{557 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{558   \}}
\DoxyCodeLine{559 \};}
\DoxyCodeLine{560 }
\DoxyCodeLine{561 \textcolor{comment}{// Creates a new TestInfo object and registers it with Google Test;}}
\DoxyCodeLine{562 \textcolor{comment}{// returns the created object.}}
\DoxyCodeLine{563 \textcolor{comment}{//}}
\DoxyCodeLine{564 \textcolor{comment}{// Arguments:}}
\DoxyCodeLine{565 \textcolor{comment}{//}}
\DoxyCodeLine{566 \textcolor{comment}{//   test\_suite\_name:  name of the test suite}}
\DoxyCodeLine{567 \textcolor{comment}{//   name:             name of the test}}
\DoxyCodeLine{568 \textcolor{comment}{//   type\_param:       the name of the test's type parameter, or NULL if}}
\DoxyCodeLine{569 \textcolor{comment}{//                     this is not a typed or a type-\/parameterized test.}}
\DoxyCodeLine{570 \textcolor{comment}{//   value\_param:      text representation of the test's value parameter,}}
\DoxyCodeLine{571 \textcolor{comment}{//                     or NULL if this is not a type-\/parameterized test.}}
\DoxyCodeLine{572 \textcolor{comment}{//   code\_location:    code location where the test is defined}}
\DoxyCodeLine{573 \textcolor{comment}{//   fixture\_class\_id: ID of the test fixture class}}
\DoxyCodeLine{574 \textcolor{comment}{//   set\_up\_tc:        pointer to the function that sets up the test suite}}
\DoxyCodeLine{575 \textcolor{comment}{//   tear\_down\_tc:     pointer to the function that tears down the test suite}}
\DoxyCodeLine{576 \textcolor{comment}{//   factory:          pointer to the factory that creates a test object.}}
\DoxyCodeLine{577 \textcolor{comment}{//                     The newly created TestInfo instance will assume}}
\DoxyCodeLine{578 \textcolor{comment}{//                     ownership of the factory object.}}
\DoxyCodeLine{579 GTEST\_API\_ \mbox{\hyperlink{classtesting_1_1TestInfo}{TestInfo}}* MakeAndRegisterTestInfo(}
\DoxyCodeLine{580     \textcolor{keyword}{const} \textcolor{keywordtype}{char}* test\_suite\_name, \textcolor{keyword}{const} \textcolor{keywordtype}{char}* name, \textcolor{keyword}{const} \textcolor{keywordtype}{char}* type\_param,}
\DoxyCodeLine{581     \textcolor{keyword}{const} \textcolor{keywordtype}{char}* value\_param, \mbox{\hyperlink{structtesting_1_1internal_1_1CodeLocation}{CodeLocation}} code\_location,}
\DoxyCodeLine{582     TypeId fixture\_class\_id, SetUpTestSuiteFunc set\_up\_tc,}
\DoxyCodeLine{583     TearDownTestSuiteFunc tear\_down\_tc, \mbox{\hyperlink{classtesting_1_1internal_1_1TestFactoryBase}{TestFactoryBase}}* factory);}
\DoxyCodeLine{584 }
\DoxyCodeLine{585 \textcolor{comment}{// If *pstr starts with the given prefix, modifies *pstr to be right}}
\DoxyCodeLine{586 \textcolor{comment}{// past the prefix and returns true; otherwise leaves *pstr unchanged}}
\DoxyCodeLine{587 \textcolor{comment}{// and returns false.  None of pstr, *pstr, and prefix can be NULL.}}
\DoxyCodeLine{588 GTEST\_API\_ \textcolor{keywordtype}{bool} SkipPrefix(\textcolor{keyword}{const} \textcolor{keywordtype}{char}* prefix, \textcolor{keyword}{const} \textcolor{keywordtype}{char}** pstr);}
\DoxyCodeLine{589 }
\DoxyCodeLine{590 GTEST\_DISABLE\_MSC\_WARNINGS\_PUSH\_(4251 \(\backslash\)}
\DoxyCodeLine{591 \textcolor{comment}{/* class A needs to have dll-\/interface to be used by clients of class B */})}
\DoxyCodeLine{592 }
\DoxyCodeLine{593 \textcolor{comment}{// State of the definition of a type-\/parameterized test suite.}}
\DoxyCodeLine{594 class GTEST\_API\_ TypedTestSuitePState \{}
\DoxyCodeLine{595  \textcolor{keyword}{public}:}
\DoxyCodeLine{596   TypedTestSuitePState() : registered\_(false) \{\}}
\DoxyCodeLine{597 }
\DoxyCodeLine{598   \textcolor{comment}{// Adds the given test name to defined\_test\_names\_ and return true}}
\DoxyCodeLine{599   \textcolor{comment}{// if the test suite hasn't been registered; otherwise aborts the}}
\DoxyCodeLine{600   \textcolor{comment}{// program.}}
\DoxyCodeLine{601   \textcolor{keywordtype}{bool} AddTestName(\textcolor{keyword}{const} \textcolor{keywordtype}{char}* file, \textcolor{keywordtype}{int} line, \textcolor{keyword}{const} \textcolor{keywordtype}{char}* case\_name,}
\DoxyCodeLine{602                    \textcolor{keyword}{const} \textcolor{keywordtype}{char}* test\_name) \{}
\DoxyCodeLine{603     \textcolor{keywordflow}{if} (registered\_) \{}
\DoxyCodeLine{604       fprintf(stderr,}
\DoxyCodeLine{605               \textcolor{stringliteral}{"{}\%s Test \%s must be defined before "{}}}
\DoxyCodeLine{606               \textcolor{stringliteral}{"{}REGISTER\_TYPED\_TEST\_SUITE\_P(\%s, ...).\(\backslash\)n"{}},}
\DoxyCodeLine{607               FormatFileLocation(file, line).c\_str(), test\_name, case\_name);}
\DoxyCodeLine{608       fflush(stderr);}
\DoxyCodeLine{609       posix::Abort();}
\DoxyCodeLine{610     \}}
\DoxyCodeLine{611     registered\_tests\_.insert(}
\DoxyCodeLine{612         ::std::make\_pair(test\_name, CodeLocation(file, line)));}
\DoxyCodeLine{613     \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{614   \}}
\DoxyCodeLine{615 }
\DoxyCodeLine{616   \textcolor{keywordtype}{bool} TestExists(\textcolor{keyword}{const} std::string\& test\_name)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{617     \textcolor{keywordflow}{return} registered\_tests\_.count(test\_name) > 0;}
\DoxyCodeLine{618   \}}
\DoxyCodeLine{619 }
\DoxyCodeLine{620   \textcolor{keyword}{const} CodeLocation\& GetCodeLocation(\textcolor{keyword}{const} std::string\& test\_name)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{621     RegisteredTestsMap::const\_iterator it = registered\_tests\_.find(test\_name);}
\DoxyCodeLine{622     GTEST\_CHECK\_(it != registered\_tests\_.end());}
\DoxyCodeLine{623     \textcolor{keywordflow}{return} it-\/>second;}
\DoxyCodeLine{624   \}}
\DoxyCodeLine{625 }
\DoxyCodeLine{626   \textcolor{comment}{// Verifies that registered\_tests match the test names in}}
\DoxyCodeLine{627   \textcolor{comment}{// defined\_test\_names\_; returns registered\_tests if successful, or}}
\DoxyCodeLine{628   \textcolor{comment}{// aborts the program otherwise.}}
\DoxyCodeLine{629   \textcolor{keyword}{const} \textcolor{keywordtype}{char}* VerifyRegisteredTestNames(\textcolor{keyword}{const} \textcolor{keywordtype}{char}* test\_suite\_name,}
\DoxyCodeLine{630                                         \textcolor{keyword}{const} \textcolor{keywordtype}{char}* file, \textcolor{keywordtype}{int} line,}
\DoxyCodeLine{631                                         \textcolor{keyword}{const} \textcolor{keywordtype}{char}* registered\_tests);}
\DoxyCodeLine{632 }
\DoxyCodeLine{633  \textcolor{keyword}{private}:}
\DoxyCodeLine{634   typedef ::std::map<std::string, CodeLocation> RegisteredTestsMap;}
\DoxyCodeLine{635 }
\DoxyCodeLine{636   \textcolor{keywordtype}{bool} registered\_;}
\DoxyCodeLine{637   RegisteredTestsMap registered\_tests\_;}
\DoxyCodeLine{638 \};}
\DoxyCodeLine{639 }
\DoxyCodeLine{640 \textcolor{comment}{//  Legacy API is deprecated but still available}}
\DoxyCodeLine{641 \textcolor{preprocessor}{\#ifndef GTEST\_REMOVE\_LEGACY\_TEST\_CASEAPI\_}}
\DoxyCodeLine{642 \textcolor{keyword}{using }TypedTestCasePState = TypedTestSuitePState;}
\DoxyCodeLine{643 \textcolor{preprocessor}{\#endif  }\textcolor{comment}{//  GTEST\_REMOVE\_LEGACY\_TEST\_CASEAPI\_}}
\DoxyCodeLine{644 }
\DoxyCodeLine{645 GTEST\_DISABLE\_MSC\_WARNINGS\_POP\_()  \textcolor{comment}{//  4251}}
\DoxyCodeLine{646 }
\DoxyCodeLine{647 \textcolor{comment}{// Skips to the first non-\/space char after the first comma in 'str';}}
\DoxyCodeLine{648 \textcolor{comment}{// returns NULL if no comma is found in 'str'.}}
\DoxyCodeLine{649 inline const \textcolor{keywordtype}{char}* SkipComma(const \textcolor{keywordtype}{char}* str) \{}
\DoxyCodeLine{650   \textcolor{keyword}{const} \textcolor{keywordtype}{char}* comma = strchr(str, \textcolor{charliteral}{','});}
\DoxyCodeLine{651   \textcolor{keywordflow}{if} (comma == \textcolor{keyword}{nullptr}) \{}
\DoxyCodeLine{652     \textcolor{keywordflow}{return} \textcolor{keyword}{nullptr};}
\DoxyCodeLine{653   \}}
\DoxyCodeLine{654   \textcolor{keywordflow}{while} (IsSpace(*(++comma))) \{}
\DoxyCodeLine{655   \}}
\DoxyCodeLine{656   \textcolor{keywordflow}{return} comma;}
\DoxyCodeLine{657 \}}
\DoxyCodeLine{658 }
\DoxyCodeLine{659 \textcolor{comment}{// Returns the prefix of 'str' before the first comma in it; returns}}
\DoxyCodeLine{660 \textcolor{comment}{// the entire string if it contains no comma.}}
\DoxyCodeLine{661 \textcolor{keyword}{inline} std::string GetPrefixUntilComma(\textcolor{keyword}{const} \textcolor{keywordtype}{char}* str) \{}
\DoxyCodeLine{662   \textcolor{keyword}{const} \textcolor{keywordtype}{char}* comma = strchr(str, \textcolor{charliteral}{','});}
\DoxyCodeLine{663   \textcolor{keywordflow}{return} comma == \textcolor{keyword}{nullptr} ? str : std::string(str, comma);}
\DoxyCodeLine{664 \}}
\DoxyCodeLine{665 }
\DoxyCodeLine{666 \textcolor{comment}{// Splits a given string on a given delimiter, populating a given}}
\DoxyCodeLine{667 \textcolor{comment}{// vector with the fields.}}
\DoxyCodeLine{668 \textcolor{keywordtype}{void} SplitString(const ::std::string\& str, \textcolor{keywordtype}{char} delimiter,}
\DoxyCodeLine{669                  ::std::vector<::std::string>* dest);}
\DoxyCodeLine{670 }
\DoxyCodeLine{671 \textcolor{comment}{// The default argument to the template below for the case when the user does}}
\DoxyCodeLine{672 \textcolor{comment}{// not provide a name generator.}}
\DoxyCodeLine{673 \textcolor{keyword}{struct }\mbox{\hyperlink{structtesting_1_1internal_1_1DefaultNameGenerator}{DefaultNameGenerator}} \{}
\DoxyCodeLine{674   \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{675   \textcolor{keyword}{static} std::string GetName(\textcolor{keywordtype}{int} i) \{}
\DoxyCodeLine{676     \textcolor{keywordflow}{return} StreamableToString(i);}
\DoxyCodeLine{677   \}}
\DoxyCodeLine{678 \};}
\DoxyCodeLine{679 }
\DoxyCodeLine{680 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Prov\textcolor{keywordtype}{id}ed = DefaultNameGenerator>}
\DoxyCodeLine{681 \textcolor{keyword}{struct }\mbox{\hyperlink{structtesting_1_1internal_1_1NameGeneratorSelector}{NameGeneratorSelector}} \{}
\DoxyCodeLine{682   \textcolor{keyword}{typedef} Provided type;}
\DoxyCodeLine{683 \};}
\DoxyCodeLine{684 }
\DoxyCodeLine{685 \textcolor{keyword}{template} <\textcolor{keyword}{typename} NameGenerator>}
\DoxyCodeLine{686 \textcolor{keywordtype}{void} GenerateNamesRecursively(\mbox{\hyperlink{structtesting_1_1internal_1_1None}{internal::None}}, std::vector<std::string>*, \textcolor{keywordtype}{int}) \{\}}
\DoxyCodeLine{687 }
\DoxyCodeLine{688 \textcolor{keyword}{template} <\textcolor{keyword}{typename} NameGenerator, \textcolor{keyword}{typename} Types>}
\DoxyCodeLine{689 \textcolor{keywordtype}{void} GenerateNamesRecursively(\mbox{\hyperlink{structtesting_1_1internal_1_1ProxyTypeList}{Types}}, std::vector<std::string>* result, \textcolor{keywordtype}{int} i) \{}
\DoxyCodeLine{690   result-\/>push\_back(NameGenerator::template GetName<typename Types::Head>(i));}
\DoxyCodeLine{691   GenerateNamesRecursively<NameGenerator>(\textcolor{keyword}{typename} Types::Tail(), result,}
\DoxyCodeLine{692                                           i + 1);}
\DoxyCodeLine{693 \}}
\DoxyCodeLine{694 }
\DoxyCodeLine{695 \textcolor{keyword}{template} <\textcolor{keyword}{typename} NameGenerator, \textcolor{keyword}{typename} Types>}
\DoxyCodeLine{696 std::vector<std::string> GenerateNames() \{}
\DoxyCodeLine{697   std::vector<std::string> result;}
\DoxyCodeLine{698   GenerateNamesRecursively<NameGenerator>(Types(), \&result, 0);}
\DoxyCodeLine{699   \textcolor{keywordflow}{return} result;}
\DoxyCodeLine{700 \}}
\DoxyCodeLine{701 }
\DoxyCodeLine{702 \textcolor{comment}{// TypeParameterizedTest<Fixture, TestSel, Types>::Register()}}
\DoxyCodeLine{703 \textcolor{comment}{// registers a list of type-\/parameterized tests with Google Test.  The}}
\DoxyCodeLine{704 \textcolor{comment}{// return value is insignificant -\/ we just need to return something}}
\DoxyCodeLine{705 \textcolor{comment}{// such that we can call this function in a namespace scope.}}
\DoxyCodeLine{706 \textcolor{comment}{//}}
\DoxyCodeLine{707 \textcolor{comment}{// Implementation note: The GTEST\_TEMPLATE\_ macro declares a template}}
\DoxyCodeLine{708 \textcolor{comment}{// template parameter.  It's defined in gtest-\/type-\/util.h.}}
\DoxyCodeLine{709 \textcolor{keyword}{template} <GTEST\_TEMPLATE\_ Fixture, \textcolor{keyword}{class} TestSel, \textcolor{keyword}{typename} Types>}
\DoxyCodeLine{710 \textcolor{keyword}{class }\mbox{\hyperlink{classtesting_1_1internal_1_1TypeParameterizedTest}{TypeParameterizedTest}} \{}
\DoxyCodeLine{711  \textcolor{keyword}{public}:}
\DoxyCodeLine{712   \textcolor{comment}{// 'index' is the index of the test in the type list 'Types'}}
\DoxyCodeLine{713   \textcolor{comment}{// specified in INSTANTIATE\_TYPED\_TEST\_SUITE\_P(Prefix, TestSuite,}}
\DoxyCodeLine{714   \textcolor{comment}{// Types).  Valid values for 'index' are [0, N -\/ 1] where N is the}}
\DoxyCodeLine{715   \textcolor{comment}{// length of Types.}}
\DoxyCodeLine{716   \textcolor{keyword}{static} \textcolor{keywordtype}{bool} Register(\textcolor{keyword}{const} \textcolor{keywordtype}{char}* prefix, \textcolor{keyword}{const} \mbox{\hyperlink{structtesting_1_1internal_1_1CodeLocation}{CodeLocation}}\& code\_location,}
\DoxyCodeLine{717                        \textcolor{keyword}{const} \textcolor{keywordtype}{char}* case\_name, \textcolor{keyword}{const} \textcolor{keywordtype}{char}* test\_names, \textcolor{keywordtype}{int} index,}
\DoxyCodeLine{718                        \textcolor{keyword}{const} std::vector<std::string>\& type\_names =}
\DoxyCodeLine{719                            GenerateNames<DefaultNameGenerator, Types>()) \{}
\DoxyCodeLine{720     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} Types::Head Type;}
\DoxyCodeLine{721     \textcolor{keyword}{typedef} \mbox{\hyperlink{classFixture}{Fixture<Type>}} FixtureClass;}
\DoxyCodeLine{722     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} GTEST\_BIND\_(TestSel, Type) TestClass;}
\DoxyCodeLine{723 }
\DoxyCodeLine{724     \textcolor{comment}{// First, registers the first type-\/parameterized test in the type}}
\DoxyCodeLine{725     \textcolor{comment}{// list.}}
\DoxyCodeLine{726     MakeAndRegisterTestInfo(}
\DoxyCodeLine{727         (std::string(prefix) + (prefix[0] == \textcolor{charliteral}{'\(\backslash\)0'} ? \textcolor{stringliteral}{"{}"{}} : \textcolor{stringliteral}{"{}/"{}}) + case\_name +}
\DoxyCodeLine{728          \textcolor{stringliteral}{"{}/"{}} + type\_names[\textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{size\_t}\textcolor{keyword}{>}(index)])}
\DoxyCodeLine{729             .c\_str(),}
\DoxyCodeLine{730         StripTrailingSpaces(GetPrefixUntilComma(test\_names)).c\_str(),}
\DoxyCodeLine{731         GetTypeName<Type>().c\_str(),}
\DoxyCodeLine{732         \textcolor{keyword}{nullptr},  \textcolor{comment}{// No value parameter.}}
\DoxyCodeLine{733         code\_location, GetTypeId<FixtureClass>(),}
\DoxyCodeLine{734         \mbox{\hyperlink{structtesting_1_1internal_1_1SuiteApiResolver}{SuiteApiResolver<TestClass>::GetSetUpCaseOrSuite}}(}
\DoxyCodeLine{735             code\_location.file.c\_str(), code\_location.line),}
\DoxyCodeLine{736         \mbox{\hyperlink{structtesting_1_1internal_1_1SuiteApiResolver}{SuiteApiResolver<TestClass>::GetTearDownCaseOrSuite}}(}
\DoxyCodeLine{737             code\_location.file.c\_str(), code\_location.line),}
\DoxyCodeLine{738         \textcolor{keyword}{new} \mbox{\hyperlink{classtesting_1_1internal_1_1TestFactoryImpl}{TestFactoryImpl<TestClass>}});}
\DoxyCodeLine{739 }
\DoxyCodeLine{740     \textcolor{comment}{// Next, recurses (at compile time) with the tail of the type list.}}
\DoxyCodeLine{741     \textcolor{keywordflow}{return} \mbox{\hyperlink{classtesting_1_1internal_1_1TypeParameterizedTest}{TypeParameterizedTest}}<\mbox{\hyperlink{classFixture}{Fixture}}, TestSel,}
\DoxyCodeLine{742                                  \textcolor{keyword}{typename} Types::Tail>::Register(prefix,}
\DoxyCodeLine{743                                                                  code\_location,}
\DoxyCodeLine{744                                                                  case\_name,}
\DoxyCodeLine{745                                                                  test\_names,}
\DoxyCodeLine{746                                                                  index + 1,}
\DoxyCodeLine{747                                                                  type\_names);}
\DoxyCodeLine{748   \}}
\DoxyCodeLine{749 \};}
\DoxyCodeLine{750 }
\DoxyCodeLine{751 \textcolor{comment}{// The base case for the compile time recursion.}}
\DoxyCodeLine{752 \textcolor{keyword}{template} <GTEST\_TEMPLATE\_ Fixture, \textcolor{keyword}{class} TestSel>}
\DoxyCodeLine{753 \textcolor{keyword}{class }\mbox{\hyperlink{classtesting_1_1internal_1_1TypeParameterizedTest}{TypeParameterizedTest}}<\mbox{\hyperlink{classFixture}{Fixture}}, TestSel, internal::\mbox{\hyperlink{structtesting_1_1internal_1_1None}{None}}> \{}
\DoxyCodeLine{754  \textcolor{keyword}{public}:}
\DoxyCodeLine{755   \textcolor{keyword}{static} \textcolor{keywordtype}{bool} Register(\textcolor{keyword}{const} \textcolor{keywordtype}{char}* \textcolor{comment}{/*prefix*/}, \textcolor{keyword}{const} \mbox{\hyperlink{structtesting_1_1internal_1_1CodeLocation}{CodeLocation}}\&,}
\DoxyCodeLine{756                        \textcolor{keyword}{const} \textcolor{keywordtype}{char}* \textcolor{comment}{/*case\_name*/}, \textcolor{keyword}{const} \textcolor{keywordtype}{char}* \textcolor{comment}{/*test\_names*/},}
\DoxyCodeLine{757                        \textcolor{keywordtype}{int} \textcolor{comment}{/*index*/},}
\DoxyCodeLine{758                        \textcolor{keyword}{const} std::vector<std::string>\& =}
\DoxyCodeLine{759                            std::vector<std::string>() \textcolor{comment}{/*type\_names*/}) \{}
\DoxyCodeLine{760     \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{761   \}}
\DoxyCodeLine{762 \};}
\DoxyCodeLine{763 }
\DoxyCodeLine{764 GTEST\_API\_ \textcolor{keywordtype}{void} RegisterTypeParameterizedTestSuite(\textcolor{keyword}{const} \textcolor{keywordtype}{char}* test\_suite\_name,}
\DoxyCodeLine{765                                                    \mbox{\hyperlink{structtesting_1_1internal_1_1CodeLocation}{CodeLocation}} code\_location);}
\DoxyCodeLine{766 GTEST\_API\_ \textcolor{keywordtype}{void} RegisterTypeParameterizedTestSuiteInstantiation(}
\DoxyCodeLine{767     \textcolor{keyword}{const} \textcolor{keywordtype}{char}* case\_name);}
\DoxyCodeLine{768 }
\DoxyCodeLine{769 \textcolor{comment}{// TypeParameterizedTestSuite<Fixture, Tests, Types>::Register()}}
\DoxyCodeLine{770 \textcolor{comment}{// registers *all combinations* of 'Tests' and 'Types' with Google}}
\DoxyCodeLine{771 \textcolor{comment}{// Test.  The return value is insignificant -\/ we just need to return}}
\DoxyCodeLine{772 \textcolor{comment}{// something such that we can call this function in a namespace scope.}}
\DoxyCodeLine{773 \textcolor{keyword}{template} <GTEST\_TEMPLATE\_ Fixture, \textcolor{keyword}{typename} Tests, \textcolor{keyword}{typename} Types>}
\DoxyCodeLine{774 \textcolor{keyword}{class }\mbox{\hyperlink{classtesting_1_1internal_1_1TypeParameterizedTestSuite}{TypeParameterizedTestSuite}} \{}
\DoxyCodeLine{775  \textcolor{keyword}{public}:}
\DoxyCodeLine{776   \textcolor{keyword}{static} \textcolor{keywordtype}{bool} Register(\textcolor{keyword}{const} \textcolor{keywordtype}{char}* prefix, \mbox{\hyperlink{structtesting_1_1internal_1_1CodeLocation}{CodeLocation}} code\_location,}
\DoxyCodeLine{777                        \textcolor{keyword}{const} TypedTestSuitePState* state, \textcolor{keyword}{const} \textcolor{keywordtype}{char}* case\_name,}
\DoxyCodeLine{778                        \textcolor{keyword}{const} \textcolor{keywordtype}{char}* test\_names,}
\DoxyCodeLine{779                        \textcolor{keyword}{const} std::vector<std::string>\& type\_names =}
\DoxyCodeLine{780                            GenerateNames<DefaultNameGenerator, Types>()) \{}
\DoxyCodeLine{781     RegisterTypeParameterizedTestSuiteInstantiation(case\_name);}
\DoxyCodeLine{782     std::string test\_name =}
\DoxyCodeLine{783         StripTrailingSpaces(GetPrefixUntilComma(test\_names));}
\DoxyCodeLine{784     \textcolor{keywordflow}{if} (!state-\/>TestExists(test\_name)) \{}
\DoxyCodeLine{785       fprintf(stderr, \textcolor{stringliteral}{"{}Failed to get code location for test \%s.\%s at \%s."{}},}
\DoxyCodeLine{786               case\_name, test\_name.c\_str(),}
\DoxyCodeLine{787               FormatFileLocation(code\_location.file.c\_str(), code\_location.line)}
\DoxyCodeLine{788                   .c\_str());}
\DoxyCodeLine{789       fflush(stderr);}
\DoxyCodeLine{790       posix::Abort();}
\DoxyCodeLine{791     \}}
\DoxyCodeLine{792     \textcolor{keyword}{const} \mbox{\hyperlink{structtesting_1_1internal_1_1CodeLocation}{CodeLocation}}\& test\_location = state-\/>GetCodeLocation(test\_name);}
\DoxyCodeLine{793 }
\DoxyCodeLine{794     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} Tests::Head Head;}
\DoxyCodeLine{795 }
\DoxyCodeLine{796     \textcolor{comment}{// First, register the first test in 'Test' for each type in 'Types'.}}
\DoxyCodeLine{797     \mbox{\hyperlink{classtesting_1_1internal_1_1TypeParameterizedTest}{TypeParameterizedTest<Fixture, Head, Types>::Register}}(}
\DoxyCodeLine{798         prefix, test\_location, case\_name, test\_names, 0, type\_names);}
\DoxyCodeLine{799 }
\DoxyCodeLine{800     \textcolor{comment}{// Next, recurses (at compile time) with the tail of the test list.}}
\DoxyCodeLine{801     \textcolor{keywordflow}{return} \mbox{\hyperlink{classtesting_1_1internal_1_1TypeParameterizedTestSuite}{TypeParameterizedTestSuite}}<\mbox{\hyperlink{classFixture}{Fixture}}, \textcolor{keyword}{typename} Tests::Tail,}
\DoxyCodeLine{802                                       \mbox{\hyperlink{structtesting_1_1internal_1_1Types}{Types}}>::Register(prefix, code\_location,}
\DoxyCodeLine{803                                                        state, case\_name,}
\DoxyCodeLine{804                                                        SkipComma(test\_names),}
\DoxyCodeLine{805                                                        type\_names);}
\DoxyCodeLine{806   \}}
\DoxyCodeLine{807 \};}
\DoxyCodeLine{808 }
\DoxyCodeLine{809 \textcolor{comment}{// The base case for the compile time recursion.}}
\DoxyCodeLine{810 \textcolor{keyword}{template} <GTEST\_TEMPLATE\_ Fixture, \textcolor{keyword}{typename} Types>}
\DoxyCodeLine{811 \textcolor{keyword}{class }\mbox{\hyperlink{classtesting_1_1internal_1_1TypeParameterizedTestSuite}{TypeParameterizedTestSuite}}<\mbox{\hyperlink{classFixture}{Fixture}}, internal::\mbox{\hyperlink{structtesting_1_1internal_1_1None}{None}}, \mbox{\hyperlink{structtesting_1_1internal_1_1Types}{Types}}> \{}
\DoxyCodeLine{812  \textcolor{keyword}{public}:}
\DoxyCodeLine{813   \textcolor{keyword}{static} \textcolor{keywordtype}{bool} Register(\textcolor{keyword}{const} \textcolor{keywordtype}{char}* \textcolor{comment}{/*prefix*/}, \textcolor{keyword}{const} \mbox{\hyperlink{structtesting_1_1internal_1_1CodeLocation}{CodeLocation}}\&,}
\DoxyCodeLine{814                        \textcolor{keyword}{const} TypedTestSuitePState* \textcolor{comment}{/*state*/},}
\DoxyCodeLine{815                        \textcolor{keyword}{const} \textcolor{keywordtype}{char}* \textcolor{comment}{/*case\_name*/}, \textcolor{keyword}{const} \textcolor{keywordtype}{char}* \textcolor{comment}{/*test\_names*/},}
\DoxyCodeLine{816                        \textcolor{keyword}{const} std::vector<std::string>\& =}
\DoxyCodeLine{817                            std::vector<std::string>() \textcolor{comment}{/*type\_names*/}) \{}
\DoxyCodeLine{818     \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{819   \}}
\DoxyCodeLine{820 \};}
\DoxyCodeLine{821 }
\DoxyCodeLine{822 \textcolor{comment}{// Returns the current OS stack trace as an std::string.}}
\DoxyCodeLine{823 \textcolor{comment}{//}}
\DoxyCodeLine{824 \textcolor{comment}{// The maximum number of stack frames to be included is specified by}}
\DoxyCodeLine{825 \textcolor{comment}{// the gtest\_stack\_trace\_depth flag.  The skip\_count parameter}}
\DoxyCodeLine{826 \textcolor{comment}{// specifies the number of top frames to be skipped, which doesn't}}
\DoxyCodeLine{827 \textcolor{comment}{// count against the number of frames to be included.}}
\DoxyCodeLine{828 \textcolor{comment}{//}}
\DoxyCodeLine{829 \textcolor{comment}{// For example, if Foo() calls Bar(), which in turn calls}}
\DoxyCodeLine{830 \textcolor{comment}{// GetCurrentOsStackTraceExceptTop(..., 1), Foo() will be included in}}
\DoxyCodeLine{831 \textcolor{comment}{// the trace but Bar() and GetCurrentOsStackTraceExceptTop() won't.}}
\DoxyCodeLine{832 GTEST\_API\_ std::string GetCurrentOsStackTraceExceptTop(\mbox{\hyperlink{classtesting_1_1UnitTest}{UnitTest}}* unit\_test,}
\DoxyCodeLine{833                                                        \textcolor{keywordtype}{int} skip\_count);}
\DoxyCodeLine{834 }
\DoxyCodeLine{835 \textcolor{comment}{// Helpers for suppressing warnings on unreachable code or constant}}
\DoxyCodeLine{836 \textcolor{comment}{// condition.}}
\DoxyCodeLine{837 }
\DoxyCodeLine{838 \textcolor{comment}{// Always returns true.}}
\DoxyCodeLine{839 GTEST\_API\_ \textcolor{keywordtype}{bool} AlwaysTrue();}
\DoxyCodeLine{840 }
\DoxyCodeLine{841 \textcolor{comment}{// Always returns false.}}
\DoxyCodeLine{842 \textcolor{keyword}{inline} \textcolor{keywordtype}{bool} AlwaysFalse() \{ \textcolor{keywordflow}{return} !AlwaysTrue(); \}}
\DoxyCodeLine{843 }
\DoxyCodeLine{844 \textcolor{comment}{// Helper for suppressing false warning from Clang on a const char*}}
\DoxyCodeLine{845 \textcolor{comment}{// variable declared in a conditional expression always being NULL in}}
\DoxyCodeLine{846 \textcolor{comment}{// the else branch.}}
\DoxyCodeLine{847 \textcolor{keyword}{struct }GTEST\_API\_ \mbox{\hyperlink{structtesting_1_1internal_1_1ConstCharPtr}{ConstCharPtr}} \{}
\DoxyCodeLine{848   \mbox{\hyperlink{structtesting_1_1internal_1_1ConstCharPtr}{ConstCharPtr}}(\textcolor{keyword}{const} \textcolor{keywordtype}{char}* str) : value(str) \{\}}
\DoxyCodeLine{849   \textcolor{keyword}{operator} bool()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} \textcolor{keyword}{true}; \}}
\DoxyCodeLine{850   \textcolor{keyword}{const} \textcolor{keywordtype}{char}* value;}
\DoxyCodeLine{851 \};}
\DoxyCodeLine{852 }
\DoxyCodeLine{853 \textcolor{comment}{// Helper for declaring std::string within 'if' statement}}
\DoxyCodeLine{854 \textcolor{comment}{// in pre C++17 build environment.}}
\DoxyCodeLine{855 \textcolor{keyword}{struct }\mbox{\hyperlink{structtesting_1_1internal_1_1TrueWithString}{TrueWithString}} \{}
\DoxyCodeLine{856   \mbox{\hyperlink{structtesting_1_1internal_1_1TrueWithString}{TrueWithString}}() = \textcolor{keywordflow}{default};}
\DoxyCodeLine{857   \textcolor{keyword}{explicit} \mbox{\hyperlink{structtesting_1_1internal_1_1TrueWithString}{TrueWithString}}(\textcolor{keyword}{const} \textcolor{keywordtype}{char}* str) : value(str) \{\}}
\DoxyCodeLine{858   \textcolor{keyword}{explicit} \mbox{\hyperlink{structtesting_1_1internal_1_1TrueWithString}{TrueWithString}}(\textcolor{keyword}{const} std::string\& str) : value(str) \{\}}
\DoxyCodeLine{859   \textcolor{keyword}{explicit} \textcolor{keyword}{operator} bool()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} \textcolor{keyword}{true}; \}}
\DoxyCodeLine{860   std::string value;}
\DoxyCodeLine{861 \};}
\DoxyCodeLine{862 }
\DoxyCodeLine{863 \textcolor{comment}{// A simple Linear Congruential Generator for generating random}}
\DoxyCodeLine{864 \textcolor{comment}{// numbers with a uniform distribution.  Unlike rand() and srand(), it}}
\DoxyCodeLine{865 \textcolor{comment}{// doesn't use global state (and therefore can't interfere with user}}
\DoxyCodeLine{866 \textcolor{comment}{// code).  Unlike rand\_r(), it's portable.  An LCG isn't very random,}}
\DoxyCodeLine{867 \textcolor{comment}{// but it's good enough for our purposes.}}
\DoxyCodeLine{868 \textcolor{keyword}{class }GTEST\_API\_ \mbox{\hyperlink{classtesting_1_1internal_1_1Random}{Random}} \{}
\DoxyCodeLine{869  \textcolor{keyword}{public}:}
\DoxyCodeLine{870   \textcolor{keyword}{static} \textcolor{keyword}{const} uint32\_t kMaxRange = 1u << 31;}
\DoxyCodeLine{871 }
\DoxyCodeLine{872   \textcolor{keyword}{explicit} \mbox{\hyperlink{classtesting_1_1internal_1_1Random}{Random}}(uint32\_t seed) : state\_(seed) \{\}}
\DoxyCodeLine{873 }
\DoxyCodeLine{874   \textcolor{keywordtype}{void} Reseed(uint32\_t seed) \{ state\_ = seed; \}}
\DoxyCodeLine{875 }
\DoxyCodeLine{876   \textcolor{comment}{// Generates a random number from [0, range).  Crashes if 'range' is}}
\DoxyCodeLine{877   \textcolor{comment}{// 0 or greater than kMaxRange.}}
\DoxyCodeLine{878   uint32\_t Generate(uint32\_t range);}
\DoxyCodeLine{879 }
\DoxyCodeLine{880  \textcolor{keyword}{private}:}
\DoxyCodeLine{881   uint32\_t state\_;}
\DoxyCodeLine{882   \mbox{\hyperlink{classtesting_1_1internal_1_1Random}{Random}}(\textcolor{keyword}{const} \mbox{\hyperlink{classtesting_1_1internal_1_1Random}{Random}}\&) = \textcolor{keyword}{delete};}
\DoxyCodeLine{883   \mbox{\hyperlink{classtesting_1_1internal_1_1Random}{Random}}\& operator=(\textcolor{keyword}{const} \mbox{\hyperlink{classtesting_1_1internal_1_1Random}{Random}}\&) = \textcolor{keyword}{delete};}
\DoxyCodeLine{884 \};}
\DoxyCodeLine{885 }
\DoxyCodeLine{886 \textcolor{comment}{// Turns const U\&, U\&, const U, and U all into U.}}
\DoxyCodeLine{887 \textcolor{preprocessor}{\#define GTEST\_REMOVE\_REFERENCE\_AND\_CONST\_(T) \(\backslash\)}}
\DoxyCodeLine{888 \textcolor{preprocessor}{  typename std::remove\_const<typename std::remove\_reference<T>::type>::type}}
\DoxyCodeLine{889 }
\DoxyCodeLine{890 \textcolor{comment}{// HasDebugStringAndShortDebugString<T>::value is a compile-\/time bool constant}}
\DoxyCodeLine{891 \textcolor{comment}{// that's true if and only if T has methods DebugString() and ShortDebugString()}}
\DoxyCodeLine{892 \textcolor{comment}{// that return std::string.}}
\DoxyCodeLine{893 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{894 \textcolor{keyword}{class }\mbox{\hyperlink{classtesting_1_1internal_1_1HasDebugStringAndShortDebugString}{HasDebugStringAndShortDebugString}} \{}
\DoxyCodeLine{895  \textcolor{keyword}{private}:}
\DoxyCodeLine{896   \textcolor{keyword}{template} <\textcolor{keyword}{typename} C>}
\DoxyCodeLine{897   \textcolor{keyword}{static} \textcolor{keyword}{auto} CheckDebugString(C*) -\/> \textcolor{keyword}{typename} std::is\_same<}
\DoxyCodeLine{898       std::string, \textcolor{keyword}{decltype}(std::declval<const C>().DebugString())>::type;}
\DoxyCodeLine{899   \textcolor{keyword}{template} <\textcolor{keyword}{typename}>}
\DoxyCodeLine{900   \textcolor{keyword}{static} std::false\_type CheckDebugString(...);}
\DoxyCodeLine{901 }
\DoxyCodeLine{902   \textcolor{keyword}{template} <\textcolor{keyword}{typename} C>}
\DoxyCodeLine{903   \textcolor{keyword}{static} \textcolor{keyword}{auto} CheckShortDebugString(C*) -\/> \textcolor{keyword}{typename} std::is\_same<}
\DoxyCodeLine{904       std::string, \textcolor{keyword}{decltype}(std::declval<const C>().ShortDebugString())>::type;}
\DoxyCodeLine{905   \textcolor{keyword}{template} <\textcolor{keyword}{typename}>}
\DoxyCodeLine{906   \textcolor{keyword}{static} std::false\_type CheckShortDebugString(...);}
\DoxyCodeLine{907 }
\DoxyCodeLine{908   \textcolor{keyword}{using }HasDebugStringType = \textcolor{keyword}{decltype}(CheckDebugString<T>(\textcolor{keyword}{nullptr}));}
\DoxyCodeLine{909   \textcolor{keyword}{using }HasShortDebugStringType = \textcolor{keyword}{decltype}(CheckShortDebugString<T>(\textcolor{keyword}{nullptr}));}
\DoxyCodeLine{910 }
\DoxyCodeLine{911  \textcolor{keyword}{public}:}
\DoxyCodeLine{912   \textcolor{keyword}{static} \textcolor{keyword}{constexpr} \textcolor{keywordtype}{bool} value =}
\DoxyCodeLine{913       HasDebugStringType::value \&\& HasShortDebugStringType::value;}
\DoxyCodeLine{914 \};}
\DoxyCodeLine{915 }
\DoxyCodeLine{916 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{917 \textcolor{keyword}{constexpr} \textcolor{keywordtype}{bool} \mbox{\hyperlink{classtesting_1_1internal_1_1HasDebugStringAndShortDebugString}{HasDebugStringAndShortDebugString<T>::value}};}
\DoxyCodeLine{918 }
\DoxyCodeLine{919 \textcolor{comment}{// When the compiler sees expression IsContainerTest<C>(0), if C is an}}
\DoxyCodeLine{920 \textcolor{comment}{// STL-\/style container class, the first overload of IsContainerTest}}
\DoxyCodeLine{921 \textcolor{comment}{// will be viable (since both C::iterator* and C::const\_iterator* are}}
\DoxyCodeLine{922 \textcolor{comment}{// valid types and NULL can be implicitly converted to them).  It will}}
\DoxyCodeLine{923 \textcolor{comment}{// be picked over the second overload as 'int' is a perfect match for}}
\DoxyCodeLine{924 \textcolor{comment}{// the type of argument 0.  If C::iterator or C::const\_iterator is not}}
\DoxyCodeLine{925 \textcolor{comment}{// a valid type, the first overload is not viable, and the second}}
\DoxyCodeLine{926 \textcolor{comment}{// overload will be picked.  Therefore, we can determine whether C is}}
\DoxyCodeLine{927 \textcolor{comment}{// a container class by checking the type of IsContainerTest<C>(0).}}
\DoxyCodeLine{928 \textcolor{comment}{// The value of the expression is insignificant.}}
\DoxyCodeLine{929 \textcolor{comment}{//}}
\DoxyCodeLine{930 \textcolor{comment}{// In C++11 mode we check the existence of a const\_iterator and that an}}
\DoxyCodeLine{931 \textcolor{comment}{// iterator is properly implemented for the container.}}
\DoxyCodeLine{932 \textcolor{comment}{//}}
\DoxyCodeLine{933 \textcolor{comment}{// For pre-\/C++11 that we look for both C::iterator and C::const\_iterator.}}
\DoxyCodeLine{934 \textcolor{comment}{// The reason is that C++ injects the name of a class as a member of the}}
\DoxyCodeLine{935 \textcolor{comment}{// class itself (e.g. you can refer to class iterator as either}}
\DoxyCodeLine{936 \textcolor{comment}{// 'iterator' or 'iterator::iterator').  If we look for C::iterator}}
\DoxyCodeLine{937 \textcolor{comment}{// only, for example, we would mistakenly think that a class named}}
\DoxyCodeLine{938 \textcolor{comment}{// iterator is an STL container.}}
\DoxyCodeLine{939 \textcolor{comment}{//}}
\DoxyCodeLine{940 \textcolor{comment}{// Also note that the simpler approach of overloading}}
\DoxyCodeLine{941 \textcolor{comment}{// IsContainerTest(typename C::const\_iterator*) and}}
\DoxyCodeLine{942 \textcolor{comment}{// IsContainerTest(...) doesn't work with Visual Age C++ and Sun C++.}}
\DoxyCodeLine{943 \textcolor{keyword}{typedef} \textcolor{keywordtype}{int} IsContainer;}
\DoxyCodeLine{944 \textcolor{keyword}{template} <\textcolor{keyword}{class }C,}
\DoxyCodeLine{945           \textcolor{keyword}{class }Iterator = \textcolor{keyword}{decltype}(::std::declval<const C\&>().begin()),}
\DoxyCodeLine{946           \textcolor{keyword}{class} = \textcolor{keyword}{decltype}(::std::declval<const C\&>().end()),}
\DoxyCodeLine{947           \textcolor{keyword}{class} = \textcolor{keyword}{decltype}(++::std::declval<Iterator\&>()),}
\DoxyCodeLine{948           \textcolor{keyword}{class} = \textcolor{keyword}{decltype}(*::std::declval<Iterator>()),}
\DoxyCodeLine{949           \textcolor{keyword}{class} = \textcolor{keyword}{typename} C::const\_iterator>}
\DoxyCodeLine{950 IsContainer IsContainerTest(\textcolor{keywordtype}{int} \textcolor{comment}{/* dummy */}) \{}
\DoxyCodeLine{951   \textcolor{keywordflow}{return} 0;}
\DoxyCodeLine{952 \}}
\DoxyCodeLine{953 }
\DoxyCodeLine{954 \textcolor{keyword}{typedef} \textcolor{keywordtype}{char} IsNotContainer;}
\DoxyCodeLine{955 \textcolor{keyword}{template} <\textcolor{keyword}{class} C>}
\DoxyCodeLine{956 IsNotContainer IsContainerTest(\textcolor{keywordtype}{long} \textcolor{comment}{/* dummy */}) \{}
\DoxyCodeLine{957   \textcolor{keywordflow}{return} \textcolor{charliteral}{'\(\backslash\)0'};}
\DoxyCodeLine{958 \}}
\DoxyCodeLine{959 }
\DoxyCodeLine{960 \textcolor{comment}{// Trait to detect whether a type T is a hash table.}}
\DoxyCodeLine{961 \textcolor{comment}{// The heuristic used is that the type contains an inner type `hasher` and does}}
\DoxyCodeLine{962 \textcolor{comment}{// not contain an inner type `reverse\_iterator`.}}
\DoxyCodeLine{963 \textcolor{comment}{// If the container is iterable in reverse, then order might actually matter.}}
\DoxyCodeLine{964 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{965 \textcolor{keyword}{struct }\mbox{\hyperlink{structtesting_1_1internal_1_1IsHashTable}{IsHashTable}} \{}
\DoxyCodeLine{966  \textcolor{keyword}{private}:}
\DoxyCodeLine{967   \textcolor{keyword}{template} <\textcolor{keyword}{typename} U>}
\DoxyCodeLine{968   \textcolor{keyword}{static} \textcolor{keywordtype}{char} test(\textcolor{keyword}{typename} U::hasher*, \textcolor{keyword}{typename} U::reverse\_iterator*);}
\DoxyCodeLine{969   \textcolor{keyword}{template} <\textcolor{keyword}{typename} U>}
\DoxyCodeLine{970   \textcolor{keyword}{static} \textcolor{keywordtype}{int} test(\textcolor{keyword}{typename} U::hasher*, ...);}
\DoxyCodeLine{971   \textcolor{keyword}{template} <\textcolor{keyword}{typename} U>}
\DoxyCodeLine{972   \textcolor{keyword}{static} \textcolor{keywordtype}{char} test(...);}
\DoxyCodeLine{973 }
\DoxyCodeLine{974  \textcolor{keyword}{public}:}
\DoxyCodeLine{975   \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{bool} value = \textcolor{keyword}{sizeof}(test<T>(\textcolor{keyword}{nullptr}, \textcolor{keyword}{nullptr})) == \textcolor{keyword}{sizeof}(\textcolor{keywordtype}{int});}
\DoxyCodeLine{976 \};}
\DoxyCodeLine{977 }
\DoxyCodeLine{978 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{979 \textcolor{keyword}{const} \textcolor{keywordtype}{bool} \mbox{\hyperlink{structtesting_1_1internal_1_1IsHashTable}{IsHashTable<T>::value}};}
\DoxyCodeLine{980 }
\DoxyCodeLine{981 \textcolor{keyword}{template} <\textcolor{keyword}{typename} C,}
\DoxyCodeLine{982           \textcolor{keywordtype}{bool} = \textcolor{keyword}{sizeof}(IsContainerTest<C>(0)) == \textcolor{keyword}{sizeof}(IsContainer)>}
\DoxyCodeLine{983 \textcolor{keyword}{struct }\mbox{\hyperlink{structtesting_1_1internal_1_1IsRecursiveContainerImpl}{IsRecursiveContainerImpl}};}
\DoxyCodeLine{984 }
\DoxyCodeLine{985 \textcolor{keyword}{template} <\textcolor{keyword}{typename} C>}
\DoxyCodeLine{986 \textcolor{keyword}{struct }\mbox{\hyperlink{structtesting_1_1internal_1_1IsRecursiveContainerImpl}{IsRecursiveContainerImpl}}<C, false> : \textcolor{keyword}{public} std::false\_type \{\};}
\DoxyCodeLine{987 }
\DoxyCodeLine{988 \textcolor{comment}{// Since the IsRecursiveContainerImpl depends on the IsContainerTest we need to}}
\DoxyCodeLine{989 \textcolor{comment}{// obey the same inconsistencies as the IsContainerTest, namely check if}}
\DoxyCodeLine{990 \textcolor{comment}{// something is a container is relying on only const\_iterator in C++11 and}}
\DoxyCodeLine{991 \textcolor{comment}{// is relying on both const\_iterator and iterator otherwise}}
\DoxyCodeLine{992 \textcolor{keyword}{template} <\textcolor{keyword}{typename} C>}
\DoxyCodeLine{993 \textcolor{keyword}{struct }\mbox{\hyperlink{structtesting_1_1internal_1_1IsRecursiveContainerImpl}{IsRecursiveContainerImpl}}<C, true> \{}
\DoxyCodeLine{994   \textcolor{keyword}{using }value\_type = \textcolor{keyword}{decltype}(*std::declval<typename C::const\_iterator>());}
\DoxyCodeLine{995   \textcolor{keyword}{using }type =}
\DoxyCodeLine{996       std::is\_same<\textcolor{keyword}{typename} std::remove\_const<}
\DoxyCodeLine{997                        \textcolor{keyword}{typename} std::remove\_reference<value\_type>::type>::type,}
\DoxyCodeLine{998                    C>;}
\DoxyCodeLine{999 \};}
\DoxyCodeLine{1000 }
\DoxyCodeLine{1001 \textcolor{comment}{// IsRecursiveContainer<Type> is a unary compile-\/time predicate that}}
\DoxyCodeLine{1002 \textcolor{comment}{// evaluates whether C is a recursive container type. A recursive container}}
\DoxyCodeLine{1003 \textcolor{comment}{// type is a container type whose value\_type is equal to the container type}}
\DoxyCodeLine{1004 \textcolor{comment}{// itself. An example for a recursive container type is}}
\DoxyCodeLine{1005 \textcolor{comment}{// boost::filesystem::path, whose iterator has a value\_type that is equal to}}
\DoxyCodeLine{1006 \textcolor{comment}{// boost::filesystem::path.}}
\DoxyCodeLine{1007 \textcolor{keyword}{template} <\textcolor{keyword}{typename} C>}
\DoxyCodeLine{1008 \textcolor{keyword}{struct }\mbox{\hyperlink{structtesting_1_1internal_1_1IsRecursiveContainer}{IsRecursiveContainer}} : \textcolor{keyword}{public} \mbox{\hyperlink{structtesting_1_1internal_1_1IsRecursiveContainerImpl}{IsRecursiveContainerImpl}}<C>::type \{\};}
\DoxyCodeLine{1009 }
\DoxyCodeLine{1010 \textcolor{comment}{// Utilities for native arrays.}}
\DoxyCodeLine{1011 }
\DoxyCodeLine{1012 \textcolor{comment}{// ArrayEq() compares two k-\/dimensional native arrays using the}}
\DoxyCodeLine{1013 \textcolor{comment}{// elements' operator==, where k can be any integer >= 0.  When k is}}
\DoxyCodeLine{1014 \textcolor{comment}{// 0, ArrayEq() degenerates into comparing a single pair of values.}}
\DoxyCodeLine{1015 }
\DoxyCodeLine{1016 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T, \textcolor{keyword}{typename} U>}
\DoxyCodeLine{1017 \textcolor{keywordtype}{bool} ArrayEq(\textcolor{keyword}{const} T* lhs, \textcolor{keywordtype}{size\_t} size, \textcolor{keyword}{const} U* rhs);}
\DoxyCodeLine{1018 }
\DoxyCodeLine{1019 \textcolor{comment}{// This generic version is used when k is 0.}}
\DoxyCodeLine{1020 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T, \textcolor{keyword}{typename} U>}
\DoxyCodeLine{1021 \textcolor{keyword}{inline} \textcolor{keywordtype}{bool} ArrayEq(\textcolor{keyword}{const} T\& lhs, \textcolor{keyword}{const} U\& rhs) \{}
\DoxyCodeLine{1022   \textcolor{keywordflow}{return} lhs == rhs;}
\DoxyCodeLine{1023 \}}
\DoxyCodeLine{1024 }
\DoxyCodeLine{1025 \textcolor{comment}{// This overload is used when k >= 1.}}
\DoxyCodeLine{1026 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T, \textcolor{keyword}{typename} U, \textcolor{keywordtype}{size\_t} N>}
\DoxyCodeLine{1027 \textcolor{keyword}{inline} \textcolor{keywordtype}{bool} ArrayEq(\textcolor{keyword}{const} T (\&lhs)[N], \textcolor{keyword}{const} U (\&rhs)[N]) \{}
\DoxyCodeLine{1028   \textcolor{keywordflow}{return} internal::ArrayEq(lhs, N, rhs);}
\DoxyCodeLine{1029 \}}
\DoxyCodeLine{1030 }
\DoxyCodeLine{1031 \textcolor{comment}{// This helper reduces code bloat.  If we instead put its logic inside}}
\DoxyCodeLine{1032 \textcolor{comment}{// the previous ArrayEq() function, arrays with different sizes would}}
\DoxyCodeLine{1033 \textcolor{comment}{// lead to different copies of the template code.}}
\DoxyCodeLine{1034 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T, \textcolor{keyword}{typename} U>}
\DoxyCodeLine{1035 \textcolor{keywordtype}{bool} ArrayEq(\textcolor{keyword}{const} T* lhs, \textcolor{keywordtype}{size\_t} size, \textcolor{keyword}{const} U* rhs) \{}
\DoxyCodeLine{1036   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{size\_t} i = 0; i != size; i++) \{}
\DoxyCodeLine{1037     \textcolor{keywordflow}{if} (!internal::ArrayEq(lhs[i], rhs[i])) \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{1038   \}}
\DoxyCodeLine{1039   \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{1040 \}}
\DoxyCodeLine{1041 }
\DoxyCodeLine{1042 \textcolor{comment}{// Finds the first element in the iterator range [begin, end) that}}
\DoxyCodeLine{1043 \textcolor{comment}{// equals elem.  Element may be a native array type itself.}}
\DoxyCodeLine{1044 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Iter, \textcolor{keyword}{typename} Element>}
\DoxyCodeLine{1045 Iter ArrayAwareFind(Iter begin, Iter end, \textcolor{keyword}{const} Element\& elem) \{}
\DoxyCodeLine{1046   \textcolor{keywordflow}{for} (Iter it = begin; it != end; ++it) \{}
\DoxyCodeLine{1047     \textcolor{keywordflow}{if} (internal::ArrayEq(*it, elem)) \textcolor{keywordflow}{return} it;}
\DoxyCodeLine{1048   \}}
\DoxyCodeLine{1049   \textcolor{keywordflow}{return} end;}
\DoxyCodeLine{1050 \}}
\DoxyCodeLine{1051 }
\DoxyCodeLine{1052 \textcolor{comment}{// CopyArray() copies a k-\/dimensional native array using the elements'}}
\DoxyCodeLine{1053 \textcolor{comment}{// operator=, where k can be any integer >= 0.  When k is 0,}}
\DoxyCodeLine{1054 \textcolor{comment}{// CopyArray() degenerates into copying a single value.}}
\DoxyCodeLine{1055 }
\DoxyCodeLine{1056 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T, \textcolor{keyword}{typename} U>}
\DoxyCodeLine{1057 \textcolor{keywordtype}{void} CopyArray(\textcolor{keyword}{const} T* from, \textcolor{keywordtype}{size\_t} size, U* to);}
\DoxyCodeLine{1058 }
\DoxyCodeLine{1059 \textcolor{comment}{// This generic version is used when k is 0.}}
\DoxyCodeLine{1060 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T, \textcolor{keyword}{typename} U>}
\DoxyCodeLine{1061 \textcolor{keyword}{inline} \textcolor{keywordtype}{void} CopyArray(\textcolor{keyword}{const} T\& from, U* to) \{}
\DoxyCodeLine{1062   *to = from;}
\DoxyCodeLine{1063 \}}
\DoxyCodeLine{1064 }
\DoxyCodeLine{1065 \textcolor{comment}{// This overload is used when k >= 1.}}
\DoxyCodeLine{1066 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T, \textcolor{keyword}{typename} U, \textcolor{keywordtype}{size\_t} N>}
\DoxyCodeLine{1067 \textcolor{keyword}{inline} \textcolor{keywordtype}{void} CopyArray(\textcolor{keyword}{const} T (\&from)[N], U (*to)[N]) \{}
\DoxyCodeLine{1068   internal::CopyArray(from, N, *to);}
\DoxyCodeLine{1069 \}}
\DoxyCodeLine{1070 }
\DoxyCodeLine{1071 \textcolor{comment}{// This helper reduces code bloat.  If we instead put its logic inside}}
\DoxyCodeLine{1072 \textcolor{comment}{// the previous CopyArray() function, arrays with different sizes}}
\DoxyCodeLine{1073 \textcolor{comment}{// would lead to different copies of the template code.}}
\DoxyCodeLine{1074 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T, \textcolor{keyword}{typename} U>}
\DoxyCodeLine{1075 \textcolor{keywordtype}{void} CopyArray(\textcolor{keyword}{const} T* from, \textcolor{keywordtype}{size\_t} size, U* to) \{}
\DoxyCodeLine{1076   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{size\_t} i = 0; i != size; i++) \{}
\DoxyCodeLine{1077     internal::CopyArray(from[i], to + i);}
\DoxyCodeLine{1078   \}}
\DoxyCodeLine{1079 \}}
\DoxyCodeLine{1080 }
\DoxyCodeLine{1081 \textcolor{comment}{// The relation between an NativeArray object (see below) and the}}
\DoxyCodeLine{1082 \textcolor{comment}{// native array it represents.}}
\DoxyCodeLine{1083 \textcolor{comment}{// We use 2 different structs to allow non-\/copyable types to be used, as long}}
\DoxyCodeLine{1084 \textcolor{comment}{// as RelationToSourceReference() is passed.}}
\DoxyCodeLine{1085 \textcolor{keyword}{struct }\mbox{\hyperlink{structtesting_1_1internal_1_1RelationToSourceReference}{RelationToSourceReference}} \{\};}
\DoxyCodeLine{1086 \textcolor{keyword}{struct }\mbox{\hyperlink{structtesting_1_1internal_1_1RelationToSourceCopy}{RelationToSourceCopy}} \{\};}
\DoxyCodeLine{1087 }
\DoxyCodeLine{1088 \textcolor{comment}{// Adapts a native array to a read-\/only STL-\/style container.  Instead}}
\DoxyCodeLine{1089 \textcolor{comment}{// of the complete STL container concept, this adaptor only implements}}
\DoxyCodeLine{1090 \textcolor{comment}{// members useful for Google Mock's container matchers.  New members}}
\DoxyCodeLine{1091 \textcolor{comment}{// should be added as needed.  To simplify the implementation, we only}}
\DoxyCodeLine{1092 \textcolor{comment}{// support Element being a raw type (i.e. having no top-\/level const or}}
\DoxyCodeLine{1093 \textcolor{comment}{// reference modifier).  It's the client's responsibility to satisfy}}
\DoxyCodeLine{1094 \textcolor{comment}{// this requirement.  Element can be an array type itself (hence}}
\DoxyCodeLine{1095 \textcolor{comment}{// multi-\/dimensional arrays are supported).}}
\DoxyCodeLine{1096 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Element>}
\DoxyCodeLine{1097 \textcolor{keyword}{class }\mbox{\hyperlink{classtesting_1_1internal_1_1NativeArray}{NativeArray}} \{}
\DoxyCodeLine{1098  \textcolor{keyword}{public}:}
\DoxyCodeLine{1099   \textcolor{comment}{// STL-\/style container typedefs.}}
\DoxyCodeLine{1100   \textcolor{keyword}{typedef} Element value\_type;}
\DoxyCodeLine{1101   \textcolor{keyword}{typedef} Element* iterator;}
\DoxyCodeLine{1102   \textcolor{keyword}{typedef} \textcolor{keyword}{const} Element* const\_iterator;}
\DoxyCodeLine{1103 }
\DoxyCodeLine{1104   \textcolor{comment}{// Constructs from a native array. References the source.}}
\DoxyCodeLine{1105   \mbox{\hyperlink{classtesting_1_1internal_1_1NativeArray}{NativeArray}}(\textcolor{keyword}{const} Element* array, \textcolor{keywordtype}{size\_t} count, \mbox{\hyperlink{structtesting_1_1internal_1_1RelationToSourceReference}{RelationToSourceReference}}) \{}
\DoxyCodeLine{1106     InitRef(array, count);}
\DoxyCodeLine{1107   \}}
\DoxyCodeLine{1108 }
\DoxyCodeLine{1109   \textcolor{comment}{// Constructs from a native array. Copies the source.}}
\DoxyCodeLine{1110   \mbox{\hyperlink{classtesting_1_1internal_1_1NativeArray}{NativeArray}}(\textcolor{keyword}{const} Element* array, \textcolor{keywordtype}{size\_t} count, \mbox{\hyperlink{structtesting_1_1internal_1_1RelationToSourceCopy}{RelationToSourceCopy}}) \{}
\DoxyCodeLine{1111     InitCopy(array, count);}
\DoxyCodeLine{1112   \}}
\DoxyCodeLine{1113 }
\DoxyCodeLine{1114   \textcolor{comment}{// Copy constructor.}}
\DoxyCodeLine{1115   \mbox{\hyperlink{classtesting_1_1internal_1_1NativeArray}{NativeArray}}(\textcolor{keyword}{const} \mbox{\hyperlink{classtesting_1_1internal_1_1NativeArray}{NativeArray}}\& rhs) \{}
\DoxyCodeLine{1116     (this-\/>*rhs.clone\_)(rhs.array\_, rhs.size\_);}
\DoxyCodeLine{1117   \}}
\DoxyCodeLine{1118 }
\DoxyCodeLine{1119   \mbox{\hyperlink{classtesting_1_1internal_1_1NativeArray}{\string~NativeArray}}() \{}
\DoxyCodeLine{1120     \textcolor{keywordflow}{if} (clone\_ != \&NativeArray::InitRef) \textcolor{keyword}{delete}[] array\_;}
\DoxyCodeLine{1121   \}}
\DoxyCodeLine{1122 }
\DoxyCodeLine{1123   \textcolor{comment}{// STL-\/style container methods.}}
\DoxyCodeLine{1124   \textcolor{keywordtype}{size\_t} size()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} size\_; \}}
\DoxyCodeLine{1125   const\_iterator begin()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} array\_; \}}
\DoxyCodeLine{1126   const\_iterator end()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} array\_ + size\_; \}}
\DoxyCodeLine{1127   \textcolor{keywordtype}{bool} operator==(\textcolor{keyword}{const} \mbox{\hyperlink{classtesting_1_1internal_1_1NativeArray}{NativeArray}}\& rhs)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{1128     \textcolor{keywordflow}{return} size() == rhs.size() \&\& ArrayEq(begin(), size(), rhs.begin());}
\DoxyCodeLine{1129   \}}
\DoxyCodeLine{1130 }
\DoxyCodeLine{1131  \textcolor{keyword}{private}:}
\DoxyCodeLine{1132   \textcolor{keyword}{static\_assert}(!std::is\_const<Element>::value, \textcolor{stringliteral}{"{}Type must not be const"{}});}
\DoxyCodeLine{1133   \textcolor{keyword}{static\_assert}(!std::is\_reference<Element>::value,}
\DoxyCodeLine{1134                 \textcolor{stringliteral}{"{}Type must not be a reference"{}});}
\DoxyCodeLine{1135 }
\DoxyCodeLine{1136   \textcolor{comment}{// Initializes this object with a copy of the input.}}
\DoxyCodeLine{1137   \textcolor{keywordtype}{void} InitCopy(\textcolor{keyword}{const} Element* array, \textcolor{keywordtype}{size\_t} a\_size) \{}
\DoxyCodeLine{1138     Element* \textcolor{keyword}{const} copy = \textcolor{keyword}{new} Element[a\_size];}
\DoxyCodeLine{1139     CopyArray(array, a\_size, copy);}
\DoxyCodeLine{1140     array\_ = copy;}
\DoxyCodeLine{1141     size\_ = a\_size;}
\DoxyCodeLine{1142     clone\_ = \&NativeArray::InitCopy;}
\DoxyCodeLine{1143   \}}
\DoxyCodeLine{1144 }
\DoxyCodeLine{1145   \textcolor{comment}{// Initializes this object with a reference of the input.}}
\DoxyCodeLine{1146   \textcolor{keywordtype}{void} InitRef(\textcolor{keyword}{const} Element* array, \textcolor{keywordtype}{size\_t} a\_size) \{}
\DoxyCodeLine{1147     array\_ = array;}
\DoxyCodeLine{1148     size\_ = a\_size;}
\DoxyCodeLine{1149     clone\_ = \&NativeArray::InitRef;}
\DoxyCodeLine{1150   \}}
\DoxyCodeLine{1151 }
\DoxyCodeLine{1152   \textcolor{keyword}{const} Element* array\_;}
\DoxyCodeLine{1153   \textcolor{keywordtype}{size\_t} size\_;}
\DoxyCodeLine{1154   void (\mbox{\hyperlink{classtesting_1_1internal_1_1NativeArray}{NativeArray}}::*clone\_)(\textcolor{keyword}{const} Element*, size\_t);}
\DoxyCodeLine{1155 \};}
\DoxyCodeLine{1156 }
\DoxyCodeLine{1157 \textcolor{comment}{// Backport of std::index\_sequence.}}
\DoxyCodeLine{1158 \textcolor{keyword}{template} <\textcolor{keywordtype}{size\_t}... Is>}
\DoxyCodeLine{1159 \textcolor{keyword}{struct }\mbox{\hyperlink{structtesting_1_1internal_1_1IndexSequence}{IndexSequence}} \{}
\DoxyCodeLine{1160   \textcolor{keyword}{using }\mbox{\hyperlink{structtesting_1_1internal_1_1IndexSequence}{type}} = \mbox{\hyperlink{structtesting_1_1internal_1_1IndexSequence}{IndexSequence}};}
\DoxyCodeLine{1161 \};}
\DoxyCodeLine{1162 }
\DoxyCodeLine{1163 \textcolor{comment}{// Double the IndexSequence, and one if plus\_one is true.}}
\DoxyCodeLine{1164 \textcolor{keyword}{template} <\textcolor{keywordtype}{bool} plus\_one, \textcolor{keyword}{typename} T, \textcolor{keywordtype}{size\_t} sizeofT>}
\DoxyCodeLine{1165 \textcolor{keyword}{struct }\mbox{\hyperlink{structtesting_1_1internal_1_1DoubleSequence}{DoubleSequence}};}
\DoxyCodeLine{1166 \textcolor{keyword}{template} <\textcolor{keywordtype}{size\_t}... I, \textcolor{keywordtype}{size\_t} sizeofT>}
\DoxyCodeLine{1167 \textcolor{keyword}{struct }\mbox{\hyperlink{structtesting_1_1internal_1_1DoubleSequence}{DoubleSequence}}<true, \mbox{\hyperlink{structtesting_1_1internal_1_1IndexSequence}{IndexSequence}}<I...>, sizeofT> \{}
\DoxyCodeLine{1168   \textcolor{keyword}{using }\mbox{\hyperlink{structtesting_1_1internal_1_1IndexSequence}{type}} = \mbox{\hyperlink{structtesting_1_1internal_1_1IndexSequence}{IndexSequence}}<I..., (sizeofT + I)..., 2 * sizeofT>;}
\DoxyCodeLine{1169 \};}
\DoxyCodeLine{1170 \textcolor{keyword}{template} <\textcolor{keywordtype}{size\_t}... I, \textcolor{keywordtype}{size\_t} sizeofT>}
\DoxyCodeLine{1171 \textcolor{keyword}{struct }\mbox{\hyperlink{structtesting_1_1internal_1_1DoubleSequence}{DoubleSequence}}<false, \mbox{\hyperlink{structtesting_1_1internal_1_1IndexSequence}{IndexSequence}}<I...>, sizeofT> \{}
\DoxyCodeLine{1172   \textcolor{keyword}{using }\mbox{\hyperlink{structtesting_1_1internal_1_1IndexSequence}{type}} = \mbox{\hyperlink{structtesting_1_1internal_1_1IndexSequence}{IndexSequence}}<I..., (sizeofT + I)...>;}
\DoxyCodeLine{1173 \};}
\DoxyCodeLine{1174 }
\DoxyCodeLine{1175 \textcolor{comment}{// Backport of std::make\_index\_sequence.}}
\DoxyCodeLine{1176 \textcolor{comment}{// It uses O(ln(N)) instantiation depth.}}
\DoxyCodeLine{1177 \textcolor{keyword}{template} <\textcolor{keywordtype}{size\_t} N>}
\DoxyCodeLine{1178 \textcolor{keyword}{struct }\mbox{\hyperlink{structtesting_1_1internal_1_1MakeIndexSequenceImpl}{MakeIndexSequenceImpl}}}
\DoxyCodeLine{1179     : \mbox{\hyperlink{structtesting_1_1internal_1_1DoubleSequence}{DoubleSequence}}<N \% 2 == 1, typename MakeIndexSequenceImpl<N / 2>::type,}
\DoxyCodeLine{1180                      N / 2>::type \{\};}
\DoxyCodeLine{1181 }
\DoxyCodeLine{1182 \textcolor{keyword}{template} <>}
\DoxyCodeLine{1183 \textcolor{keyword}{struct }\mbox{\hyperlink{structtesting_1_1internal_1_1MakeIndexSequenceImpl}{MakeIndexSequenceImpl}}<0> : \mbox{\hyperlink{structtesting_1_1internal_1_1IndexSequence}{IndexSequence}}<> \{\};}
\DoxyCodeLine{1184 }
\DoxyCodeLine{1185 \textcolor{keyword}{template} <\textcolor{keywordtype}{size\_t} N>}
\DoxyCodeLine{1186 \textcolor{keyword}{using }MakeIndexSequence = \textcolor{keyword}{typename} \mbox{\hyperlink{structtesting_1_1internal_1_1MakeIndexSequenceImpl}{MakeIndexSequenceImpl<N>::type}};}
\DoxyCodeLine{1187 }
\DoxyCodeLine{1188 \textcolor{keyword}{template} <\textcolor{keyword}{typename}... T>}
\DoxyCodeLine{1189 \textcolor{keyword}{using }IndexSequenceFor = \textcolor{keyword}{typename} MakeIndexSequence<\textcolor{keyword}{sizeof}...(T)>::type;}
\DoxyCodeLine{1190 }
\DoxyCodeLine{1191 \textcolor{keyword}{template} <\textcolor{keywordtype}{size\_t}>}
\DoxyCodeLine{1192 \textcolor{keyword}{struct }\mbox{\hyperlink{structtesting_1_1internal_1_1Ignore}{Ignore}} \{}
\DoxyCodeLine{1193   \mbox{\hyperlink{structtesting_1_1internal_1_1Ignore}{Ignore}}(...);  \textcolor{comment}{// NOLINT}}
\DoxyCodeLine{1194 \};}
\DoxyCodeLine{1195 }
\DoxyCodeLine{1196 \textcolor{keyword}{template} <\textcolor{keyword}{typename}>}
\DoxyCodeLine{1197 \textcolor{keyword}{struct }\mbox{\hyperlink{structtesting_1_1internal_1_1ElemFromListImpl}{ElemFromListImpl}};}
\DoxyCodeLine{1198 \textcolor{keyword}{template} <\textcolor{keywordtype}{size\_t}... I>}
\DoxyCodeLine{1199 \textcolor{keyword}{struct }\mbox{\hyperlink{structtesting_1_1internal_1_1ElemFromListImpl}{ElemFromListImpl}}<\mbox{\hyperlink{structtesting_1_1internal_1_1IndexSequence}{IndexSequence}}<I...>> \{}
\DoxyCodeLine{1200   \textcolor{comment}{// We make Ignore a template to solve a problem with MSVC.}}
\DoxyCodeLine{1201   \textcolor{comment}{// A non-\/template Ignore would work fine with `decltype(Ignore(I))...`, but}}
\DoxyCodeLine{1202   \textcolor{comment}{// MSVC doesn't understand how to deal with that pack expansion.}}
\DoxyCodeLine{1203   \textcolor{comment}{// Use `0 * I` to have a single instantiation of Ignore.}}
\DoxyCodeLine{1204   \textcolor{keyword}{template} <\textcolor{keyword}{typename} R>}
\DoxyCodeLine{1205   \textcolor{keyword}{static} R Apply(\mbox{\hyperlink{structtesting_1_1internal_1_1Ignore}{Ignore<0 * I>}}..., R (*)(), ...);}
\DoxyCodeLine{1206 \};}
\DoxyCodeLine{1207 }
\DoxyCodeLine{1208 \textcolor{keyword}{template} <\textcolor{keywordtype}{size\_t} N, \textcolor{keyword}{typename}... T>}
\DoxyCodeLine{1209 \textcolor{keyword}{struct }\mbox{\hyperlink{structtesting_1_1internal_1_1ElemFromList}{ElemFromList}} \{}
\DoxyCodeLine{1210   \textcolor{keyword}{using }type =}
\DoxyCodeLine{1211       \textcolor{keyword}{decltype}(\mbox{\hyperlink{structtesting_1_1internal_1_1ElemFromListImpl}{ElemFromListImpl<typename MakeIndexSequence<N>::type}}>::Apply(}
\DoxyCodeLine{1212           \textcolor{keyword}{static\_cast<}T (*)()\textcolor{keyword}{>}(\textcolor{keyword}{nullptr})...));}
\DoxyCodeLine{1213 \};}
\DoxyCodeLine{1214 }
\DoxyCodeLine{1215 \textcolor{keyword}{struct }\mbox{\hyperlink{structtesting_1_1internal_1_1FlatTupleConstructTag}{FlatTupleConstructTag}} \{\};}
\DoxyCodeLine{1216 }
\DoxyCodeLine{1217 \textcolor{keyword}{template} <\textcolor{keyword}{typename}... T>}
\DoxyCodeLine{1218 \textcolor{keyword}{class }\mbox{\hyperlink{classtesting_1_1internal_1_1FlatTuple}{FlatTuple}};}
\DoxyCodeLine{1219 }
\DoxyCodeLine{1220 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Derived, \textcolor{keywordtype}{size\_t} I>}
\DoxyCodeLine{1221 \textcolor{keyword}{struct }\mbox{\hyperlink{structtesting_1_1internal_1_1FlatTupleElemBase}{FlatTupleElemBase}};}
\DoxyCodeLine{1222 }
\DoxyCodeLine{1223 \textcolor{keyword}{template} <\textcolor{keyword}{typename}... T, \textcolor{keywordtype}{size\_t} I>}
\DoxyCodeLine{1224 \textcolor{keyword}{struct }\mbox{\hyperlink{structtesting_1_1internal_1_1FlatTupleElemBase}{FlatTupleElemBase}}<\mbox{\hyperlink{classtesting_1_1internal_1_1FlatTuple}{FlatTuple}}<T...>, I> \{}
\DoxyCodeLine{1225   \textcolor{keyword}{using }value\_type = \textcolor{keyword}{typename} \mbox{\hyperlink{structtesting_1_1internal_1_1ElemFromList}{ElemFromList}}<I, T...>::type;}
\DoxyCodeLine{1226   \mbox{\hyperlink{structtesting_1_1internal_1_1FlatTupleElemBase}{FlatTupleElemBase}}() = \textcolor{keywordflow}{default};}
\DoxyCodeLine{1227   \textcolor{keyword}{template} <\textcolor{keyword}{typename} Arg>}
\DoxyCodeLine{1228   \textcolor{keyword}{explicit} \mbox{\hyperlink{structtesting_1_1internal_1_1FlatTupleElemBase}{FlatTupleElemBase}}(\mbox{\hyperlink{structtesting_1_1internal_1_1FlatTupleConstructTag}{FlatTupleConstructTag}}, Arg\&\& t)}
\DoxyCodeLine{1229       : value(std::forward<Arg>(t)) \{\}}
\DoxyCodeLine{1230   value\_type value;}
\DoxyCodeLine{1231 \};}
\DoxyCodeLine{1232 }
\DoxyCodeLine{1233 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Derived, \textcolor{keyword}{typename} Idx>}
\DoxyCodeLine{1234 \textcolor{keyword}{struct }\mbox{\hyperlink{structtesting_1_1internal_1_1FlatTupleBase}{FlatTupleBase}};}
\DoxyCodeLine{1235 }
\DoxyCodeLine{1236 \textcolor{keyword}{template} <\textcolor{keywordtype}{size\_t}... Idx, \textcolor{keyword}{typename}... T>}
\DoxyCodeLine{1237 \textcolor{keyword}{struct }\mbox{\hyperlink{structtesting_1_1internal_1_1FlatTupleBase}{FlatTupleBase}}<\mbox{\hyperlink{classtesting_1_1internal_1_1FlatTuple}{FlatTuple}}<T...>, \mbox{\hyperlink{structtesting_1_1internal_1_1IndexSequence}{IndexSequence}}<Idx...>>}
\DoxyCodeLine{1238     : \mbox{\hyperlink{structtesting_1_1internal_1_1FlatTupleElemBase}{FlatTupleElemBase}}<FlatTuple<T...>, Idx>... \{}
\DoxyCodeLine{1239   \textcolor{keyword}{using }\mbox{\hyperlink{structtesting_1_1internal_1_1IndexSequence}{Indices}} = \mbox{\hyperlink{structtesting_1_1internal_1_1IndexSequence}{IndexSequence}}<Idx...>;}
\DoxyCodeLine{1240   \mbox{\hyperlink{structtesting_1_1internal_1_1FlatTupleBase}{FlatTupleBase}}() = \textcolor{keywordflow}{default};}
\DoxyCodeLine{1241   \textcolor{keyword}{template} <\textcolor{keyword}{typename}... Args>}
\DoxyCodeLine{1242   \textcolor{keyword}{explicit} \mbox{\hyperlink{structtesting_1_1internal_1_1FlatTupleBase}{FlatTupleBase}}(\mbox{\hyperlink{structtesting_1_1internal_1_1FlatTupleConstructTag}{FlatTupleConstructTag}}, Args\&\&... args)}
\DoxyCodeLine{1243       : \mbox{\hyperlink{structtesting_1_1internal_1_1FlatTupleElemBase}{FlatTupleElemBase}}<\mbox{\hyperlink{classtesting_1_1internal_1_1FlatTuple}{FlatTuple}}<T...>, Idx>(\mbox{\hyperlink{structtesting_1_1internal_1_1FlatTupleConstructTag}{FlatTupleConstructTag}}\{\},}
\DoxyCodeLine{1244                                                 std::forward<Args>(args))... \{\}}
\DoxyCodeLine{1245 }
\DoxyCodeLine{1246   \textcolor{keyword}{template} <\textcolor{keywordtype}{size\_t} I>}
\DoxyCodeLine{1247   \textcolor{keyword}{const} \textcolor{keyword}{typename} \mbox{\hyperlink{structtesting_1_1internal_1_1ElemFromList}{ElemFromList}}<I, T...>::type\& Get()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{1248     \textcolor{keywordflow}{return} \mbox{\hyperlink{structtesting_1_1internal_1_1FlatTupleElemBase}{FlatTupleElemBase}}<\mbox{\hyperlink{classtesting_1_1internal_1_1FlatTuple}{FlatTuple}}<T...>, I>::value;}
\DoxyCodeLine{1249   \}}
\DoxyCodeLine{1250 }
\DoxyCodeLine{1251   \textcolor{keyword}{template} <\textcolor{keywordtype}{size\_t} I>}
\DoxyCodeLine{1252   \textcolor{keyword}{typename} \mbox{\hyperlink{structtesting_1_1internal_1_1ElemFromList}{ElemFromList}}<I, T...>::type\& Get() \{}
\DoxyCodeLine{1253     \textcolor{keywordflow}{return} \mbox{\hyperlink{structtesting_1_1internal_1_1FlatTupleElemBase}{FlatTupleElemBase}}<\mbox{\hyperlink{classtesting_1_1internal_1_1FlatTuple}{FlatTuple}}<T...>, I>::value;}
\DoxyCodeLine{1254   \}}
\DoxyCodeLine{1255 }
\DoxyCodeLine{1256   \textcolor{keyword}{template} <\textcolor{keyword}{typename} F>}
\DoxyCodeLine{1257   \textcolor{keyword}{auto} Apply(F\&\& f) -\/> \textcolor{keyword}{decltype}(std::forward<F>(f)(this-\/>Get<Idx>()...)) \{}
\DoxyCodeLine{1258     \textcolor{keywordflow}{return} std::forward<F>(f)(Get<Idx>()...);}
\DoxyCodeLine{1259   \}}
\DoxyCodeLine{1260 }
\DoxyCodeLine{1261   \textcolor{keyword}{template} <\textcolor{keyword}{typename} F>}
\DoxyCodeLine{1262   \textcolor{keyword}{auto} Apply(F\&\& f) \textcolor{keyword}{const} -\/> \textcolor{keyword}{decltype}(std::forward<F>(f)(this-\/>Get<Idx>()...)) \{}
\DoxyCodeLine{1263     \textcolor{keywordflow}{return} std::forward<F>(f)(Get<Idx>()...);}
\DoxyCodeLine{1264   \}}
\DoxyCodeLine{1265 \};}
\DoxyCodeLine{1266 }
\DoxyCodeLine{1267 \textcolor{comment}{// Analog to std::tuple but with different tradeoffs.}}
\DoxyCodeLine{1268 \textcolor{comment}{// This class minimizes the template instantiation depth, thus allowing more}}
\DoxyCodeLine{1269 \textcolor{comment}{// elements than std::tuple would. std::tuple has been seen to require an}}
\DoxyCodeLine{1270 \textcolor{comment}{// instantiation depth of more than 10x the number of elements in some}}
\DoxyCodeLine{1271 \textcolor{comment}{// implementations.}}
\DoxyCodeLine{1272 \textcolor{comment}{// FlatTuple and ElemFromList are not recursive and have a fixed depth}}
\DoxyCodeLine{1273 \textcolor{comment}{// regardless of T...}}
\DoxyCodeLine{1274 \textcolor{comment}{// MakeIndexSequence, on the other hand, it is recursive but with an}}
\DoxyCodeLine{1275 \textcolor{comment}{// instantiation depth of O(ln(N)).}}
\DoxyCodeLine{1276 \textcolor{keyword}{template} <\textcolor{keyword}{typename}... T>}
\DoxyCodeLine{1277 \textcolor{keyword}{class }\mbox{\hyperlink{classtesting_1_1internal_1_1FlatTuple}{FlatTuple}}}
\DoxyCodeLine{1278     : \textcolor{keyword}{private} \mbox{\hyperlink{structtesting_1_1internal_1_1FlatTupleBase}{FlatTupleBase}}<FlatTuple<T...>,}
\DoxyCodeLine{1279                             typename MakeIndexSequence<sizeof...(T)>::type> \{}
\DoxyCodeLine{1280   \textcolor{keyword}{using }Indices = \textcolor{keyword}{typename} \mbox{\hyperlink{structtesting_1_1internal_1_1FlatTupleBase}{FlatTupleBase}}<}
\DoxyCodeLine{1281       \mbox{\hyperlink{classtesting_1_1internal_1_1FlatTuple}{FlatTuple}}<T...>, \textcolor{keyword}{typename} MakeIndexSequence<\textcolor{keyword}{sizeof}...(T)>::type>::Indices;}
\DoxyCodeLine{1282 }
\DoxyCodeLine{1283  \textcolor{keyword}{public}:}
\DoxyCodeLine{1284   \mbox{\hyperlink{classtesting_1_1internal_1_1FlatTuple}{FlatTuple}}() = \textcolor{keywordflow}{default};}
\DoxyCodeLine{1285   \textcolor{keyword}{template} <\textcolor{keyword}{typename}... Args>}
\DoxyCodeLine{1286   \textcolor{keyword}{explicit} \mbox{\hyperlink{classtesting_1_1internal_1_1FlatTuple}{FlatTuple}}(\mbox{\hyperlink{structtesting_1_1internal_1_1FlatTupleConstructTag}{FlatTupleConstructTag}} tag, Args\&\&... args)}
\DoxyCodeLine{1287       : FlatTuple::FlatTupleBase(tag, std::forward<Args>(args)...) \{\}}
\DoxyCodeLine{1288 }
\DoxyCodeLine{1289   \textcolor{keyword}{using }FlatTuple::FlatTupleBase::Apply;}
\DoxyCodeLine{1290   \textcolor{keyword}{using }FlatTuple::FlatTupleBase::Get;}
\DoxyCodeLine{1291 \};}
\DoxyCodeLine{1292 }
\DoxyCodeLine{1293 \textcolor{comment}{// Utility functions to be called with static\_assert to induce deprecation}}
\DoxyCodeLine{1294 \textcolor{comment}{// warnings.}}
\DoxyCodeLine{1295 GTEST\_INTERNAL\_DEPRECATED(}
\DoxyCodeLine{1296     \textcolor{stringliteral}{"{}INSTANTIATE\_TEST\_CASE\_P is deprecated, please use "{}}}
\DoxyCodeLine{1297     \textcolor{stringliteral}{"{}INSTANTIATE\_TEST\_SUITE\_P"{}})}
\DoxyCodeLine{1298 constexpr \textcolor{keywordtype}{bool} InstantiateTestCase\_P\_IsDeprecated() \{ \textcolor{keywordflow}{return} \textcolor{keyword}{true}; \}}
\DoxyCodeLine{1299 }
\DoxyCodeLine{1300 GTEST\_INTERNAL\_DEPRECATED(}
\DoxyCodeLine{1301     \textcolor{stringliteral}{"{}TYPED\_TEST\_CASE\_P is deprecated, please use "{}}}
\DoxyCodeLine{1302     \textcolor{stringliteral}{"{}TYPED\_TEST\_SUITE\_P"{}})}
\DoxyCodeLine{1303 constexpr \textcolor{keywordtype}{bool} TypedTestCase\_P\_IsDeprecated() \{ \textcolor{keywordflow}{return} \textcolor{keyword}{true}; \}}
\DoxyCodeLine{1304 }
\DoxyCodeLine{1305 GTEST\_INTERNAL\_DEPRECATED(}
\DoxyCodeLine{1306     \textcolor{stringliteral}{"{}TYPED\_TEST\_CASE is deprecated, please use "{}}}
\DoxyCodeLine{1307     \textcolor{stringliteral}{"{}TYPED\_TEST\_SUITE"{}})}
\DoxyCodeLine{1308 constexpr \textcolor{keywordtype}{bool} TypedTestCaseIsDeprecated() \{ \textcolor{keywordflow}{return} \textcolor{keyword}{true}; \}}
\DoxyCodeLine{1309 }
\DoxyCodeLine{1310 GTEST\_INTERNAL\_DEPRECATED(}
\DoxyCodeLine{1311     \textcolor{stringliteral}{"{}REGISTER\_TYPED\_TEST\_CASE\_P is deprecated, please use "{}}}
\DoxyCodeLine{1312     \textcolor{stringliteral}{"{}REGISTER\_TYPED\_TEST\_SUITE\_P"{}})}
\DoxyCodeLine{1313 constexpr \textcolor{keywordtype}{bool} RegisterTypedTestCase\_P\_IsDeprecated() \{ \textcolor{keywordflow}{return} \textcolor{keyword}{true}; \}}
\DoxyCodeLine{1314 }
\DoxyCodeLine{1315 GTEST\_INTERNAL\_DEPRECATED(}
\DoxyCodeLine{1316     \textcolor{stringliteral}{"{}INSTANTIATE\_TYPED\_TEST\_CASE\_P is deprecated, please use "{}}}
\DoxyCodeLine{1317     \textcolor{stringliteral}{"{}INSTANTIATE\_TYPED\_TEST\_SUITE\_P"{}})}
\DoxyCodeLine{1318 constexpr \textcolor{keywordtype}{bool} InstantiateTypedTestCase\_P\_IsDeprecated() \{ \textcolor{keywordflow}{return} \textcolor{keyword}{true}; \}}
\DoxyCodeLine{1319 }
\DoxyCodeLine{1320 \}  \textcolor{comment}{// namespace internal}}
\DoxyCodeLine{1321 \}  \textcolor{comment}{// namespace testing}}
\DoxyCodeLine{1322 }
\DoxyCodeLine{1323 \textcolor{keyword}{namespace }std \{}
\DoxyCodeLine{1324 \textcolor{comment}{// Some standard library implementations use `struct tuple\_size` and some use}}
\DoxyCodeLine{1325 \textcolor{comment}{// `class tuple\_size`. Clang warns about the mismatch.}}
\DoxyCodeLine{1326 \textcolor{comment}{// https://reviews.llvm.org/D55466}}
\DoxyCodeLine{1327 \textcolor{preprocessor}{\#ifdef \_\_clang\_\_}}
\DoxyCodeLine{1328 \textcolor{preprocessor}{\#pragma clang diagnostic push}}
\DoxyCodeLine{1329 \textcolor{preprocessor}{\#pragma clang diagnostic ignored "{}-\/Wmismatched-\/tags"{}}}
\DoxyCodeLine{1330 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{1331 \textcolor{keyword}{template} <\textcolor{keyword}{typename}... Ts>}
\DoxyCodeLine{1332 \textcolor{keyword}{struct }tuple\_size<testing::internal::FlatTuple<Ts...>>}
\DoxyCodeLine{1333     : std::integral\_constant<size\_t, sizeof...(Ts)> \{\};}
\DoxyCodeLine{1334 \textcolor{preprocessor}{\#ifdef \_\_clang\_\_}}
\DoxyCodeLine{1335 \textcolor{preprocessor}{\#pragma clang diagnostic pop}}
\DoxyCodeLine{1336 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{1337 \}  \textcolor{comment}{// namespace std}}
\DoxyCodeLine{1338 }
\DoxyCodeLine{1339 \textcolor{preprocessor}{\#define GTEST\_MESSAGE\_AT\_(file, line, message, result\_type)             \(\backslash\)}}
\DoxyCodeLine{1340 \textcolor{preprocessor}{  ::testing::internal::AssertHelper(result\_type, file, line, message) = \(\backslash\)}}
\DoxyCodeLine{1341 \textcolor{preprocessor}{      ::testing::Message()}}
\DoxyCodeLine{1342 }
\DoxyCodeLine{1343 \textcolor{preprocessor}{\#define GTEST\_MESSAGE\_(message, result\_type) \(\backslash\)}}
\DoxyCodeLine{1344 \textcolor{preprocessor}{  GTEST\_MESSAGE\_AT\_(\_\_FILE\_\_, \_\_LINE\_\_, message, result\_type)}}
\DoxyCodeLine{1345 }
\DoxyCodeLine{1346 \textcolor{preprocessor}{\#define GTEST\_FATAL\_FAILURE\_(message) \(\backslash\)}}
\DoxyCodeLine{1347 \textcolor{preprocessor}{  return GTEST\_MESSAGE\_(message, ::testing::TestPartResult::kFatalFailure)}}
\DoxyCodeLine{1348 }
\DoxyCodeLine{1349 \textcolor{preprocessor}{\#define GTEST\_NONFATAL\_FAILURE\_(message) \(\backslash\)}}
\DoxyCodeLine{1350 \textcolor{preprocessor}{  GTEST\_MESSAGE\_(message, ::testing::TestPartResult::kNonFatalFailure)}}
\DoxyCodeLine{1351 }
\DoxyCodeLine{1352 \textcolor{preprocessor}{\#define GTEST\_SUCCESS\_(message) \(\backslash\)}}
\DoxyCodeLine{1353 \textcolor{preprocessor}{  GTEST\_MESSAGE\_(message, ::testing::TestPartResult::kSuccess)}}
\DoxyCodeLine{1354 }
\DoxyCodeLine{1355 \textcolor{preprocessor}{\#define GTEST\_SKIP\_(message) \(\backslash\)}}
\DoxyCodeLine{1356 \textcolor{preprocessor}{  return GTEST\_MESSAGE\_(message, ::testing::TestPartResult::kSkip)}}
\DoxyCodeLine{1357 }
\DoxyCodeLine{1358 \textcolor{comment}{// Suppress MSVC warning 4072 (unreachable code) for the code following}}
\DoxyCodeLine{1359 \textcolor{comment}{// statement if it returns or throws (or doesn't return or throw in some}}
\DoxyCodeLine{1360 \textcolor{comment}{// situations).}}
\DoxyCodeLine{1361 \textcolor{comment}{// NOTE: The "{}else"{} is important to keep this expansion to prevent a top-\/level}}
\DoxyCodeLine{1362 \textcolor{comment}{// "{}else"{} from attaching to our "{}if"{}.}}
\DoxyCodeLine{1363 \textcolor{preprocessor}{\#define GTEST\_SUPPRESS\_UNREACHABLE\_CODE\_WARNING\_BELOW\_(statement) \(\backslash\)}}
\DoxyCodeLine{1364 \textcolor{preprocessor}{  if (::testing::internal::AlwaysTrue()) \{                        \(\backslash\)}}
\DoxyCodeLine{1365 \textcolor{preprocessor}{    statement;                                                    \(\backslash\)}}
\DoxyCodeLine{1366 \textcolor{preprocessor}{  \} else                     }\textcolor{comment}{/* NOLINT */}\textcolor{preprocessor}{                         \(\backslash\)}}
\DoxyCodeLine{1367 \textcolor{preprocessor}{    static\_assert(true, "{}"{}})  \textcolor{comment}{// User must have a semicolon after expansion.}}
\DoxyCodeLine{1368 }
\DoxyCodeLine{1369 \textcolor{preprocessor}{\#if GTEST\_HAS\_EXCEPTIONS}}
\DoxyCodeLine{1370 }
\DoxyCodeLine{1371 \textcolor{keyword}{namespace }testing \{}
\DoxyCodeLine{1372 \textcolor{keyword}{namespace }internal \{}
\DoxyCodeLine{1373 }
\DoxyCodeLine{1374 \textcolor{keyword}{class }NeverThrown \{}
\DoxyCodeLine{1375  \textcolor{keyword}{public}:}
\DoxyCodeLine{1376   \textcolor{keyword}{const} \textcolor{keywordtype}{char}* what() const noexcept \{}
\DoxyCodeLine{1377     \textcolor{keywordflow}{return} \textcolor{stringliteral}{"{}this exception should never be thrown"{}};}
\DoxyCodeLine{1378   \}}
\DoxyCodeLine{1379 \};}
\DoxyCodeLine{1380 }
\DoxyCodeLine{1381 \}  \textcolor{comment}{// namespace internal}}
\DoxyCodeLine{1382 \}  \textcolor{comment}{// namespace testing}}
\DoxyCodeLine{1383 }
\DoxyCodeLine{1384 \textcolor{preprocessor}{\#if GTEST\_HAS\_RTTI}}
\DoxyCodeLine{1385 }
\DoxyCodeLine{1386 \textcolor{preprocessor}{\#define GTEST\_EXCEPTION\_TYPE\_(e) ::testing::internal::GetTypeName(typeid(e))}}
\DoxyCodeLine{1387 }
\DoxyCodeLine{1388 \textcolor{preprocessor}{\#else  }\textcolor{comment}{// GTEST\_HAS\_RTTI}}
\DoxyCodeLine{1389 }
\DoxyCodeLine{1390 \textcolor{preprocessor}{\#define GTEST\_EXCEPTION\_TYPE\_(e) \(\backslash\)}}
\DoxyCodeLine{1391 \textcolor{preprocessor}{  std::string \{ "{}an std::exception-\/derived error"{}} \}}
\DoxyCodeLine{1392 }
\DoxyCodeLine{1393 \textcolor{preprocessor}{\#endif  }\textcolor{comment}{// GTEST\_HAS\_RTTI}}
\DoxyCodeLine{1394 }
\DoxyCodeLine{1395 \textcolor{preprocessor}{\#define GTEST\_TEST\_THROW\_CATCH\_STD\_EXCEPTION\_(statement, expected\_exception)   \(\backslash\)}}
\DoxyCodeLine{1396 \textcolor{preprocessor}{  catch (typename std::conditional<                                            \(\backslash\)}}
\DoxyCodeLine{1397 \textcolor{preprocessor}{         std::is\_same<typename std::remove\_cv<typename std::remove\_reference<  \(\backslash\)}}
\DoxyCodeLine{1398 \textcolor{preprocessor}{                          expected\_exception>::type>::type,                    \(\backslash\)}}
\DoxyCodeLine{1399 \textcolor{preprocessor}{                      std::exception>::value,                                  \(\backslash\)}}
\DoxyCodeLine{1400 \textcolor{preprocessor}{         const ::testing::internal::NeverThrown\&, const std::exception\&>::type \(\backslash\)}}
\DoxyCodeLine{1401 \textcolor{preprocessor}{             e) \{                                                              \(\backslash\)}}
\DoxyCodeLine{1402 \textcolor{preprocessor}{    gtest\_msg.value = "{}Expected: "{}} \#statement                                  \(\backslash\)}
\DoxyCodeLine{1403                       "{} throws an exception of type "{} \#expected\_exception      \(\backslash\)}
\DoxyCodeLine{1404                       "{}.\(\backslash\)n  Actual: it throws "{};                               \(\backslash\)}
\DoxyCodeLine{1405     gtest\_msg.value += GTEST\_EXCEPTION\_TYPE\_(e);                               \(\backslash\)}
\DoxyCodeLine{1406     gtest\_msg.value += "{} with description \(\backslash\)"{}"{};                                 \(\backslash\)}
\DoxyCodeLine{1407     gtest\_msg.value += e.what();                                               \(\backslash\)}
\DoxyCodeLine{1408     gtest\_msg.value += "{}\(\backslash\)"{}."{};                                                  \(\backslash\)}
\DoxyCodeLine{1409     goto GTEST\_CONCAT\_TOKEN\_(gtest\_label\_testthrow\_, \_\_LINE\_\_);                \(\backslash\)}
\DoxyCodeLine{1410   \}}
\DoxyCodeLine{1411 }
\DoxyCodeLine{1412 \textcolor{preprocessor}{\#else  }\textcolor{comment}{// GTEST\_HAS\_EXCEPTIONS}}
\DoxyCodeLine{1413 }
\DoxyCodeLine{1414 \textcolor{preprocessor}{\#define GTEST\_TEST\_THROW\_CATCH\_STD\_EXCEPTION\_(statement, expected\_exception)}}
\DoxyCodeLine{1415 }
\DoxyCodeLine{1416 \textcolor{preprocessor}{\#endif  }\textcolor{comment}{// GTEST\_HAS\_EXCEPTIONS}}
\DoxyCodeLine{1417 }
\DoxyCodeLine{1418 \textcolor{preprocessor}{\#define GTEST\_TEST\_THROW\_(statement, expected\_exception, fail)              \(\backslash\)}}
\DoxyCodeLine{1419 \textcolor{preprocessor}{  GTEST\_AMBIGUOUS\_ELSE\_BLOCKER\_                                             \(\backslash\)}}
\DoxyCodeLine{1420 \textcolor{preprocessor}{  if (::testing::internal::TrueWithString gtest\_msg\{\}) \{                    \(\backslash\)}}
\DoxyCodeLine{1421 \textcolor{preprocessor}{    bool gtest\_caught\_expected = false;                                     \(\backslash\)}}
\DoxyCodeLine{1422 \textcolor{preprocessor}{    try \{                                                                   \(\backslash\)}}
\DoxyCodeLine{1423 \textcolor{preprocessor}{      GTEST\_SUPPRESS\_UNREACHABLE\_CODE\_WARNING\_BELOW\_(statement);            \(\backslash\)}}
\DoxyCodeLine{1424 \textcolor{preprocessor}{    \} catch (expected\_exception const\&) \{                                   \(\backslash\)}}
\DoxyCodeLine{1425 \textcolor{preprocessor}{      gtest\_caught\_expected = true;                                         \(\backslash\)}}
\DoxyCodeLine{1426 \textcolor{preprocessor}{    \}                                                                       \(\backslash\)}}
\DoxyCodeLine{1427 \textcolor{preprocessor}{    GTEST\_TEST\_THROW\_CATCH\_STD\_EXCEPTION\_(statement, expected\_exception)    \(\backslash\)}}
\DoxyCodeLine{1428 \textcolor{preprocessor}{    catch (...) \{                                                           \(\backslash\)}}
\DoxyCodeLine{1429 \textcolor{preprocessor}{      gtest\_msg.value = "{}Expected: "{}} \#statement                             \(\backslash\)}
\DoxyCodeLine{1430                         "{} throws an exception of type "{} \#expected\_exception \(\backslash\)}
\DoxyCodeLine{1431                         "{}.\(\backslash\)n  Actual: it throws a different type."{};         \(\backslash\)}
\DoxyCodeLine{1432       goto GTEST\_CONCAT\_TOKEN\_(gtest\_label\_testthrow\_, \_\_LINE\_\_);           \(\backslash\)}
\DoxyCodeLine{1433     \}                                                                       \(\backslash\)}
\DoxyCodeLine{1434     if (!gtest\_caught\_expected) \{                                           \(\backslash\)}
\DoxyCodeLine{1435       gtest\_msg.value = "{}Expected: "{} \#statement                             \(\backslash\)}
\DoxyCodeLine{1436                         "{} throws an exception of type "{} \#expected\_exception \(\backslash\)}
\DoxyCodeLine{1437                         "{}.\(\backslash\)n  Actual: it throws nothing."{};                  \(\backslash\)}
\DoxyCodeLine{1438       goto GTEST\_CONCAT\_TOKEN\_(gtest\_label\_testthrow\_, \_\_LINE\_\_);           \(\backslash\)}
\DoxyCodeLine{1439     \}                                                                       \(\backslash\)}
\DoxyCodeLine{1440   \} else \textcolor{comment}{/*NOLINT*/}\textcolor{preprocessor}{                                                         \(\backslash\)}}
\DoxyCodeLine{1441 \textcolor{preprocessor}{    GTEST\_CONCAT\_TOKEN\_(gtest\_label\_testthrow\_, \_\_LINE\_\_)                   \(\backslash\)}}
\DoxyCodeLine{1442 \textcolor{preprocessor}{        : fail(gtest\_msg.value.c\_str())}}
\DoxyCodeLine{1443 }
\DoxyCodeLine{1444 \textcolor{preprocessor}{\#if GTEST\_HAS\_EXCEPTIONS}}
\DoxyCodeLine{1445 }
\DoxyCodeLine{1446 \textcolor{preprocessor}{\#define GTEST\_TEST\_NO\_THROW\_CATCH\_STD\_EXCEPTION\_()                \(\backslash\)}}
\DoxyCodeLine{1447 \textcolor{preprocessor}{  catch (std::exception const\& e) \{                               \(\backslash\)}}
\DoxyCodeLine{1448 \textcolor{preprocessor}{    gtest\_msg.value = "{}it throws "{}};                               \(\backslash\)}
\DoxyCodeLine{1449     gtest\_msg.value += GTEST\_EXCEPTION\_TYPE\_(e);                  \(\backslash\)}
\DoxyCodeLine{1450     gtest\_msg.value += "{} with description \(\backslash\)"{}"{};                    \(\backslash\)}
\DoxyCodeLine{1451     gtest\_msg.value += e.what();                                  \(\backslash\)}
\DoxyCodeLine{1452     gtest\_msg.value += "{}\(\backslash\)"{}."{};                                     \(\backslash\)}
\DoxyCodeLine{1453     goto GTEST\_CONCAT\_TOKEN\_(gtest\_label\_testnothrow\_, \_\_LINE\_\_); \(\backslash\)}
\DoxyCodeLine{1454   \}}
\DoxyCodeLine{1455 }
\DoxyCodeLine{1456 \textcolor{preprocessor}{\#else  }\textcolor{comment}{// GTEST\_HAS\_EXCEPTIONS}}
\DoxyCodeLine{1457 }
\DoxyCodeLine{1458 \textcolor{preprocessor}{\#define GTEST\_TEST\_NO\_THROW\_CATCH\_STD\_EXCEPTION\_()}}
\DoxyCodeLine{1459 }
\DoxyCodeLine{1460 \textcolor{preprocessor}{\#endif  }\textcolor{comment}{// GTEST\_HAS\_EXCEPTIONS}}
\DoxyCodeLine{1461 }
\DoxyCodeLine{1462 \textcolor{preprocessor}{\#define GTEST\_TEST\_NO\_THROW\_(statement, fail)                            \(\backslash\)}}
\DoxyCodeLine{1463 \textcolor{preprocessor}{  GTEST\_AMBIGUOUS\_ELSE\_BLOCKER\_                                          \(\backslash\)}}
\DoxyCodeLine{1464 \textcolor{preprocessor}{  if (::testing::internal::TrueWithString gtest\_msg\{\}) \{                 \(\backslash\)}}
\DoxyCodeLine{1465 \textcolor{preprocessor}{    try \{                                                                \(\backslash\)}}
\DoxyCodeLine{1466 \textcolor{preprocessor}{      GTEST\_SUPPRESS\_UNREACHABLE\_CODE\_WARNING\_BELOW\_(statement);         \(\backslash\)}}
\DoxyCodeLine{1467 \textcolor{preprocessor}{    \}                                                                    \(\backslash\)}}
\DoxyCodeLine{1468 \textcolor{preprocessor}{    GTEST\_TEST\_NO\_THROW\_CATCH\_STD\_EXCEPTION\_()                           \(\backslash\)}}
\DoxyCodeLine{1469 \textcolor{preprocessor}{    catch (...) \{                                                        \(\backslash\)}}
\DoxyCodeLine{1470 \textcolor{preprocessor}{      gtest\_msg.value = "{}it throws."{}};                                    \(\backslash\)}
\DoxyCodeLine{1471       goto GTEST\_CONCAT\_TOKEN\_(gtest\_label\_testnothrow\_, \_\_LINE\_\_);      \(\backslash\)}
\DoxyCodeLine{1472     \}                                                                    \(\backslash\)}
\DoxyCodeLine{1473   \} else                                                                 \(\backslash\)}
\DoxyCodeLine{1474     GTEST\_CONCAT\_TOKEN\_(gtest\_label\_testnothrow\_, \_\_LINE\_\_)              \(\backslash\)}
\DoxyCodeLine{1475         : fail(("{}Expected: "{} \#statement "{} doesn't throw an exception.\(\backslash\)n"{} \(\backslash\)}
\DoxyCodeLine{1476                 "{}  Actual: "{} +                                           \(\backslash\)}
\DoxyCodeLine{1477                 gtest\_msg.value)                                         \(\backslash\)}
\DoxyCodeLine{1478                    .c\_str())}
\DoxyCodeLine{1479 }
\DoxyCodeLine{1480 \textcolor{preprocessor}{\#define GTEST\_TEST\_ANY\_THROW\_(statement, fail)                       \(\backslash\)}}
\DoxyCodeLine{1481 \textcolor{preprocessor}{  GTEST\_AMBIGUOUS\_ELSE\_BLOCKER\_                                      \(\backslash\)}}
\DoxyCodeLine{1482 \textcolor{preprocessor}{  if (::testing::internal::AlwaysTrue()) \{                           \(\backslash\)}}
\DoxyCodeLine{1483 \textcolor{preprocessor}{    bool gtest\_caught\_any = false;                                   \(\backslash\)}}
\DoxyCodeLine{1484 \textcolor{preprocessor}{    try \{                                                            \(\backslash\)}}
\DoxyCodeLine{1485 \textcolor{preprocessor}{      GTEST\_SUPPRESS\_UNREACHABLE\_CODE\_WARNING\_BELOW\_(statement);     \(\backslash\)}}
\DoxyCodeLine{1486 \textcolor{preprocessor}{    \} catch (...) \{                                                  \(\backslash\)}}
\DoxyCodeLine{1487 \textcolor{preprocessor}{      gtest\_caught\_any = true;                                       \(\backslash\)}}
\DoxyCodeLine{1488 \textcolor{preprocessor}{    \}                                                                \(\backslash\)}}
\DoxyCodeLine{1489 \textcolor{preprocessor}{    if (!gtest\_caught\_any) \{                                         \(\backslash\)}}
\DoxyCodeLine{1490 \textcolor{preprocessor}{      goto GTEST\_CONCAT\_TOKEN\_(gtest\_label\_testanythrow\_, \_\_LINE\_\_); \(\backslash\)}}
\DoxyCodeLine{1491 \textcolor{preprocessor}{    \}                                                                \(\backslash\)}}
\DoxyCodeLine{1492 \textcolor{preprocessor}{  \} else                                                             \(\backslash\)}}
\DoxyCodeLine{1493 \textcolor{preprocessor}{    GTEST\_CONCAT\_TOKEN\_(gtest\_label\_testanythrow\_, \_\_LINE\_\_)         \(\backslash\)}}
\DoxyCodeLine{1494 \textcolor{preprocessor}{        : fail("{}Expected: "{}} \#statement                               \(\backslash\)}
\DoxyCodeLine{1495                "{} throws an exception.\(\backslash\)n"{}                             \(\backslash\)}
\DoxyCodeLine{1496                "{}  Actual: it doesn't."{})}
\DoxyCodeLine{1497 }
\DoxyCodeLine{1498 \textcolor{comment}{// Implements Boolean test assertions such as EXPECT\_TRUE. expression can be}}
\DoxyCodeLine{1499 \textcolor{comment}{// either a boolean expression or an AssertionResult. text is a textual}}
\DoxyCodeLine{1500 \textcolor{comment}{// representation of expression as it was passed into the EXPECT\_TRUE.}}
\DoxyCodeLine{1501 \textcolor{preprocessor}{\#define GTEST\_TEST\_BOOLEAN\_(expression, text, actual, expected, fail) \(\backslash\)}}
\DoxyCodeLine{1502 \textcolor{preprocessor}{  GTEST\_AMBIGUOUS\_ELSE\_BLOCKER\_                                       \(\backslash\)}}
\DoxyCodeLine{1503 \textcolor{preprocessor}{  if (const ::testing::AssertionResult gtest\_ar\_ =                    \(\backslash\)}}
\DoxyCodeLine{1504 \textcolor{preprocessor}{          ::testing::AssertionResult(expression))                     \(\backslash\)}}
\DoxyCodeLine{1505 \textcolor{preprocessor}{    ;                                                                 \(\backslash\)}}
\DoxyCodeLine{1506 \textcolor{preprocessor}{  else                                                                \(\backslash\)}}
\DoxyCodeLine{1507 \textcolor{preprocessor}{    fail(::testing::internal::GetBoolAssertionFailureMessage(         \(\backslash\)}}
\DoxyCodeLine{1508 \textcolor{preprocessor}{             gtest\_ar\_, text, \#actual, \#expected)                     \(\backslash\)}}
\DoxyCodeLine{1509 \textcolor{preprocessor}{             .c\_str())}}
\DoxyCodeLine{1510 }
\DoxyCodeLine{1511 \textcolor{preprocessor}{\#define GTEST\_TEST\_NO\_FATAL\_FAILURE\_(statement, fail)                          \(\backslash\)}}
\DoxyCodeLine{1512 \textcolor{preprocessor}{  GTEST\_AMBIGUOUS\_ELSE\_BLOCKER\_                                                \(\backslash\)}}
\DoxyCodeLine{1513 \textcolor{preprocessor}{  if (::testing::internal::AlwaysTrue()) \{                                     \(\backslash\)}}
\DoxyCodeLine{1514 \textcolor{preprocessor}{    ::testing::internal::HasNewFatalFailureHelper gtest\_fatal\_failure\_checker; \(\backslash\)}}
\DoxyCodeLine{1515 \textcolor{preprocessor}{    GTEST\_SUPPRESS\_UNREACHABLE\_CODE\_WARNING\_BELOW\_(statement);                 \(\backslash\)}}
\DoxyCodeLine{1516 \textcolor{preprocessor}{    if (gtest\_fatal\_failure\_checker.has\_new\_fatal\_failure()) \{                 \(\backslash\)}}
\DoxyCodeLine{1517 \textcolor{preprocessor}{      goto GTEST\_CONCAT\_TOKEN\_(gtest\_label\_testnofatal\_, \_\_LINE\_\_);            \(\backslash\)}}
\DoxyCodeLine{1518 \textcolor{preprocessor}{    \}                                                                          \(\backslash\)}}
\DoxyCodeLine{1519 \textcolor{preprocessor}{  \} else                                                                       \(\backslash\)}}
\DoxyCodeLine{1520 \textcolor{preprocessor}{    GTEST\_CONCAT\_TOKEN\_(gtest\_label\_testnofatal\_, \_\_LINE\_\_)                    \(\backslash\)}}
\DoxyCodeLine{1521 \textcolor{preprocessor}{        : fail("{}Expected: "{}} \#statement                                         \(\backslash\)}
\DoxyCodeLine{1522                "{} doesn't generate new fatal "{}                                  \(\backslash\)}
\DoxyCodeLine{1523                "{}failures in the current thread.\(\backslash\)n"{}                             \(\backslash\)}
\DoxyCodeLine{1524                "{}  Actual: it does."{})}
\DoxyCodeLine{1525 }
\DoxyCodeLine{1526 \textcolor{comment}{// Expands to the name of the class that implements the given test.}}
\DoxyCodeLine{1527 \textcolor{preprocessor}{\#define GTEST\_TEST\_CLASS\_NAME\_(test\_suite\_name, test\_name) \(\backslash\)}}
\DoxyCodeLine{1528 \textcolor{preprocessor}{  test\_suite\_name\#\#\_\#\#test\_name\#\#\_Test}}
\DoxyCodeLine{1529 }
\DoxyCodeLine{1530 \textcolor{comment}{// Helper macro for defining tests.}}
\DoxyCodeLine{1531 \textcolor{preprocessor}{\#define GTEST\_TEST\_(test\_suite\_name, test\_name, parent\_class, parent\_id)       \(\backslash\)}}
\DoxyCodeLine{1532 \textcolor{preprocessor}{  static\_assert(sizeof(GTEST\_STRINGIFY\_(test\_suite\_name)) > 1,                 \(\backslash\)}}
\DoxyCodeLine{1533 \textcolor{preprocessor}{                "{}test\_suite\_name must not be empty"{}});                          \(\backslash\)}
\DoxyCodeLine{1534   static\_assert(sizeof(GTEST\_STRINGIFY\_(test\_name)) > 1,                       \(\backslash\)}
\DoxyCodeLine{1535                 "{}test\_name must not be empty"{});                                \(\backslash\)}
\DoxyCodeLine{1536   class GTEST\_TEST\_CLASS\_NAME\_(test\_suite\_name, test\_name)                     \(\backslash\)}
\DoxyCodeLine{1537       : public parent\_class \{                                                  \(\backslash\)}
\DoxyCodeLine{1538    public:                                                                     \(\backslash\)}
\DoxyCodeLine{1539     GTEST\_TEST\_CLASS\_NAME\_(test\_suite\_name, test\_name)() = default;            \(\backslash\)}
\DoxyCodeLine{1540     \string~GTEST\_TEST\_CLASS\_NAME\_(test\_suite\_name, test\_name)() override = default;  \(\backslash\)}
\DoxyCodeLine{1541     GTEST\_TEST\_CLASS\_NAME\_(test\_suite\_name, test\_name)                         \(\backslash\)}
\DoxyCodeLine{1542     (const GTEST\_TEST\_CLASS\_NAME\_(test\_suite\_name, test\_name) \&) = delete;     \(\backslash\)}
\DoxyCodeLine{1543     GTEST\_TEST\_CLASS\_NAME\_(test\_suite\_name, test\_name) \& operator=(            \(\backslash\)}
\DoxyCodeLine{1544         const GTEST\_TEST\_CLASS\_NAME\_(test\_suite\_name,                          \(\backslash\)}
\DoxyCodeLine{1545                                      test\_name) \&) = delete; \textcolor{comment}{/* NOLINT */}\textcolor{preprocessor}{      \(\backslash\)}}
\DoxyCodeLine{1546 \textcolor{preprocessor}{    GTEST\_TEST\_CLASS\_NAME\_(test\_suite\_name, test\_name)                         \(\backslash\)}}
\DoxyCodeLine{1547 \textcolor{preprocessor}{    (GTEST\_TEST\_CLASS\_NAME\_(test\_suite\_name, test\_name) \&\&) noexcept = delete; \(\backslash\)}}
\DoxyCodeLine{1548 \textcolor{preprocessor}{    GTEST\_TEST\_CLASS\_NAME\_(test\_suite\_name, test\_name) \& operator=(            \(\backslash\)}}
\DoxyCodeLine{1549 \textcolor{preprocessor}{        GTEST\_TEST\_CLASS\_NAME\_(test\_suite\_name,                                \(\backslash\)}}
\DoxyCodeLine{1550 \textcolor{preprocessor}{                               test\_name) \&\&) noexcept = delete; }\textcolor{comment}{/* NOLINT */}\textcolor{preprocessor}{  \(\backslash\)}}
\DoxyCodeLine{1551 \textcolor{preprocessor}{                                                                               \(\backslash\)}}
\DoxyCodeLine{1552 \textcolor{preprocessor}{   private:                                                                    \(\backslash\)}}
\DoxyCodeLine{1553 \textcolor{preprocessor}{    void TestBody() override;                                                  \(\backslash\)}}
\DoxyCodeLine{1554 \textcolor{preprocessor}{    static ::testing::TestInfo* const test\_info\_ GTEST\_ATTRIBUTE\_UNUSED\_;      \(\backslash\)}}
\DoxyCodeLine{1555 \textcolor{preprocessor}{  \};                                                                           \(\backslash\)}}
\DoxyCodeLine{1556 \textcolor{preprocessor}{                                                                               \(\backslash\)}}
\DoxyCodeLine{1557 \textcolor{preprocessor}{  ::testing::TestInfo* const GTEST\_TEST\_CLASS\_NAME\_(test\_suite\_name,           \(\backslash\)}}
\DoxyCodeLine{1558 \textcolor{preprocessor}{                                                    test\_name)::test\_info\_ =   \(\backslash\)}}
\DoxyCodeLine{1559 \textcolor{preprocessor}{      ::testing::internal::MakeAndRegisterTestInfo(                            \(\backslash\)}}
\DoxyCodeLine{1560 \textcolor{preprocessor}{          \#test\_suite\_name, \#test\_name, nullptr, nullptr,                      \(\backslash\)}}
\DoxyCodeLine{1561 \textcolor{preprocessor}{          ::testing::internal::CodeLocation(\_\_FILE\_\_, \_\_LINE\_\_), (parent\_id),  \(\backslash\)}}
\DoxyCodeLine{1562 \textcolor{preprocessor}{          ::testing::internal::SuiteApiResolver<                               \(\backslash\)}}
\DoxyCodeLine{1563 \textcolor{preprocessor}{              parent\_class>::GetSetUpCaseOrSuite(\_\_FILE\_\_, \_\_LINE\_\_),          \(\backslash\)}}
\DoxyCodeLine{1564 \textcolor{preprocessor}{          ::testing::internal::SuiteApiResolver<                               \(\backslash\)}}
\DoxyCodeLine{1565 \textcolor{preprocessor}{              parent\_class>::GetTearDownCaseOrSuite(\_\_FILE\_\_, \_\_LINE\_\_),       \(\backslash\)}}
\DoxyCodeLine{1566 \textcolor{preprocessor}{          new ::testing::internal::TestFactoryImpl<GTEST\_TEST\_CLASS\_NAME\_(     \(\backslash\)}}
\DoxyCodeLine{1567 \textcolor{preprocessor}{              test\_suite\_name, test\_name)>);                                   \(\backslash\)}}
\DoxyCodeLine{1568 \textcolor{preprocessor}{  void GTEST\_TEST\_CLASS\_NAME\_(test\_suite\_name, test\_name)::TestBody()}}
\DoxyCodeLine{1569 }
\DoxyCodeLine{1570 \textcolor{preprocessor}{\#endif  }\textcolor{comment}{// GOOGLETEST\_INCLUDE\_GTEST\_INTERNAL\_GTEST\_INTERNAL\_H\_}}

\end{DoxyCode}
