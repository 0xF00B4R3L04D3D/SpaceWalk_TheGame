\hypertarget{gtest-type-util_8h_source}{}\doxysection{gtest-\/type-\/util.h}
\label{gtest-type-util_8h_source}\index{build/\_deps/googletest-\/src/googletest/include/gtest/internal/gtest-\/type-\/util.h@{build/\_deps/googletest-\/src/googletest/include/gtest/internal/gtest-\/type-\/util.h}}

\begin{DoxyCode}{0}
\DoxyCodeLine{1 \textcolor{comment}{// Copyright 2008 Google Inc.}}
\DoxyCodeLine{2 \textcolor{comment}{// All Rights Reserved.}}
\DoxyCodeLine{3 \textcolor{comment}{//}}
\DoxyCodeLine{4 \textcolor{comment}{// Redistribution and use in source and binary forms, with or without}}
\DoxyCodeLine{5 \textcolor{comment}{// modification, are permitted provided that the following conditions are}}
\DoxyCodeLine{6 \textcolor{comment}{// met:}}
\DoxyCodeLine{7 \textcolor{comment}{//}}
\DoxyCodeLine{8 \textcolor{comment}{//     * Redistributions of source code must retain the above copyright}}
\DoxyCodeLine{9 \textcolor{comment}{// notice, this list of conditions and the following disclaimer.}}
\DoxyCodeLine{10 \textcolor{comment}{//     * Redistributions in binary form must reproduce the above}}
\DoxyCodeLine{11 \textcolor{comment}{// copyright notice, this list of conditions and the following disclaimer}}
\DoxyCodeLine{12 \textcolor{comment}{// in the documentation and/or other materials provided with the}}
\DoxyCodeLine{13 \textcolor{comment}{// distribution.}}
\DoxyCodeLine{14 \textcolor{comment}{//     * Neither the name of Google Inc. nor the names of its}}
\DoxyCodeLine{15 \textcolor{comment}{// contributors may be used to endorse or promote products derived from}}
\DoxyCodeLine{16 \textcolor{comment}{// this software without specific prior written permission.}}
\DoxyCodeLine{17 \textcolor{comment}{//}}
\DoxyCodeLine{18 \textcolor{comment}{// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS}}
\DoxyCodeLine{19 \textcolor{comment}{// "{}AS IS"{} AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT}}
\DoxyCodeLine{20 \textcolor{comment}{// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR}}
\DoxyCodeLine{21 \textcolor{comment}{// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT}}
\DoxyCodeLine{22 \textcolor{comment}{// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,}}
\DoxyCodeLine{23 \textcolor{comment}{// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT}}
\DoxyCodeLine{24 \textcolor{comment}{// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,}}
\DoxyCodeLine{25 \textcolor{comment}{// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY}}
\DoxyCodeLine{26 \textcolor{comment}{// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT}}
\DoxyCodeLine{27 \textcolor{comment}{// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE}}
\DoxyCodeLine{28 \textcolor{comment}{// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.}}
\DoxyCodeLine{29 }
\DoxyCodeLine{30 \textcolor{comment}{// Type utilities needed for implementing typed and type-\/parameterized}}
\DoxyCodeLine{31 \textcolor{comment}{// tests.}}
\DoxyCodeLine{32 }
\DoxyCodeLine{33 \textcolor{comment}{// IWYU pragma: private, include "{}gtest/gtest.h"{}}}
\DoxyCodeLine{34 \textcolor{comment}{// IWYU pragma: friend gtest/.*}}
\DoxyCodeLine{35 \textcolor{comment}{// IWYU pragma: friend gmock/.*}}
\DoxyCodeLine{36 }
\DoxyCodeLine{37 \textcolor{preprocessor}{\#ifndef GOOGLETEST\_INCLUDE\_GTEST\_INTERNAL\_GTEST\_TYPE\_UTIL\_H\_}}
\DoxyCodeLine{38 \textcolor{preprocessor}{\#define GOOGLETEST\_INCLUDE\_GTEST\_INTERNAL\_GTEST\_TYPE\_UTIL\_H\_}}
\DoxyCodeLine{39 }
\DoxyCodeLine{40 \textcolor{preprocessor}{\#include "{}gtest/internal/gtest-\/port.h"{}}}
\DoxyCodeLine{41 }
\DoxyCodeLine{42 \textcolor{comment}{// \#ifdef \_\_GNUC\_\_ is too general here.  It is possible to use gcc without using}}
\DoxyCodeLine{43 \textcolor{comment}{// libstdc++ (which is where cxxabi.h comes from).}}
\DoxyCodeLine{44 \textcolor{preprocessor}{\#if GTEST\_HAS\_CXXABI\_H\_}}
\DoxyCodeLine{45 \textcolor{preprocessor}{\#include <cxxabi.h>}}
\DoxyCodeLine{46 \textcolor{preprocessor}{\#elif defined(\_\_HP\_aCC)}}
\DoxyCodeLine{47 \textcolor{preprocessor}{\#include <acxx\_demangle.h>}}
\DoxyCodeLine{48 \textcolor{preprocessor}{\#endif  }\textcolor{comment}{// GTEST\_HASH\_CXXABI\_H\_}}
\DoxyCodeLine{49 }
\DoxyCodeLine{50 \textcolor{keyword}{namespace }testing \{}
\DoxyCodeLine{51 \textcolor{keyword}{namespace }internal \{}
\DoxyCodeLine{52 }
\DoxyCodeLine{53 \textcolor{comment}{// Canonicalizes a given name with respect to the Standard C++ Library.}}
\DoxyCodeLine{54 \textcolor{comment}{// This handles removing the inline namespace within `std` that is}}
\DoxyCodeLine{55 \textcolor{comment}{// used by various standard libraries (e.g., `std::\_\_1`).  Names outside}}
\DoxyCodeLine{56 \textcolor{comment}{// of namespace std are returned unmodified.}}
\DoxyCodeLine{57 \textcolor{keyword}{inline} std::string CanonicalizeForStdLibVersioning(std::string s) \{}
\DoxyCodeLine{58   \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{char} prefix[] = \textcolor{stringliteral}{"{}std::\_\_"{}};}
\DoxyCodeLine{59   \textcolor{keywordflow}{if} (s.compare(0, strlen(prefix), prefix) == 0) \{}
\DoxyCodeLine{60     std::string::size\_type end = s.find(\textcolor{stringliteral}{"{}::"{}}, strlen(prefix));}
\DoxyCodeLine{61     \textcolor{keywordflow}{if} (end != s.npos) \{}
\DoxyCodeLine{62       \textcolor{comment}{// Erase everything between the initial `std` and the second `::`.}}
\DoxyCodeLine{63       s.erase(strlen(\textcolor{stringliteral}{"{}std"{}}), end -\/ strlen(\textcolor{stringliteral}{"{}std"{}}));}
\DoxyCodeLine{64     \}}
\DoxyCodeLine{65   \}}
\DoxyCodeLine{66   \textcolor{keywordflow}{return} s;}
\DoxyCodeLine{67 \}}
\DoxyCodeLine{68 }
\DoxyCodeLine{69 \textcolor{preprocessor}{\#if GTEST\_HAS\_RTTI}}
\DoxyCodeLine{70 \textcolor{comment}{// GetTypeName(const std::type\_info\&) returns a human-\/readable name of type T.}}
\DoxyCodeLine{71 \textcolor{keyword}{inline} std::string GetTypeName(\textcolor{keyword}{const} std::type\_info\& type) \{}
\DoxyCodeLine{72   \textcolor{keyword}{const} \textcolor{keywordtype}{char}* \textcolor{keyword}{const} name = type.name();}
\DoxyCodeLine{73 \textcolor{preprocessor}{\#if GTEST\_HAS\_CXXABI\_H\_ || defined(\_\_HP\_aCC)}}
\DoxyCodeLine{74   \textcolor{keywordtype}{int} status = 0;}
\DoxyCodeLine{75   \textcolor{comment}{// gcc's implementation of typeid(T).name() mangles the type name,}}
\DoxyCodeLine{76   \textcolor{comment}{// so we have to demangle it.}}
\DoxyCodeLine{77 \textcolor{preprocessor}{\#if GTEST\_HAS\_CXXABI\_H\_}}
\DoxyCodeLine{78   \textcolor{keyword}{using }abi::\_\_cxa\_demangle;}
\DoxyCodeLine{79 \textcolor{preprocessor}{\#endif  }\textcolor{comment}{// GTEST\_HAS\_CXXABI\_H\_}}
\DoxyCodeLine{80   \textcolor{keywordtype}{char}* \textcolor{keyword}{const} readable\_name = \_\_cxa\_demangle(name, \textcolor{keyword}{nullptr}, \textcolor{keyword}{nullptr}, \&status);}
\DoxyCodeLine{81   \textcolor{keyword}{const} std::string name\_str(status == 0 ? readable\_name : name);}
\DoxyCodeLine{82   free(readable\_name);}
\DoxyCodeLine{83   \textcolor{keywordflow}{return} CanonicalizeForStdLibVersioning(name\_str);}
\DoxyCodeLine{84 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{85   \textcolor{keywordflow}{return} name;}
\DoxyCodeLine{86 \textcolor{preprocessor}{\#endif  }\textcolor{comment}{// GTEST\_HAS\_CXXABI\_H\_ || \_\_HP\_aCC}}
\DoxyCodeLine{87 \}}
\DoxyCodeLine{88 \textcolor{preprocessor}{\#endif  }\textcolor{comment}{// GTEST\_HAS\_RTTI}}
\DoxyCodeLine{89 }
\DoxyCodeLine{90 \textcolor{comment}{// GetTypeName<T>() returns a human-\/readable name of type T if and only if}}
\DoxyCodeLine{91 \textcolor{comment}{// RTTI is enabled, otherwise it returns a dummy type name.}}
\DoxyCodeLine{92 \textcolor{comment}{// NB: This function is also used in Google Mock, so don't move it inside of}}
\DoxyCodeLine{93 \textcolor{comment}{// the typed-\/test-\/only section below.}}
\DoxyCodeLine{94 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{95 std::string GetTypeName() \{}
\DoxyCodeLine{96 \textcolor{preprocessor}{\#if GTEST\_HAS\_RTTI}}
\DoxyCodeLine{97   \textcolor{keywordflow}{return} GetTypeName(\textcolor{keyword}{typeid}(T));}
\DoxyCodeLine{98 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{99   \textcolor{keywordflow}{return} \textcolor{stringliteral}{"{}<type>"{}};}
\DoxyCodeLine{100 \textcolor{preprocessor}{\#endif  }\textcolor{comment}{// GTEST\_HAS\_RTTI}}
\DoxyCodeLine{101 \}}
\DoxyCodeLine{102 }
\DoxyCodeLine{103 \textcolor{comment}{// A unique type indicating an empty node}}
\DoxyCodeLine{104 \textcolor{keyword}{struct }\mbox{\hyperlink{structtesting_1_1internal_1_1None}{None}} \{\};}
\DoxyCodeLine{105 }
\DoxyCodeLine{106 \textcolor{preprocessor}{\#define GTEST\_TEMPLATE\_ \(\backslash\)}}
\DoxyCodeLine{107 \textcolor{preprocessor}{  template <typename T> \(\backslash\)}}
\DoxyCodeLine{108 \textcolor{preprocessor}{  class}}
\DoxyCodeLine{109 }
\DoxyCodeLine{110 \textcolor{comment}{// The template "{}selector"{} struct TemplateSel<Tmpl> is used to}}
\DoxyCodeLine{111 \textcolor{comment}{// represent Tmpl, which must be a class template with one type}}
\DoxyCodeLine{112 \textcolor{comment}{// parameter, as a type.  TemplateSel<Tmpl>::Bind<T>::type is defined}}
\DoxyCodeLine{113 \textcolor{comment}{// as the type Tmpl<T>.  This allows us to actually instantiate the}}
\DoxyCodeLine{114 \textcolor{comment}{// template "{}selected"{} by TemplateSel<Tmpl>.}}
\DoxyCodeLine{115 \textcolor{comment}{//}}
\DoxyCodeLine{116 \textcolor{comment}{// This trick is necessary for simulating typedef for class templates,}}
\DoxyCodeLine{117 \textcolor{comment}{// which C++ doesn't support directly.}}
\DoxyCodeLine{118 \textcolor{keyword}{template} <GTEST\_TEMPLATE\_ Tmpl>}
\DoxyCodeLine{119 \textcolor{keyword}{struct }\mbox{\hyperlink{structtesting_1_1internal_1_1TemplateSel}{TemplateSel}} \{}
\DoxyCodeLine{120   \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{121   \textcolor{keyword}{struct }\mbox{\hyperlink{structtesting_1_1internal_1_1TemplateSel_1_1Bind}{Bind}} \{}
\DoxyCodeLine{122     \textcolor{keyword}{typedef} Tmpl<T> type;}
\DoxyCodeLine{123   \};}
\DoxyCodeLine{124 \};}
\DoxyCodeLine{125 }
\DoxyCodeLine{126 \textcolor{preprocessor}{\#define GTEST\_BIND\_(TmplSel, T) TmplSel::template Bind<T>::type}}
\DoxyCodeLine{127 }
\DoxyCodeLine{128 \textcolor{keyword}{template} <GTEST\_TEMPLATE\_ Head\_, GTEST\_TEMPLATE\_... Tail\_>}
\DoxyCodeLine{129 \textcolor{keyword}{struct }\mbox{\hyperlink{structtesting_1_1internal_1_1Templates}{Templates}} \{}
\DoxyCodeLine{130   \textcolor{keyword}{using }\mbox{\hyperlink{structtesting_1_1internal_1_1TemplateSel}{Head}} = \mbox{\hyperlink{structtesting_1_1internal_1_1TemplateSel}{TemplateSel<Head\_>}};}
\DoxyCodeLine{131   \textcolor{keyword}{using }\mbox{\hyperlink{structtesting_1_1internal_1_1Templates}{Tail}} = \mbox{\hyperlink{structtesting_1_1internal_1_1Templates}{Templates}}<Tail\_...>;}
\DoxyCodeLine{132 \};}
\DoxyCodeLine{133 }
\DoxyCodeLine{134 \textcolor{keyword}{template} <GTEST\_TEMPLATE\_ Head\_>}
\DoxyCodeLine{135 \textcolor{keyword}{struct }\mbox{\hyperlink{structtesting_1_1internal_1_1Templates}{Templates}}<Head\_> \{}
\DoxyCodeLine{136   \textcolor{keyword}{using }\mbox{\hyperlink{structtesting_1_1internal_1_1TemplateSel}{Head}} = \mbox{\hyperlink{structtesting_1_1internal_1_1TemplateSel}{TemplateSel<Head\_>}};}
\DoxyCodeLine{137   \textcolor{keyword}{using }\mbox{\hyperlink{structtesting_1_1internal_1_1None}{Tail}} = \mbox{\hyperlink{structtesting_1_1internal_1_1None}{None}};}
\DoxyCodeLine{138 \};}
\DoxyCodeLine{139 }
\DoxyCodeLine{140 \textcolor{comment}{// Tuple-\/like type lists}}
\DoxyCodeLine{141 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Head\_, \textcolor{keyword}{typename}... Tail\_>}
\DoxyCodeLine{142 \textcolor{keyword}{struct }\mbox{\hyperlink{structtesting_1_1internal_1_1Types}{Types}} \{}
\DoxyCodeLine{143   \textcolor{keyword}{using }Head = Head\_;}
\DoxyCodeLine{144   \textcolor{keyword}{using }\mbox{\hyperlink{structtesting_1_1internal_1_1Types}{Tail}} = \mbox{\hyperlink{structtesting_1_1internal_1_1Types}{Types}}<Tail\_...>;}
\DoxyCodeLine{145 \};}
\DoxyCodeLine{146 }
\DoxyCodeLine{147 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Head\_>}
\DoxyCodeLine{148 \textcolor{keyword}{struct }\mbox{\hyperlink{structtesting_1_1internal_1_1Types}{Types}}<Head\_> \{}
\DoxyCodeLine{149   \textcolor{keyword}{using }Head = Head\_;}
\DoxyCodeLine{150   \textcolor{keyword}{using }\mbox{\hyperlink{structtesting_1_1internal_1_1None}{Tail}} = \mbox{\hyperlink{structtesting_1_1internal_1_1None}{None}};}
\DoxyCodeLine{151 \};}
\DoxyCodeLine{152 }
\DoxyCodeLine{153 \textcolor{comment}{// Helper metafunctions to tell apart a single type from types}}
\DoxyCodeLine{154 \textcolor{comment}{// generated by ::testing::Types}}
\DoxyCodeLine{155 \textcolor{keyword}{template} <\textcolor{keyword}{typename}... Ts>}
\DoxyCodeLine{156 \textcolor{keyword}{struct }\mbox{\hyperlink{structtesting_1_1internal_1_1ProxyTypeList}{ProxyTypeList}} \{}
\DoxyCodeLine{157   \textcolor{keyword}{using }\mbox{\hyperlink{structtesting_1_1internal_1_1Types}{type}} = \mbox{\hyperlink{structtesting_1_1internal_1_1Types}{Types}}<Ts...>;}
\DoxyCodeLine{158 \};}
\DoxyCodeLine{159 }
\DoxyCodeLine{160 \textcolor{keyword}{template} <\textcolor{keyword}{typename}>}
\DoxyCodeLine{161 \textcolor{keyword}{struct }\mbox{\hyperlink{structtesting_1_1internal_1_1is__proxy__type__list}{is\_proxy\_type\_list}} : std::false\_type \{\};}
\DoxyCodeLine{162 }
\DoxyCodeLine{163 \textcolor{keyword}{template} <\textcolor{keyword}{typename}... Ts>}
\DoxyCodeLine{164 \textcolor{keyword}{struct }\mbox{\hyperlink{structtesting_1_1internal_1_1is__proxy__type__list}{is\_proxy\_type\_list}}<\mbox{\hyperlink{structtesting_1_1internal_1_1ProxyTypeList}{ProxyTypeList}}<Ts...>> : std::true\_type \{\};}
\DoxyCodeLine{165 }
\DoxyCodeLine{166 \textcolor{comment}{// Generator which conditionally creates type lists.}}
\DoxyCodeLine{167 \textcolor{comment}{// It recognizes if a requested type list should be created}}
\DoxyCodeLine{168 \textcolor{comment}{// and prevents creating a new type list nested within another one.}}
\DoxyCodeLine{169 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{170 \textcolor{keyword}{struct }\mbox{\hyperlink{structtesting_1_1internal_1_1GenerateTypeList}{GenerateTypeList}} \{}
\DoxyCodeLine{171  \textcolor{keyword}{private}:}
\DoxyCodeLine{172   \textcolor{keyword}{using }proxy = \textcolor{keyword}{typename} std::conditional<is\_proxy\_type\_list<T>::value, T,}
\DoxyCodeLine{173                                           \mbox{\hyperlink{structtesting_1_1internal_1_1ProxyTypeList}{ProxyTypeList<T>}}>::type;}
\DoxyCodeLine{174 }
\DoxyCodeLine{175  \textcolor{keyword}{public}:}
\DoxyCodeLine{176   \textcolor{keyword}{using }type = \textcolor{keyword}{typename} proxy::type;}
\DoxyCodeLine{177 \};}
\DoxyCodeLine{178 }
\DoxyCodeLine{179 \}  \textcolor{comment}{// namespace internal}}
\DoxyCodeLine{180 }
\DoxyCodeLine{181 \textcolor{keyword}{template} <\textcolor{keyword}{typename}... Ts>}
\DoxyCodeLine{182 \textcolor{keyword}{using }\mbox{\hyperlink{structtesting_1_1internal_1_1ProxyTypeList}{Types}} = \mbox{\hyperlink{structtesting_1_1internal_1_1ProxyTypeList}{internal::ProxyTypeList}}<Ts...>;}
\DoxyCodeLine{183 }
\DoxyCodeLine{184 \}  \textcolor{comment}{// namespace testing}}
\DoxyCodeLine{185 }
\DoxyCodeLine{186 \textcolor{preprocessor}{\#endif  }\textcolor{comment}{// GOOGLETEST\_INCLUDE\_GTEST\_INTERNAL\_GTEST\_TYPE\_UTIL\_H\_}}

\end{DoxyCode}
