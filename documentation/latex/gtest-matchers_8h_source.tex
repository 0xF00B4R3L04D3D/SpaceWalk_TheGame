\hypertarget{gtest-matchers_8h_source}{}\doxysection{gtest-\/matchers.h}
\label{gtest-matchers_8h_source}\index{build/\_deps/googletest-\/src/googletest/include/gtest/gtest-\/matchers.h@{build/\_deps/googletest-\/src/googletest/include/gtest/gtest-\/matchers.h}}

\begin{DoxyCode}{0}
\DoxyCodeLine{1 \textcolor{comment}{// Copyright 2007, Google Inc.}}
\DoxyCodeLine{2 \textcolor{comment}{// All rights reserved.}}
\DoxyCodeLine{3 \textcolor{comment}{//}}
\DoxyCodeLine{4 \textcolor{comment}{// Redistribution and use in source and binary forms, with or without}}
\DoxyCodeLine{5 \textcolor{comment}{// modification, are permitted provided that the following conditions are}}
\DoxyCodeLine{6 \textcolor{comment}{// met:}}
\DoxyCodeLine{7 \textcolor{comment}{//}}
\DoxyCodeLine{8 \textcolor{comment}{//     * Redistributions of source code must retain the above copyright}}
\DoxyCodeLine{9 \textcolor{comment}{// notice, this list of conditions and the following disclaimer.}}
\DoxyCodeLine{10 \textcolor{comment}{//     * Redistributions in binary form must reproduce the above}}
\DoxyCodeLine{11 \textcolor{comment}{// copyright notice, this list of conditions and the following disclaimer}}
\DoxyCodeLine{12 \textcolor{comment}{// in the documentation and/or other materials provided with the}}
\DoxyCodeLine{13 \textcolor{comment}{// distribution.}}
\DoxyCodeLine{14 \textcolor{comment}{//     * Neither the name of Google Inc. nor the names of its}}
\DoxyCodeLine{15 \textcolor{comment}{// contributors may be used to endorse or promote products derived from}}
\DoxyCodeLine{16 \textcolor{comment}{// this software without specific prior written permission.}}
\DoxyCodeLine{17 \textcolor{comment}{//}}
\DoxyCodeLine{18 \textcolor{comment}{// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS}}
\DoxyCodeLine{19 \textcolor{comment}{// "{}AS IS"{} AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT}}
\DoxyCodeLine{20 \textcolor{comment}{// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR}}
\DoxyCodeLine{21 \textcolor{comment}{// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT}}
\DoxyCodeLine{22 \textcolor{comment}{// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,}}
\DoxyCodeLine{23 \textcolor{comment}{// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT}}
\DoxyCodeLine{24 \textcolor{comment}{// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,}}
\DoxyCodeLine{25 \textcolor{comment}{// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY}}
\DoxyCodeLine{26 \textcolor{comment}{// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT}}
\DoxyCodeLine{27 \textcolor{comment}{// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE}}
\DoxyCodeLine{28 \textcolor{comment}{// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.}}
\DoxyCodeLine{29 }
\DoxyCodeLine{30 \textcolor{comment}{// The Google C++ Testing and Mocking Framework (Google Test)}}
\DoxyCodeLine{31 \textcolor{comment}{//}}
\DoxyCodeLine{32 \textcolor{comment}{// This file implements just enough of the matcher interface to allow}}
\DoxyCodeLine{33 \textcolor{comment}{// EXPECT\_DEATH and friends to accept a matcher argument.}}
\DoxyCodeLine{34 }
\DoxyCodeLine{35 \textcolor{comment}{// IWYU pragma: private, include "{}gtest/gtest.h"{}}}
\DoxyCodeLine{36 \textcolor{comment}{// IWYU pragma: friend gtest/.*}}
\DoxyCodeLine{37 \textcolor{comment}{// IWYU pragma: friend gmock/.*}}
\DoxyCodeLine{38 }
\DoxyCodeLine{39 \textcolor{preprocessor}{\#ifndef GOOGLETEST\_INCLUDE\_GTEST\_GTEST\_MATCHERS\_H\_}}
\DoxyCodeLine{40 \textcolor{preprocessor}{\#define GOOGLETEST\_INCLUDE\_GTEST\_GTEST\_MATCHERS\_H\_}}
\DoxyCodeLine{41 }
\DoxyCodeLine{42 \textcolor{preprocessor}{\#include <atomic>}}
\DoxyCodeLine{43 \textcolor{preprocessor}{\#include <memory>}}
\DoxyCodeLine{44 \textcolor{preprocessor}{\#include <ostream>}}
\DoxyCodeLine{45 \textcolor{preprocessor}{\#include <string>}}
\DoxyCodeLine{46 \textcolor{preprocessor}{\#include <type\_traits>}}
\DoxyCodeLine{47 }
\DoxyCodeLine{48 \textcolor{preprocessor}{\#include "{}gtest/gtest-\/printers.h"{}}}
\DoxyCodeLine{49 \textcolor{preprocessor}{\#include "{}gtest/internal/gtest-\/internal.h"{}}}
\DoxyCodeLine{50 \textcolor{preprocessor}{\#include "{}gtest/internal/gtest-\/port.h"{}}}
\DoxyCodeLine{51 }
\DoxyCodeLine{52 \textcolor{comment}{// MSVC warning C5046 is new as of VS2017 version 15.8.}}
\DoxyCodeLine{53 \textcolor{preprocessor}{\#if defined(\_MSC\_VER) \&\& \_MSC\_VER >= 1915}}
\DoxyCodeLine{54 \textcolor{preprocessor}{\#define GTEST\_MAYBE\_5046\_ 5046}}
\DoxyCodeLine{55 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{56 \textcolor{preprocessor}{\#define GTEST\_MAYBE\_5046\_}}
\DoxyCodeLine{57 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{58 }
\DoxyCodeLine{59 GTEST\_DISABLE\_MSC\_WARNINGS\_PUSH\_(}
\DoxyCodeLine{60     4251 GTEST\_MAYBE\_5046\_ \textcolor{comment}{/* class A needs to have dll-\/interface to be used by}}
\DoxyCodeLine{61 \textcolor{comment}{                              clients of class B */}}
\DoxyCodeLine{62     \textcolor{comment}{/* Symbol involving type with internal linkage not defined */})}
\DoxyCodeLine{63 }
\DoxyCodeLine{64 \textcolor{keyword}{namespace }testing \{}
\DoxyCodeLine{65 }
\DoxyCodeLine{66 \textcolor{comment}{// To implement a matcher Foo for type T, define:}}
\DoxyCodeLine{67 \textcolor{comment}{//   1. a class FooMatcherMatcher that implements the matcher interface:}}
\DoxyCodeLine{68 \textcolor{comment}{//     using is\_gtest\_matcher = void;}}
\DoxyCodeLine{69 \textcolor{comment}{//     bool MatchAndExplain(const T\&, std::ostream*);}}
\DoxyCodeLine{70 \textcolor{comment}{//       (MatchResultListener* can also be used instead of std::ostream*)}}
\DoxyCodeLine{71 \textcolor{comment}{//     void DescribeTo(std::ostream*);}}
\DoxyCodeLine{72 \textcolor{comment}{//     void DescribeNegationTo(std::ostream*);}}
\DoxyCodeLine{73 \textcolor{comment}{//}}
\DoxyCodeLine{74 \textcolor{comment}{//   2. a factory function that creates a Matcher<T> object from a}}
\DoxyCodeLine{75 \textcolor{comment}{//      FooMatcherMatcher.}}
\DoxyCodeLine{76 }
\DoxyCodeLine{77 \textcolor{keyword}{class }MatchResultListener \{}
\DoxyCodeLine{78  \textcolor{keyword}{public}:}
\DoxyCodeLine{79   \textcolor{comment}{// Creates a listener object with the given underlying ostream.  The}}
\DoxyCodeLine{80   \textcolor{comment}{// listener does not own the ostream, and does not dereference it}}
\DoxyCodeLine{81   \textcolor{comment}{// in the constructor or destructor.}}
\DoxyCodeLine{82   \textcolor{keyword}{explicit} MatchResultListener(::std::ostream* os) : stream\_(os) \{\}}
\DoxyCodeLine{83   \textcolor{keyword}{virtual} \string~MatchResultListener() = 0;  \textcolor{comment}{// Makes this class abstract.}}
\DoxyCodeLine{84 }
\DoxyCodeLine{85   \textcolor{comment}{// Streams x to the underlying ostream; does nothing if the ostream}}
\DoxyCodeLine{86   \textcolor{comment}{// is NULL.}}
\DoxyCodeLine{87   \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{88   MatchResultListener\& operator<<(\textcolor{keyword}{const} T\& x) \{}
\DoxyCodeLine{89     \textcolor{keywordflow}{if} (stream\_ != \textcolor{keyword}{nullptr}) *stream\_ << x;}
\DoxyCodeLine{90     \textcolor{keywordflow}{return} *\textcolor{keyword}{this};}
\DoxyCodeLine{91   \}}
\DoxyCodeLine{92 }
\DoxyCodeLine{93   \textcolor{comment}{// Returns the underlying ostream.}}
\DoxyCodeLine{94   ::std::ostream* stream() \{ \textcolor{keywordflow}{return} stream\_; \}}
\DoxyCodeLine{95 }
\DoxyCodeLine{96   \textcolor{comment}{// Returns true if and only if the listener is interested in an explanation}}
\DoxyCodeLine{97   \textcolor{comment}{// of the match result.  A matcher's MatchAndExplain() method can use}}
\DoxyCodeLine{98   \textcolor{comment}{// this information to avoid generating the explanation when no one}}
\DoxyCodeLine{99   \textcolor{comment}{// intends to hear it.}}
\DoxyCodeLine{100   \textcolor{keywordtype}{bool} IsInterested()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} stream\_ != \textcolor{keyword}{nullptr}; \}}
\DoxyCodeLine{101 }
\DoxyCodeLine{102  \textcolor{keyword}{private}:}
\DoxyCodeLine{103   ::std::ostream* \textcolor{keyword}{const} stream\_;}
\DoxyCodeLine{104 }
\DoxyCodeLine{105   MatchResultListener(\textcolor{keyword}{const} MatchResultListener\&) = \textcolor{keyword}{delete};}
\DoxyCodeLine{106   MatchResultListener\& operator=(\textcolor{keyword}{const} MatchResultListener\&) = \textcolor{keyword}{delete};}
\DoxyCodeLine{107 \};}
\DoxyCodeLine{108 }
\DoxyCodeLine{109 \textcolor{keyword}{inline} MatchResultListener::\string~MatchResultListener() \{\}}
\DoxyCodeLine{110 }
\DoxyCodeLine{111 \textcolor{comment}{// An instance of a subclass of this knows how to describe itself as a}}
\DoxyCodeLine{112 \textcolor{comment}{// matcher.}}
\DoxyCodeLine{113 \textcolor{keyword}{class }GTEST\_API\_ MatcherDescriberInterface \{}
\DoxyCodeLine{114  \textcolor{keyword}{public}:}
\DoxyCodeLine{115   \textcolor{keyword}{virtual} \string~MatcherDescriberInterface() \{\}}
\DoxyCodeLine{116 }
\DoxyCodeLine{117   \textcolor{comment}{// Describes this matcher to an ostream.  The function should print}}
\DoxyCodeLine{118   \textcolor{comment}{// a verb phrase that describes the property a value matching this}}
\DoxyCodeLine{119   \textcolor{comment}{// matcher should have.  The subject of the verb phrase is the value}}
\DoxyCodeLine{120   \textcolor{comment}{// being matched.  For example, the DescribeTo() method of the Gt(7)}}
\DoxyCodeLine{121   \textcolor{comment}{// matcher prints "{}is greater than 7"{}.}}
\DoxyCodeLine{122   \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} DescribeTo(::std::ostream* os) \textcolor{keyword}{const} = 0;}
\DoxyCodeLine{123 }
\DoxyCodeLine{124   \textcolor{comment}{// Describes the negation of this matcher to an ostream.  For}}
\DoxyCodeLine{125   \textcolor{comment}{// example, if the description of this matcher is "{}is greater than}}
\DoxyCodeLine{126   \textcolor{comment}{// 7"{}, the negated description could be "{}is not greater than 7"{}.}}
\DoxyCodeLine{127   \textcolor{comment}{// You are not required to override this when implementing}}
\DoxyCodeLine{128   \textcolor{comment}{// MatcherInterface, but it is highly advised so that your matcher}}
\DoxyCodeLine{129   \textcolor{comment}{// can produce good error messages.}}
\DoxyCodeLine{130   \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} DescribeNegationTo(::std::ostream* os)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{131     *os << \textcolor{stringliteral}{"{}not ("{}};}
\DoxyCodeLine{132     DescribeTo(os);}
\DoxyCodeLine{133     *os << \textcolor{stringliteral}{"{})"{}};}
\DoxyCodeLine{134   \}}
\DoxyCodeLine{135 \};}
\DoxyCodeLine{136 }
\DoxyCodeLine{137 \textcolor{comment}{// The implementation of a matcher.}}
\DoxyCodeLine{138 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{139 \textcolor{keyword}{class }MatcherInterface : \textcolor{keyword}{public} MatcherDescriberInterface \{}
\DoxyCodeLine{140  \textcolor{keyword}{public}:}
\DoxyCodeLine{141   \textcolor{comment}{// Returns true if and only if the matcher matches x; also explains the}}
\DoxyCodeLine{142   \textcolor{comment}{// match result to 'listener' if necessary (see the next paragraph), in}}
\DoxyCodeLine{143   \textcolor{comment}{// the form of a non-\/restrictive relative clause ("{}which ..."{},}}
\DoxyCodeLine{144   \textcolor{comment}{// "{}whose ..."{}, etc) that describes x.  For example, the}}
\DoxyCodeLine{145   \textcolor{comment}{// MatchAndExplain() method of the Pointee(...) matcher should}}
\DoxyCodeLine{146   \textcolor{comment}{// generate an explanation like "{}which points to ..."{}.}}
\DoxyCodeLine{147   \textcolor{comment}{//}}
\DoxyCodeLine{148   \textcolor{comment}{// Implementations of MatchAndExplain() should add an explanation of}}
\DoxyCodeLine{149   \textcolor{comment}{// the match result *if and only if* they can provide additional}}
\DoxyCodeLine{150   \textcolor{comment}{// information that's not already present (or not obvious) in the}}
\DoxyCodeLine{151   \textcolor{comment}{// print-\/out of x and the matcher's description.  Whether the match}}
\DoxyCodeLine{152   \textcolor{comment}{// succeeds is not a factor in deciding whether an explanation is}}
\DoxyCodeLine{153   \textcolor{comment}{// needed, as sometimes the caller needs to print a failure message}}
\DoxyCodeLine{154   \textcolor{comment}{// when the match succeeds (e.g. when the matcher is used inside}}
\DoxyCodeLine{155   \textcolor{comment}{// Not()).}}
\DoxyCodeLine{156   \textcolor{comment}{//}}
\DoxyCodeLine{157   \textcolor{comment}{// For example, a "{}has at least 10 elements"{} matcher should explain}}
\DoxyCodeLine{158   \textcolor{comment}{// what the actual element count is, regardless of the match result,}}
\DoxyCodeLine{159   \textcolor{comment}{// as it is useful information to the reader; on the other hand, an}}
\DoxyCodeLine{160   \textcolor{comment}{// "{}is empty"{} matcher probably only needs to explain what the actual}}
\DoxyCodeLine{161   \textcolor{comment}{// size is when the match fails, as it's redundant to say that the}}
\DoxyCodeLine{162   \textcolor{comment}{// size is 0 when the value is already known to be empty.}}
\DoxyCodeLine{163   \textcolor{comment}{//}}
\DoxyCodeLine{164   \textcolor{comment}{// You should override this method when defining a new matcher.}}
\DoxyCodeLine{165   \textcolor{comment}{//}}
\DoxyCodeLine{166   \textcolor{comment}{// It's the responsibility of the caller (Google Test) to guarantee}}
\DoxyCodeLine{167   \textcolor{comment}{// that 'listener' is not NULL.  This helps to simplify a matcher's}}
\DoxyCodeLine{168   \textcolor{comment}{// implementation when it doesn't care about the performance, as it}}
\DoxyCodeLine{169   \textcolor{comment}{// can talk to 'listener' without checking its validity first.}}
\DoxyCodeLine{170   \textcolor{comment}{// However, in order to implement dummy listeners efficiently,}}
\DoxyCodeLine{171   \textcolor{comment}{// listener-\/>stream() may be NULL.}}
\DoxyCodeLine{172   \textcolor{keyword}{virtual} \textcolor{keywordtype}{bool} MatchAndExplain(T x, MatchResultListener* listener) \textcolor{keyword}{const} = 0;}
\DoxyCodeLine{173 }
\DoxyCodeLine{174   \textcolor{comment}{// Inherits these methods from MatcherDescriberInterface:}}
\DoxyCodeLine{175   \textcolor{comment}{//   virtual void DescribeTo(::std::ostream* os) const = 0;}}
\DoxyCodeLine{176   \textcolor{comment}{//   virtual void DescribeNegationTo(::std::ostream* os) const;}}
\DoxyCodeLine{177 \};}
\DoxyCodeLine{178 }
\DoxyCodeLine{179 \textcolor{keyword}{namespace }internal \{}
\DoxyCodeLine{180 }
\DoxyCodeLine{181 \textcolor{keyword}{struct }AnyEq \{}
\DoxyCodeLine{182   \textcolor{keyword}{template} <\textcolor{keyword}{typename} A, \textcolor{keyword}{typename} B>}
\DoxyCodeLine{183   \textcolor{keywordtype}{bool} operator()(\textcolor{keyword}{const} A\& a, \textcolor{keyword}{const} B\& b)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{184     \textcolor{keywordflow}{return} a == b;}
\DoxyCodeLine{185   \}}
\DoxyCodeLine{186 \};}
\DoxyCodeLine{187 \textcolor{keyword}{struct }AnyNe \{}
\DoxyCodeLine{188   \textcolor{keyword}{template} <\textcolor{keyword}{typename} A, \textcolor{keyword}{typename} B>}
\DoxyCodeLine{189   \textcolor{keywordtype}{bool} operator()(\textcolor{keyword}{const} A\& a, \textcolor{keyword}{const} B\& b)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{190     \textcolor{keywordflow}{return} a != b;}
\DoxyCodeLine{191   \}}
\DoxyCodeLine{192 \};}
\DoxyCodeLine{193 \textcolor{keyword}{struct }AnyLt \{}
\DoxyCodeLine{194   \textcolor{keyword}{template} <\textcolor{keyword}{typename} A, \textcolor{keyword}{typename} B>}
\DoxyCodeLine{195   \textcolor{keywordtype}{bool} operator()(\textcolor{keyword}{const} A\& a, \textcolor{keyword}{const} B\& b)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{196     \textcolor{keywordflow}{return} a < b;}
\DoxyCodeLine{197   \}}
\DoxyCodeLine{198 \};}
\DoxyCodeLine{199 \textcolor{keyword}{struct }AnyGt \{}
\DoxyCodeLine{200   \textcolor{keyword}{template} <\textcolor{keyword}{typename} A, \textcolor{keyword}{typename} B>}
\DoxyCodeLine{201   \textcolor{keywordtype}{bool} operator()(\textcolor{keyword}{const} A\& a, \textcolor{keyword}{const} B\& b)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{202     \textcolor{keywordflow}{return} a > b;}
\DoxyCodeLine{203   \}}
\DoxyCodeLine{204 \};}
\DoxyCodeLine{205 \textcolor{keyword}{struct }AnyLe \{}
\DoxyCodeLine{206   \textcolor{keyword}{template} <\textcolor{keyword}{typename} A, \textcolor{keyword}{typename} B>}
\DoxyCodeLine{207   \textcolor{keywordtype}{bool} operator()(\textcolor{keyword}{const} A\& a, \textcolor{keyword}{const} B\& b)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{208     \textcolor{keywordflow}{return} a <= b;}
\DoxyCodeLine{209   \}}
\DoxyCodeLine{210 \};}
\DoxyCodeLine{211 \textcolor{keyword}{struct }AnyGe \{}
\DoxyCodeLine{212   \textcolor{keyword}{template} <\textcolor{keyword}{typename} A, \textcolor{keyword}{typename} B>}
\DoxyCodeLine{213   \textcolor{keywordtype}{bool} operator()(\textcolor{keyword}{const} A\& a, \textcolor{keyword}{const} B\& b)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{214     \textcolor{keywordflow}{return} a >= b;}
\DoxyCodeLine{215   \}}
\DoxyCodeLine{216 \};}
\DoxyCodeLine{217 }
\DoxyCodeLine{218 \textcolor{comment}{// A match result listener that ignores the explanation.}}
\DoxyCodeLine{219 \textcolor{keyword}{class }DummyMatchResultListener : \textcolor{keyword}{public} MatchResultListener \{}
\DoxyCodeLine{220  \textcolor{keyword}{public}:}
\DoxyCodeLine{221   DummyMatchResultListener() : MatchResultListener(nullptr) \{\}}
\DoxyCodeLine{222 }
\DoxyCodeLine{223  \textcolor{keyword}{private}:}
\DoxyCodeLine{224   DummyMatchResultListener(\textcolor{keyword}{const} DummyMatchResultListener\&) = \textcolor{keyword}{delete};}
\DoxyCodeLine{225   DummyMatchResultListener\& operator=(\textcolor{keyword}{const} DummyMatchResultListener\&) = \textcolor{keyword}{delete};}
\DoxyCodeLine{226 \};}
\DoxyCodeLine{227 }
\DoxyCodeLine{228 \textcolor{comment}{// A match result listener that forwards the explanation to a given}}
\DoxyCodeLine{229 \textcolor{comment}{// ostream.  The difference between this and MatchResultListener is}}
\DoxyCodeLine{230 \textcolor{comment}{// that the former is concrete.}}
\DoxyCodeLine{231 \textcolor{keyword}{class }StreamMatchResultListener : \textcolor{keyword}{public} MatchResultListener \{}
\DoxyCodeLine{232  \textcolor{keyword}{public}:}
\DoxyCodeLine{233   \textcolor{keyword}{explicit} StreamMatchResultListener(::std::ostream* os)}
\DoxyCodeLine{234       : MatchResultListener(os) \{\}}
\DoxyCodeLine{235 }
\DoxyCodeLine{236  \textcolor{keyword}{private}:}
\DoxyCodeLine{237   StreamMatchResultListener(\textcolor{keyword}{const} StreamMatchResultListener\&) = \textcolor{keyword}{delete};}
\DoxyCodeLine{238   StreamMatchResultListener\& operator=(\textcolor{keyword}{const} StreamMatchResultListener\&) =}
\DoxyCodeLine{239       \textcolor{keyword}{delete};}
\DoxyCodeLine{240 \};}
\DoxyCodeLine{241 }
\DoxyCodeLine{242 \textcolor{keyword}{struct }SharedPayloadBase \{}
\DoxyCodeLine{243   std::atomic<int> ref\{1\};}
\DoxyCodeLine{244   \textcolor{keywordtype}{void} Ref() \{ ref.fetch\_add(1, std::memory\_order\_relaxed); \}}
\DoxyCodeLine{245   \textcolor{keywordtype}{bool} Unref() \{ \textcolor{keywordflow}{return} ref.fetch\_sub(1, std::memory\_order\_acq\_rel) == 1; \}}
\DoxyCodeLine{246 \};}
\DoxyCodeLine{247 }
\DoxyCodeLine{248 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{249 \textcolor{keyword}{struct }SharedPayload : SharedPayloadBase \{}
\DoxyCodeLine{250   \textcolor{keyword}{explicit} SharedPayload(\textcolor{keyword}{const} T\& v) : value(v) \{\}}
\DoxyCodeLine{251   \textcolor{keyword}{explicit} SharedPayload(T\&\& v) : value(std::move(v)) \{\}}
\DoxyCodeLine{252 }
\DoxyCodeLine{253   \textcolor{keyword}{static} \textcolor{keywordtype}{void} Destroy(SharedPayloadBase* shared) \{}
\DoxyCodeLine{254     \textcolor{keyword}{delete} \textcolor{keyword}{static\_cast<}SharedPayload*\textcolor{keyword}{>}(shared);}
\DoxyCodeLine{255   \}}
\DoxyCodeLine{256 }
\DoxyCodeLine{257   T value;}
\DoxyCodeLine{258 \};}
\DoxyCodeLine{259 }
\DoxyCodeLine{260 \textcolor{comment}{// An internal class for implementing Matcher<T>, which will derive}}
\DoxyCodeLine{261 \textcolor{comment}{// from it.  We put functionalities common to all Matcher<T>}}
\DoxyCodeLine{262 \textcolor{comment}{// specializations here to avoid code duplication.}}
\DoxyCodeLine{263 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{264 \textcolor{keyword}{class }MatcherBase : \textcolor{keyword}{private} MatcherDescriberInterface \{}
\DoxyCodeLine{265  \textcolor{keyword}{public}:}
\DoxyCodeLine{266   \textcolor{comment}{// Returns true if and only if the matcher matches x; also explains the}}
\DoxyCodeLine{267   \textcolor{comment}{// match result to 'listener'.}}
\DoxyCodeLine{268   \textcolor{keywordtype}{bool} MatchAndExplain(\textcolor{keyword}{const} T\& x, MatchResultListener* listener)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{269     GTEST\_CHECK\_(vtable\_ != \textcolor{keyword}{nullptr});}
\DoxyCodeLine{270     \textcolor{keywordflow}{return} vtable\_-\/>match\_and\_explain(*\textcolor{keyword}{this}, x, listener);}
\DoxyCodeLine{271   \}}
\DoxyCodeLine{272 }
\DoxyCodeLine{273   \textcolor{comment}{// Returns true if and only if this matcher matches x.}}
\DoxyCodeLine{274   \textcolor{keywordtype}{bool} Matches(\textcolor{keyword}{const} T\& x)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{275     DummyMatchResultListener dummy;}
\DoxyCodeLine{276     \textcolor{keywordflow}{return} MatchAndExplain(x, \&dummy);}
\DoxyCodeLine{277   \}}
\DoxyCodeLine{278 }
\DoxyCodeLine{279   \textcolor{comment}{// Describes this matcher to an ostream.}}
\DoxyCodeLine{280   \textcolor{keywordtype}{void} DescribeTo(::std::ostream* os) \textcolor{keyword}{const} \textcolor{keyword}{final} \{}
\DoxyCodeLine{281     GTEST\_CHECK\_(vtable\_ != \textcolor{keyword}{nullptr});}
\DoxyCodeLine{282     vtable\_-\/>describe(*\textcolor{keyword}{this}, os, \textcolor{keyword}{false});}
\DoxyCodeLine{283   \}}
\DoxyCodeLine{284 }
\DoxyCodeLine{285   \textcolor{comment}{// Describes the negation of this matcher to an ostream.}}
\DoxyCodeLine{286   \textcolor{keywordtype}{void} DescribeNegationTo(::std::ostream* os) \textcolor{keyword}{const} \textcolor{keyword}{final} \{}
\DoxyCodeLine{287     GTEST\_CHECK\_(vtable\_ != \textcolor{keyword}{nullptr});}
\DoxyCodeLine{288     vtable\_-\/>describe(*\textcolor{keyword}{this}, os, \textcolor{keyword}{true});}
\DoxyCodeLine{289   \}}
\DoxyCodeLine{290 }
\DoxyCodeLine{291   \textcolor{comment}{// Explains why x matches, or doesn't match, the matcher.}}
\DoxyCodeLine{292   \textcolor{keywordtype}{void} ExplainMatchResultTo(\textcolor{keyword}{const} T\& x, ::std::ostream* os)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{293     StreamMatchResultListener listener(os);}
\DoxyCodeLine{294     MatchAndExplain(x, \&listener);}
\DoxyCodeLine{295   \}}
\DoxyCodeLine{296 }
\DoxyCodeLine{297   \textcolor{comment}{// Returns the describer for this matcher object; retains ownership}}
\DoxyCodeLine{298   \textcolor{comment}{// of the describer, which is only guaranteed to be alive when}}
\DoxyCodeLine{299   \textcolor{comment}{// this matcher object is alive.}}
\DoxyCodeLine{300   \textcolor{keyword}{const} MatcherDescriberInterface* GetDescriber()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{301     \textcolor{keywordflow}{if} (vtable\_ == \textcolor{keyword}{nullptr}) \textcolor{keywordflow}{return} \textcolor{keyword}{nullptr};}
\DoxyCodeLine{302     \textcolor{keywordflow}{return} vtable\_-\/>get\_describer(*\textcolor{keyword}{this});}
\DoxyCodeLine{303   \}}
\DoxyCodeLine{304 }
\DoxyCodeLine{305  \textcolor{keyword}{protected}:}
\DoxyCodeLine{306   MatcherBase() : vtable\_(nullptr), buffer\_() \{\}}
\DoxyCodeLine{307 }
\DoxyCodeLine{308   \textcolor{comment}{// Constructs a matcher from its implementation.}}
\DoxyCodeLine{309   \textcolor{keyword}{template} <\textcolor{keyword}{typename} U>}
\DoxyCodeLine{310   \textcolor{keyword}{explicit} MatcherBase(\textcolor{keyword}{const} MatcherInterface<U>* impl)}
\DoxyCodeLine{311       : vtable\_(nullptr), buffer\_() \{}
\DoxyCodeLine{312     Init(impl);}
\DoxyCodeLine{313   \}}
\DoxyCodeLine{314 }
\DoxyCodeLine{315   \textcolor{keyword}{template} <\textcolor{keyword}{typename} M, \textcolor{keyword}{typename} = \textcolor{keyword}{typename} std::remove\_reference<}
\DoxyCodeLine{316                             M>::type::is\_gtest\_matcher>}
\DoxyCodeLine{317   MatcherBase(M\&\& m) : vtable\_(nullptr), buffer\_() \{  \textcolor{comment}{// NOLINT}}
\DoxyCodeLine{318     Init(std::forward<M>(m));}
\DoxyCodeLine{319   \}}
\DoxyCodeLine{320 }
\DoxyCodeLine{321   MatcherBase(\textcolor{keyword}{const} MatcherBase\& other)}
\DoxyCodeLine{322       : vtable\_(other.vtable\_), buffer\_(other.buffer\_) \{}
\DoxyCodeLine{323     \textcolor{keywordflow}{if} (IsShared()) buffer\_.shared-\/>Ref();}
\DoxyCodeLine{324   \}}
\DoxyCodeLine{325 }
\DoxyCodeLine{326   MatcherBase\& operator=(\textcolor{keyword}{const} MatcherBase\& other) \{}
\DoxyCodeLine{327     \textcolor{keywordflow}{if} (\textcolor{keyword}{this} == \&other) \textcolor{keywordflow}{return} *\textcolor{keyword}{this};}
\DoxyCodeLine{328     Destroy();}
\DoxyCodeLine{329     vtable\_ = other.vtable\_;}
\DoxyCodeLine{330     buffer\_ = other.buffer\_;}
\DoxyCodeLine{331     \textcolor{keywordflow}{if} (IsShared()) buffer\_.shared-\/>Ref();}
\DoxyCodeLine{332     \textcolor{keywordflow}{return} *\textcolor{keyword}{this};}
\DoxyCodeLine{333   \}}
\DoxyCodeLine{334 }
\DoxyCodeLine{335   MatcherBase(MatcherBase\&\& other)}
\DoxyCodeLine{336       : vtable\_(other.vtable\_), buffer\_(other.buffer\_) \{}
\DoxyCodeLine{337     other.vtable\_ = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{338   \}}
\DoxyCodeLine{339 }
\DoxyCodeLine{340   MatcherBase\& operator=(MatcherBase\&\& other) \{}
\DoxyCodeLine{341     \textcolor{keywordflow}{if} (\textcolor{keyword}{this} == \&other) \textcolor{keywordflow}{return} *\textcolor{keyword}{this};}
\DoxyCodeLine{342     Destroy();}
\DoxyCodeLine{343     vtable\_ = other.vtable\_;}
\DoxyCodeLine{344     buffer\_ = other.buffer\_;}
\DoxyCodeLine{345     other.vtable\_ = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{346     \textcolor{keywordflow}{return} *\textcolor{keyword}{this};}
\DoxyCodeLine{347   \}}
\DoxyCodeLine{348 }
\DoxyCodeLine{349   \string~MatcherBase()\textcolor{keyword}{ override }\{ Destroy(); \}}
\DoxyCodeLine{350 }
\DoxyCodeLine{351  \textcolor{keyword}{private}:}
\DoxyCodeLine{352   \textcolor{keyword}{struct }VTable \{}
\DoxyCodeLine{353     bool (*match\_and\_explain)(\textcolor{keyword}{const} MatcherBase\&, \textcolor{keyword}{const} T\&,}
\DoxyCodeLine{354                               MatchResultListener*);}
\DoxyCodeLine{355     void (*describe)(\textcolor{keyword}{const} MatcherBase\&, std::ostream*, \textcolor{keywordtype}{bool} negation);}
\DoxyCodeLine{356     \textcolor{comment}{// Returns the captured object if it implements the interface, otherwise}}
\DoxyCodeLine{357     \textcolor{comment}{// returns the MatcherBase itself.}}
\DoxyCodeLine{358     \textcolor{keyword}{const} MatcherDescriberInterface* (*get\_describer)(\textcolor{keyword}{const} MatcherBase\&);}
\DoxyCodeLine{359     \textcolor{comment}{// Called on shared instances when the reference count reaches 0.}}
\DoxyCodeLine{360     void (*shared\_destroy)(SharedPayloadBase*);}
\DoxyCodeLine{361   \};}
\DoxyCodeLine{362 }
\DoxyCodeLine{363   \textcolor{keywordtype}{bool} IsShared()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{364     \textcolor{keywordflow}{return} vtable\_ != \textcolor{keyword}{nullptr} \&\& vtable\_-\/>shared\_destroy != \textcolor{keyword}{nullptr};}
\DoxyCodeLine{365   \}}
\DoxyCodeLine{366 }
\DoxyCodeLine{367   \textcolor{comment}{// If the implementation uses a listener, call that.}}
\DoxyCodeLine{368   \textcolor{keyword}{template} <\textcolor{keyword}{typename} P>}
\DoxyCodeLine{369   \textcolor{keyword}{static} \textcolor{keyword}{auto} MatchAndExplainImpl(\textcolor{keyword}{const} MatcherBase\& m, \textcolor{keyword}{const} T\& value,}
\DoxyCodeLine{370                                   MatchResultListener* listener)}
\DoxyCodeLine{371       -\/> \textcolor{keyword}{decltype}(P::Get(m).MatchAndExplain(value, listener-\/>stream())) \{}
\DoxyCodeLine{372     \textcolor{keywordflow}{return} P::Get(m).MatchAndExplain(value, listener-\/>stream());}
\DoxyCodeLine{373   \}}
\DoxyCodeLine{374 }
\DoxyCodeLine{375   \textcolor{keyword}{template} <\textcolor{keyword}{typename} P>}
\DoxyCodeLine{376   \textcolor{keyword}{static} \textcolor{keyword}{auto} MatchAndExplainImpl(\textcolor{keyword}{const} MatcherBase\& m, \textcolor{keyword}{const} T\& value,}
\DoxyCodeLine{377                                   MatchResultListener* listener)}
\DoxyCodeLine{378       -\/> \textcolor{keyword}{decltype}(P::Get(m).MatchAndExplain(value, listener)) \{}
\DoxyCodeLine{379     \textcolor{keywordflow}{return} P::Get(m).MatchAndExplain(value, listener);}
\DoxyCodeLine{380   \}}
\DoxyCodeLine{381 }
\DoxyCodeLine{382   \textcolor{keyword}{template} <\textcolor{keyword}{typename} P>}
\DoxyCodeLine{383   \textcolor{keyword}{static} \textcolor{keywordtype}{void} DescribeImpl(\textcolor{keyword}{const} MatcherBase\& m, std::ostream* os,}
\DoxyCodeLine{384                            \textcolor{keywordtype}{bool} negation) \{}
\DoxyCodeLine{385     \textcolor{keywordflow}{if} (negation) \{}
\DoxyCodeLine{386       P::Get(m).DescribeNegationTo(os);}
\DoxyCodeLine{387     \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{388       P::Get(m).DescribeTo(os);}
\DoxyCodeLine{389     \}}
\DoxyCodeLine{390   \}}
\DoxyCodeLine{391 }
\DoxyCodeLine{392   \textcolor{keyword}{template} <\textcolor{keyword}{typename} P>}
\DoxyCodeLine{393   \textcolor{keyword}{static} \textcolor{keyword}{const} MatcherDescriberInterface* GetDescriberImpl(}
\DoxyCodeLine{394       \textcolor{keyword}{const} MatcherBase\& m) \{}
\DoxyCodeLine{395     \textcolor{comment}{// If the impl is a MatcherDescriberInterface, then return it.}}
\DoxyCodeLine{396     \textcolor{comment}{// Otherwise use MatcherBase itself.}}
\DoxyCodeLine{397     \textcolor{comment}{// This allows us to implement the GetDescriber() function without support}}
\DoxyCodeLine{398     \textcolor{comment}{// from the impl, but some users really want to get their impl back when}}
\DoxyCodeLine{399     \textcolor{comment}{// they call GetDescriber().}}
\DoxyCodeLine{400     \textcolor{comment}{// We use std::get on a tuple as a workaround of not having `if constexpr`.}}
\DoxyCodeLine{401     \textcolor{keywordflow}{return} std::get<(}
\DoxyCodeLine{402         std::is\_convertible<\textcolor{keyword}{decltype}(\&P::Get(m)),}
\DoxyCodeLine{403                             \textcolor{keyword}{const} MatcherDescriberInterface*>::value}
\DoxyCodeLine{404             ? 1}
\DoxyCodeLine{405             : 0)>(std::make\_tuple(\&m, \&P::Get(m)));}
\DoxyCodeLine{406   \}}
\DoxyCodeLine{407 }
\DoxyCodeLine{408   \textcolor{keyword}{template} <\textcolor{keyword}{typename} P>}
\DoxyCodeLine{409   \textcolor{keyword}{const} VTable* GetVTable() \{}
\DoxyCodeLine{410     \textcolor{keyword}{static} \textcolor{keyword}{constexpr} VTable kVTable = \{\&MatchAndExplainImpl<P>,}
\DoxyCodeLine{411                                        \&DescribeImpl<P>, \&GetDescriberImpl<P>,}
\DoxyCodeLine{412                                        P::shared\_destroy\};}
\DoxyCodeLine{413     \textcolor{keywordflow}{return} \&kVTable;}
\DoxyCodeLine{414   \}}
\DoxyCodeLine{415 }
\DoxyCodeLine{416   \textcolor{keyword}{union }Buffer \{}
\DoxyCodeLine{417     \textcolor{comment}{// Add some types to give Buffer some common alignment/size use cases.}}
\DoxyCodeLine{418     \textcolor{keywordtype}{void}* ptr;}
\DoxyCodeLine{419     \textcolor{keywordtype}{double} d;}
\DoxyCodeLine{420     int64\_t i;}
\DoxyCodeLine{421     \textcolor{comment}{// And add one for the out-\/of-\/line cases.}}
\DoxyCodeLine{422     SharedPayloadBase* shared;}
\DoxyCodeLine{423   \};}
\DoxyCodeLine{424 }
\DoxyCodeLine{425   \textcolor{keywordtype}{void} Destroy() \{}
\DoxyCodeLine{426     \textcolor{keywordflow}{if} (IsShared() \&\& buffer\_.shared-\/>Unref()) \{}
\DoxyCodeLine{427       vtable\_-\/>shared\_destroy(buffer\_.shared);}
\DoxyCodeLine{428     \}}
\DoxyCodeLine{429   \}}
\DoxyCodeLine{430 }
\DoxyCodeLine{431   \textcolor{keyword}{template} <\textcolor{keyword}{typename} M>}
\DoxyCodeLine{432   \textcolor{keyword}{static} \textcolor{keyword}{constexpr} \textcolor{keywordtype}{bool} IsInlined() \{}
\DoxyCodeLine{433     \textcolor{keywordflow}{return} \textcolor{keyword}{sizeof}(M) <= \textcolor{keyword}{sizeof}(Buffer) \&\& \textcolor{keyword}{alignof}(M) <= \textcolor{keyword}{alignof}(Buffer) \&\&}
\DoxyCodeLine{434            std::is\_trivially\_copy\_constructible<M>::value \&\&}
\DoxyCodeLine{435            std::is\_trivially\_destructible<M>::value;}
\DoxyCodeLine{436   \}}
\DoxyCodeLine{437 }
\DoxyCodeLine{438   template <typename M, bool = MatcherBase::IsInlined<M>()>}
\DoxyCodeLine{439   \textcolor{keyword}{struct }ValuePolicy \{}
\DoxyCodeLine{440     \textcolor{keyword}{static} \textcolor{keyword}{const} M\& Get(\textcolor{keyword}{const} MatcherBase\& m) \{}
\DoxyCodeLine{441       \textcolor{comment}{// When inlined along with Init, need to be explicit to avoid violating}}
\DoxyCodeLine{442       \textcolor{comment}{// strict aliasing rules.}}
\DoxyCodeLine{443       \textcolor{keyword}{const} M* ptr =}
\DoxyCodeLine{444           \textcolor{keyword}{static\_cast<}\textcolor{keyword}{const }M*\textcolor{keyword}{>}(\textcolor{keyword}{static\_cast<}\textcolor{keyword}{const }\textcolor{keywordtype}{void}*\textcolor{keyword}{>}(\&m.buffer\_));}
\DoxyCodeLine{445       \textcolor{keywordflow}{return} *ptr;}
\DoxyCodeLine{446     \}}
\DoxyCodeLine{447     \textcolor{keyword}{static} \textcolor{keywordtype}{void} Init(MatcherBase\& m, M impl) \{}
\DoxyCodeLine{448       ::new (\textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{void}*\textcolor{keyword}{>}(\&m.buffer\_)) M(impl);}
\DoxyCodeLine{449     \}}
\DoxyCodeLine{450     static constexpr auto shared\_destroy = \textcolor{keywordtype}{nullptr};}
\DoxyCodeLine{451   \};}
\DoxyCodeLine{452 }
\DoxyCodeLine{453   template <typename M>}
\DoxyCodeLine{454   struct ValuePolicy<M, false> \{}
\DoxyCodeLine{455     \textcolor{keyword}{using }Shared = SharedPayload<M>;}
\DoxyCodeLine{456     \textcolor{keyword}{static} \textcolor{keyword}{const} M\& Get(\textcolor{keyword}{const} MatcherBase\& m) \{}
\DoxyCodeLine{457       \textcolor{keywordflow}{return} \textcolor{keyword}{static\_cast<}Shared*\textcolor{keyword}{>}(m.buffer\_.shared)-\/>value;}
\DoxyCodeLine{458     \}}
\DoxyCodeLine{459     \textcolor{keyword}{template} <\textcolor{keyword}{typename} Arg>}
\DoxyCodeLine{460     \textcolor{keyword}{static} \textcolor{keywordtype}{void} Init(MatcherBase\& m, Arg\&\& arg) \{}
\DoxyCodeLine{461       m.buffer\_.shared = \textcolor{keyword}{new} Shared(std::forward<Arg>(arg));}
\DoxyCodeLine{462     \}}
\DoxyCodeLine{463     \textcolor{keyword}{static} \textcolor{keyword}{constexpr} \textcolor{keyword}{auto} shared\_destroy = \&Shared::Destroy;}
\DoxyCodeLine{464   \};}
\DoxyCodeLine{465 }
\DoxyCodeLine{466   \textcolor{keyword}{template} <\textcolor{keyword}{typename} U, \textcolor{keywordtype}{bool} B>}
\DoxyCodeLine{467   \textcolor{keyword}{struct }ValuePolicy<const MatcherInterface<U>*, B> \{}
\DoxyCodeLine{468     \textcolor{keyword}{using }M = \textcolor{keyword}{const} MatcherInterface<U>;}
\DoxyCodeLine{469     \textcolor{keyword}{using }Shared = SharedPayload<std::unique\_ptr<M>>;}
\DoxyCodeLine{470     \textcolor{keyword}{static} \textcolor{keyword}{const} M\& Get(\textcolor{keyword}{const} MatcherBase\& m) \{}
\DoxyCodeLine{471       \textcolor{keywordflow}{return} *\textcolor{keyword}{static\_cast<}Shared*\textcolor{keyword}{>}(m.buffer\_.shared)-\/>value;}
\DoxyCodeLine{472     \}}
\DoxyCodeLine{473     \textcolor{keyword}{static} \textcolor{keywordtype}{void} Init(MatcherBase\& m, M* impl) \{}
\DoxyCodeLine{474       m.buffer\_.shared = \textcolor{keyword}{new} Shared(std::unique\_ptr<M>(impl));}
\DoxyCodeLine{475     \}}
\DoxyCodeLine{476 }
\DoxyCodeLine{477     \textcolor{keyword}{static} \textcolor{keyword}{constexpr} \textcolor{keyword}{auto} shared\_destroy = \&Shared::Destroy;}
\DoxyCodeLine{478   \};}
\DoxyCodeLine{479 }
\DoxyCodeLine{480   \textcolor{keyword}{template} <\textcolor{keyword}{typename} M>}
\DoxyCodeLine{481   \textcolor{keywordtype}{void} Init(M\&\& m) \{}
\DoxyCodeLine{482     \textcolor{keyword}{using }MM = \textcolor{keyword}{typename} std::decay<M>::type;}
\DoxyCodeLine{483     \textcolor{keyword}{using }Policy = ValuePolicy<MM>;}
\DoxyCodeLine{484     vtable\_ = GetVTable<Policy>();}
\DoxyCodeLine{485     Policy::Init(*\textcolor{keyword}{this}, std::forward<M>(m));}
\DoxyCodeLine{486   \}}
\DoxyCodeLine{487 }
\DoxyCodeLine{488   \textcolor{keyword}{const} VTable* vtable\_;}
\DoxyCodeLine{489   Buffer buffer\_;}
\DoxyCodeLine{490 \};}
\DoxyCodeLine{491 }
\DoxyCodeLine{492 \}  \textcolor{comment}{// namespace internal}}
\DoxyCodeLine{493 }
\DoxyCodeLine{494 \textcolor{comment}{// A Matcher<T> is a copyable and IMMUTABLE (except by assignment)}}
\DoxyCodeLine{495 \textcolor{comment}{// object that can check whether a value of type T matches.  The}}
\DoxyCodeLine{496 \textcolor{comment}{// implementation of Matcher<T> is just a std::shared\_ptr to const}}
\DoxyCodeLine{497 \textcolor{comment}{// MatcherInterface<T>.  Don't inherit from Matcher!}}
\DoxyCodeLine{498 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{499 \textcolor{keyword}{class }Matcher : \textcolor{keyword}{public} internal::MatcherBase<T> \{}
\DoxyCodeLine{500  \textcolor{keyword}{public}:}
\DoxyCodeLine{501   \textcolor{comment}{// Constructs a null matcher.  Needed for storing Matcher objects in STL}}
\DoxyCodeLine{502   \textcolor{comment}{// containers.  A default-\/constructed matcher is not yet initialized.  You}}
\DoxyCodeLine{503   \textcolor{comment}{// cannot use it until a valid value has been assigned to it.}}
\DoxyCodeLine{504   \textcolor{keyword}{explicit} Matcher() \{\}  \textcolor{comment}{// NOLINT}}
\DoxyCodeLine{505 }
\DoxyCodeLine{506   \textcolor{comment}{// Constructs a matcher from its implementation.}}
\DoxyCodeLine{507   \textcolor{keyword}{explicit} Matcher(\textcolor{keyword}{const} MatcherInterface<const T\&>* impl)}
\DoxyCodeLine{508       : internal::MatcherBase<T>(impl) \{\}}
\DoxyCodeLine{509 }
\DoxyCodeLine{510   \textcolor{keyword}{template} <\textcolor{keyword}{typename} U>}
\DoxyCodeLine{511   \textcolor{keyword}{explicit} Matcher(}
\DoxyCodeLine{512       \textcolor{keyword}{const} MatcherInterface<U>* impl,}
\DoxyCodeLine{513       \textcolor{keyword}{typename} std::enable\_if<!std::is\_same<U, const U\&>::value>::type* =}
\DoxyCodeLine{514           \textcolor{keyword}{nullptr})}
\DoxyCodeLine{515       : internal::MatcherBase<T>(impl) \{\}}
\DoxyCodeLine{516 }
\DoxyCodeLine{517   \textcolor{keyword}{template} <\textcolor{keyword}{typename} M, \textcolor{keyword}{typename} = \textcolor{keyword}{typename} std::remove\_reference<}
\DoxyCodeLine{518                             M>::type::is\_gtest\_matcher>}
\DoxyCodeLine{519   Matcher(M\&\& m) : internal::MatcherBase<T>(std::forward<M>(m)) \{\}  \textcolor{comment}{// NOLINT}}
\DoxyCodeLine{520 }
\DoxyCodeLine{521   \textcolor{comment}{// Implicit constructor here allows people to write}}
\DoxyCodeLine{522   \textcolor{comment}{// EXPECT\_CALL(foo, Bar(5)) instead of EXPECT\_CALL(foo, Bar(Eq(5))) sometimes}}
\DoxyCodeLine{523   Matcher(T value);  \textcolor{comment}{// NOLINT}}
\DoxyCodeLine{524 \};}
\DoxyCodeLine{525 }
\DoxyCodeLine{526 \textcolor{comment}{// The following two specializations allow the user to write str}}
\DoxyCodeLine{527 \textcolor{comment}{// instead of Eq(str) and "{}foo"{} instead of Eq("{}foo"{}) when a std::string}}
\DoxyCodeLine{528 \textcolor{comment}{// matcher is expected.}}
\DoxyCodeLine{529 \textcolor{keyword}{template} <>}
\DoxyCodeLine{530 \textcolor{keyword}{class }GTEST\_API\_ Matcher<const std::string\&>}
\DoxyCodeLine{531     : \textcolor{keyword}{public} internal::MatcherBase<const std::string\&> \{}
\DoxyCodeLine{532  \textcolor{keyword}{public}:}
\DoxyCodeLine{533   Matcher() \{\}}
\DoxyCodeLine{534 }
\DoxyCodeLine{535   \textcolor{keyword}{explicit} Matcher(\textcolor{keyword}{const} MatcherInterface<const std::string\&>* impl)}
\DoxyCodeLine{536       : internal::MatcherBase<const std::string\&>(impl) \{\}}
\DoxyCodeLine{537 }
\DoxyCodeLine{538   \textcolor{keyword}{template} <\textcolor{keyword}{typename} M, \textcolor{keyword}{typename} = \textcolor{keyword}{typename} std::remove\_reference<}
\DoxyCodeLine{539                             M>::type::is\_gtest\_matcher>}
\DoxyCodeLine{540   Matcher(M\&\& m)  \textcolor{comment}{// NOLINT}}
\DoxyCodeLine{541       : internal::MatcherBase<const std::string\&>(std::forward<M>(m)) \{\}}
\DoxyCodeLine{542 }
\DoxyCodeLine{543   \textcolor{comment}{// Allows the user to write str instead of Eq(str) sometimes, where}}
\DoxyCodeLine{544   \textcolor{comment}{// str is a std::string object.}}
\DoxyCodeLine{545   Matcher(\textcolor{keyword}{const} std::string\& s);  \textcolor{comment}{// NOLINT}}
\DoxyCodeLine{546 }
\DoxyCodeLine{547   \textcolor{comment}{// Allows the user to write "{}foo"{} instead of Eq("{}foo"{}) sometimes.}}
\DoxyCodeLine{548   Matcher(\textcolor{keyword}{const} \textcolor{keywordtype}{char}* s);  \textcolor{comment}{// NOLINT}}
\DoxyCodeLine{549 \};}
\DoxyCodeLine{550 }
\DoxyCodeLine{551 \textcolor{keyword}{template} <>}
\DoxyCodeLine{552 \textcolor{keyword}{class }GTEST\_API\_ Matcher<std::string>}
\DoxyCodeLine{553     : \textcolor{keyword}{public} internal::MatcherBase<std::string> \{}
\DoxyCodeLine{554  \textcolor{keyword}{public}:}
\DoxyCodeLine{555   Matcher() \{\}}
\DoxyCodeLine{556 }
\DoxyCodeLine{557   \textcolor{keyword}{explicit} Matcher(\textcolor{keyword}{const} MatcherInterface<const std::string\&>* impl)}
\DoxyCodeLine{558       : internal::MatcherBase<std::string>(impl) \{\}}
\DoxyCodeLine{559   \textcolor{keyword}{explicit} Matcher(\textcolor{keyword}{const} MatcherInterface<std::string>* impl)}
\DoxyCodeLine{560       : internal::MatcherBase<std::string>(impl) \{\}}
\DoxyCodeLine{561 }
\DoxyCodeLine{562   \textcolor{keyword}{template} <\textcolor{keyword}{typename} M, \textcolor{keyword}{typename} = \textcolor{keyword}{typename} std::remove\_reference<}
\DoxyCodeLine{563                             M>::type::is\_gtest\_matcher>}
\DoxyCodeLine{564   Matcher(M\&\& m)  \textcolor{comment}{// NOLINT}}
\DoxyCodeLine{565       : internal::MatcherBase<std::string>(std::forward<M>(m)) \{\}}
\DoxyCodeLine{566 }
\DoxyCodeLine{567   \textcolor{comment}{// Allows the user to write str instead of Eq(str) sometimes, where}}
\DoxyCodeLine{568   \textcolor{comment}{// str is a string object.}}
\DoxyCodeLine{569   Matcher(\textcolor{keyword}{const} std::string\& s);  \textcolor{comment}{// NOLINT}}
\DoxyCodeLine{570 }
\DoxyCodeLine{571   \textcolor{comment}{// Allows the user to write "{}foo"{} instead of Eq("{}foo"{}) sometimes.}}
\DoxyCodeLine{572   Matcher(\textcolor{keyword}{const} \textcolor{keywordtype}{char}* s);  \textcolor{comment}{// NOLINT}}
\DoxyCodeLine{573 \};}
\DoxyCodeLine{574 }
\DoxyCodeLine{575 \textcolor{preprocessor}{\#if GTEST\_INTERNAL\_HAS\_STRING\_VIEW}}
\DoxyCodeLine{576 \textcolor{comment}{// The following two specializations allow the user to write str}}
\DoxyCodeLine{577 \textcolor{comment}{// instead of Eq(str) and "{}foo"{} instead of Eq("{}foo"{}) when a absl::string\_view}}
\DoxyCodeLine{578 \textcolor{comment}{// matcher is expected.}}
\DoxyCodeLine{579 \textcolor{keyword}{template} <>}
\DoxyCodeLine{580 \textcolor{keyword}{class }GTEST\_API\_ Matcher<const internal::StringView\&>}
\DoxyCodeLine{581     : \textcolor{keyword}{public} internal::MatcherBase<const internal::StringView\&> \{}
\DoxyCodeLine{582  \textcolor{keyword}{public}:}
\DoxyCodeLine{583   Matcher() \{\}}
\DoxyCodeLine{584 }
\DoxyCodeLine{585   \textcolor{keyword}{explicit} Matcher(\textcolor{keyword}{const} MatcherInterface<const internal::StringView\&>* impl)}
\DoxyCodeLine{586       : internal::MatcherBase<const internal::StringView\&>(impl) \{\}}
\DoxyCodeLine{587 }
\DoxyCodeLine{588   \textcolor{keyword}{template} <\textcolor{keyword}{typename} M, \textcolor{keyword}{typename} = \textcolor{keyword}{typename} std::remove\_reference<}
\DoxyCodeLine{589                             M>::type::is\_gtest\_matcher>}
\DoxyCodeLine{590   Matcher(M\&\& m)  \textcolor{comment}{// NOLINT}}
\DoxyCodeLine{591       : internal::MatcherBase<const internal::StringView\&>(std::forward<M>(m)) \{}
\DoxyCodeLine{592   \}}
\DoxyCodeLine{593 }
\DoxyCodeLine{594   \textcolor{comment}{// Allows the user to write str instead of Eq(str) sometimes, where}}
\DoxyCodeLine{595   \textcolor{comment}{// str is a std::string object.}}
\DoxyCodeLine{596   Matcher(\textcolor{keyword}{const} std::string\& s);  \textcolor{comment}{// NOLINT}}
\DoxyCodeLine{597 }
\DoxyCodeLine{598   \textcolor{comment}{// Allows the user to write "{}foo"{} instead of Eq("{}foo"{}) sometimes.}}
\DoxyCodeLine{599   Matcher(\textcolor{keyword}{const} \textcolor{keywordtype}{char}* s);  \textcolor{comment}{// NOLINT}}
\DoxyCodeLine{600 }
\DoxyCodeLine{601   \textcolor{comment}{// Allows the user to pass absl::string\_views or std::string\_views directly.}}
\DoxyCodeLine{602   Matcher(internal::StringView s);  \textcolor{comment}{// NOLINT}}
\DoxyCodeLine{603 \};}
\DoxyCodeLine{604 }
\DoxyCodeLine{605 \textcolor{keyword}{template} <>}
\DoxyCodeLine{606 \textcolor{keyword}{class }GTEST\_API\_ Matcher<internal::StringView>}
\DoxyCodeLine{607     : \textcolor{keyword}{public} internal::MatcherBase<internal::StringView> \{}
\DoxyCodeLine{608  \textcolor{keyword}{public}:}
\DoxyCodeLine{609   Matcher() \{\}}
\DoxyCodeLine{610 }
\DoxyCodeLine{611   \textcolor{keyword}{explicit} Matcher(\textcolor{keyword}{const} MatcherInterface<const internal::StringView\&>* impl)}
\DoxyCodeLine{612       : internal::MatcherBase<internal::StringView>(impl) \{\}}
\DoxyCodeLine{613   \textcolor{keyword}{explicit} Matcher(\textcolor{keyword}{const} MatcherInterface<internal::StringView>* impl)}
\DoxyCodeLine{614       : internal::MatcherBase<internal::StringView>(impl) \{\}}
\DoxyCodeLine{615 }
\DoxyCodeLine{616   \textcolor{keyword}{template} <\textcolor{keyword}{typename} M, \textcolor{keyword}{typename} = \textcolor{keyword}{typename} std::remove\_reference<}
\DoxyCodeLine{617                             M>::type::is\_gtest\_matcher>}
\DoxyCodeLine{618   Matcher(M\&\& m)  \textcolor{comment}{// NOLINT}}
\DoxyCodeLine{619       : internal::MatcherBase<internal::StringView>(std::forward<M>(m)) \{\}}
\DoxyCodeLine{620 }
\DoxyCodeLine{621   \textcolor{comment}{// Allows the user to write str instead of Eq(str) sometimes, where}}
\DoxyCodeLine{622   \textcolor{comment}{// str is a std::string object.}}
\DoxyCodeLine{623   Matcher(\textcolor{keyword}{const} std::string\& s);  \textcolor{comment}{// NOLINT}}
\DoxyCodeLine{624 }
\DoxyCodeLine{625   \textcolor{comment}{// Allows the user to write "{}foo"{} instead of Eq("{}foo"{}) sometimes.}}
\DoxyCodeLine{626   Matcher(\textcolor{keyword}{const} \textcolor{keywordtype}{char}* s);  \textcolor{comment}{// NOLINT}}
\DoxyCodeLine{627 }
\DoxyCodeLine{628   \textcolor{comment}{// Allows the user to pass absl::string\_views or std::string\_views directly.}}
\DoxyCodeLine{629   Matcher(internal::StringView s);  \textcolor{comment}{// NOLINT}}
\DoxyCodeLine{630 \};}
\DoxyCodeLine{631 \textcolor{preprocessor}{\#endif  }\textcolor{comment}{// GTEST\_INTERNAL\_HAS\_STRING\_VIEW}}
\DoxyCodeLine{632 }
\DoxyCodeLine{633 \textcolor{comment}{// Prints a matcher in a human-\/readable format.}}
\DoxyCodeLine{634 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{635 std::ostream\& operator<<(std::ostream\& os, \textcolor{keyword}{const} Matcher<T>\& matcher) \{}
\DoxyCodeLine{636   matcher.DescribeTo(\&os);}
\DoxyCodeLine{637   \textcolor{keywordflow}{return} os;}
\DoxyCodeLine{638 \}}
\DoxyCodeLine{639 }
\DoxyCodeLine{640 \textcolor{comment}{// The PolymorphicMatcher class template makes it easy to implement a}}
\DoxyCodeLine{641 \textcolor{comment}{// polymorphic matcher (i.e. a matcher that can match values of more}}
\DoxyCodeLine{642 \textcolor{comment}{// than one type, e.g. Eq(n) and NotNull()).}}
\DoxyCodeLine{643 \textcolor{comment}{//}}
\DoxyCodeLine{644 \textcolor{comment}{// To define a polymorphic matcher, a user should provide an Impl}}
\DoxyCodeLine{645 \textcolor{comment}{// class that has a DescribeTo() method and a DescribeNegationTo()}}
\DoxyCodeLine{646 \textcolor{comment}{// method, and define a member function (or member function template)}}
\DoxyCodeLine{647 \textcolor{comment}{//}}
\DoxyCodeLine{648 \textcolor{comment}{//   bool MatchAndExplain(const Value\& value,}}
\DoxyCodeLine{649 \textcolor{comment}{//                        MatchResultListener* listener) const;}}
\DoxyCodeLine{650 \textcolor{comment}{//}}
\DoxyCodeLine{651 \textcolor{comment}{// See the definition of NotNull() for a complete example.}}
\DoxyCodeLine{652 \textcolor{keyword}{template} <\textcolor{keyword}{class} Impl>}
\DoxyCodeLine{653 \textcolor{keyword}{class }PolymorphicMatcher \{}
\DoxyCodeLine{654  \textcolor{keyword}{public}:}
\DoxyCodeLine{655   \textcolor{keyword}{explicit} PolymorphicMatcher(\textcolor{keyword}{const} Impl\& an\_impl) : impl\_(an\_impl) \{\}}
\DoxyCodeLine{656 }
\DoxyCodeLine{657   \textcolor{comment}{// Returns a mutable reference to the underlying matcher}}
\DoxyCodeLine{658   \textcolor{comment}{// implementation object.}}
\DoxyCodeLine{659   Impl\& mutable\_impl() \{ \textcolor{keywordflow}{return} impl\_; \}}
\DoxyCodeLine{660 }
\DoxyCodeLine{661   \textcolor{comment}{// Returns an immutable reference to the underlying matcher}}
\DoxyCodeLine{662   \textcolor{comment}{// implementation object.}}
\DoxyCodeLine{663   \textcolor{keyword}{const} Impl\& impl()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} impl\_; \}}
\DoxyCodeLine{664 }
\DoxyCodeLine{665   \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{666   \textcolor{keyword}{operator} Matcher<T>()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{667     \textcolor{keywordflow}{return} Matcher<T>(\textcolor{keyword}{new} MonomorphicImpl<const T\&>(impl\_));}
\DoxyCodeLine{668   \}}
\DoxyCodeLine{669 }
\DoxyCodeLine{670  \textcolor{keyword}{private}:}
\DoxyCodeLine{671   \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{672   \textcolor{keyword}{class }MonomorphicImpl : \textcolor{keyword}{public} MatcherInterface<T> \{}
\DoxyCodeLine{673    \textcolor{keyword}{public}:}
\DoxyCodeLine{674     \textcolor{keyword}{explicit} MonomorphicImpl(\textcolor{keyword}{const} Impl\& impl) : impl\_(impl) \{\}}
\DoxyCodeLine{675 }
\DoxyCodeLine{676     \textcolor{keywordtype}{void} DescribeTo(::std::ostream* os)\textcolor{keyword}{ const override }\{ impl\_.DescribeTo(os); \}}
\DoxyCodeLine{677 }
\DoxyCodeLine{678     \textcolor{keywordtype}{void} DescribeNegationTo(::std::ostream* os)\textcolor{keyword}{ const override }\{}
\DoxyCodeLine{679       impl\_.DescribeNegationTo(os);}
\DoxyCodeLine{680     \}}
\DoxyCodeLine{681 }
\DoxyCodeLine{682     \textcolor{keywordtype}{bool} MatchAndExplain(T x, MatchResultListener* listener)\textcolor{keyword}{ const override }\{}
\DoxyCodeLine{683       \textcolor{keywordflow}{return} impl\_.MatchAndExplain(x, listener);}
\DoxyCodeLine{684     \}}
\DoxyCodeLine{685 }
\DoxyCodeLine{686    \textcolor{keyword}{private}:}
\DoxyCodeLine{687     \textcolor{keyword}{const} Impl impl\_;}
\DoxyCodeLine{688   \};}
\DoxyCodeLine{689 }
\DoxyCodeLine{690   Impl impl\_;}
\DoxyCodeLine{691 \};}
\DoxyCodeLine{692 }
\DoxyCodeLine{693 \textcolor{comment}{// Creates a matcher from its implementation.}}
\DoxyCodeLine{694 \textcolor{comment}{// DEPRECATED: Especially in the generic code, prefer:}}
\DoxyCodeLine{695 \textcolor{comment}{//   Matcher<T>(new MyMatcherImpl<const T\&>(...));}}
\DoxyCodeLine{696 \textcolor{comment}{//}}
\DoxyCodeLine{697 \textcolor{comment}{// MakeMatcher may create a Matcher that accepts its argument by value, which}}
\DoxyCodeLine{698 \textcolor{comment}{// leads to unnecessary copies \& lack of support for non-\/copyable types.}}
\DoxyCodeLine{699 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{700 \textcolor{keyword}{inline} Matcher<T> MakeMatcher(\textcolor{keyword}{const} MatcherInterface<T>* impl) \{}
\DoxyCodeLine{701   \textcolor{keywordflow}{return} Matcher<T>(impl);}
\DoxyCodeLine{702 \}}
\DoxyCodeLine{703 }
\DoxyCodeLine{704 \textcolor{comment}{// Creates a polymorphic matcher from its implementation.  This is}}
\DoxyCodeLine{705 \textcolor{comment}{// easier to use than the PolymorphicMatcher<Impl> constructor as it}}
\DoxyCodeLine{706 \textcolor{comment}{// doesn't require you to explicitly write the template argument, e.g.}}
\DoxyCodeLine{707 \textcolor{comment}{//}}
\DoxyCodeLine{708 \textcolor{comment}{//   MakePolymorphicMatcher(foo);}}
\DoxyCodeLine{709 \textcolor{comment}{// vs}}
\DoxyCodeLine{710 \textcolor{comment}{//   PolymorphicMatcher<TypeOfFoo>(foo);}}
\DoxyCodeLine{711 \textcolor{keyword}{template} <\textcolor{keyword}{class} Impl>}
\DoxyCodeLine{712 \textcolor{keyword}{inline} PolymorphicMatcher<Impl> MakePolymorphicMatcher(\textcolor{keyword}{const} Impl\& impl) \{}
\DoxyCodeLine{713   \textcolor{keywordflow}{return} PolymorphicMatcher<Impl>(impl);}
\DoxyCodeLine{714 \}}
\DoxyCodeLine{715 }
\DoxyCodeLine{716 \textcolor{keyword}{namespace }internal \{}
\DoxyCodeLine{717 \textcolor{comment}{// Implements a matcher that compares a given value with a}}
\DoxyCodeLine{718 \textcolor{comment}{// pre-\/supplied value using one of the ==, <=, <, etc, operators.  The}}
\DoxyCodeLine{719 \textcolor{comment}{// two values being compared don't have to have the same type.}}
\DoxyCodeLine{720 \textcolor{comment}{//}}
\DoxyCodeLine{721 \textcolor{comment}{// The matcher defined here is polymorphic (for example, Eq(5) can be}}
\DoxyCodeLine{722 \textcolor{comment}{// used to match an int, a short, a double, etc).  Therefore we use}}
\DoxyCodeLine{723 \textcolor{comment}{// a template type conversion operator in the implementation.}}
\DoxyCodeLine{724 \textcolor{comment}{//}}
\DoxyCodeLine{725 \textcolor{comment}{// The following template definition assumes that the Rhs parameter is}}
\DoxyCodeLine{726 \textcolor{comment}{// a "{}bare"{} type (i.e. neither 'const T' nor 'T\&').}}
\DoxyCodeLine{727 \textcolor{keyword}{template} <\textcolor{keyword}{typename} D, \textcolor{keyword}{typename} Rhs, \textcolor{keyword}{typename} Op>}
\DoxyCodeLine{728 \textcolor{keyword}{class }ComparisonBase \{}
\DoxyCodeLine{729  \textcolor{keyword}{public}:}
\DoxyCodeLine{730   \textcolor{keyword}{explicit} ComparisonBase(\textcolor{keyword}{const} Rhs\& rhs) : rhs\_(rhs) \{\}}
\DoxyCodeLine{731 }
\DoxyCodeLine{732   \textcolor{keyword}{using }is\_gtest\_matcher = void;}
\DoxyCodeLine{733 }
\DoxyCodeLine{734   \textcolor{keyword}{template} <\textcolor{keyword}{typename} Lhs>}
\DoxyCodeLine{735   \textcolor{keywordtype}{bool} MatchAndExplain(\textcolor{keyword}{const} Lhs\& lhs, std::ostream*)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{736     \textcolor{keywordflow}{return} Op()(lhs, Unwrap(rhs\_));}
\DoxyCodeLine{737   \}}
\DoxyCodeLine{738   \textcolor{keywordtype}{void} DescribeTo(std::ostream* os)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{739     *os << D::Desc() << \textcolor{stringliteral}{"{} "{}};}
\DoxyCodeLine{740     UniversalPrint(Unwrap(rhs\_), os);}
\DoxyCodeLine{741   \}}
\DoxyCodeLine{742   \textcolor{keywordtype}{void} DescribeNegationTo(std::ostream* os)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{743     *os << D::NegatedDesc() << \textcolor{stringliteral}{"{} "{}};}
\DoxyCodeLine{744     UniversalPrint(Unwrap(rhs\_), os);}
\DoxyCodeLine{745   \}}
\DoxyCodeLine{746 }
\DoxyCodeLine{747  \textcolor{keyword}{private}:}
\DoxyCodeLine{748   \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{749   \textcolor{keyword}{static} \textcolor{keyword}{const} T\& Unwrap(\textcolor{keyword}{const} T\& v) \{}
\DoxyCodeLine{750     \textcolor{keywordflow}{return} v;}
\DoxyCodeLine{751   \}}
\DoxyCodeLine{752   \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{753   \textcolor{keyword}{static} \textcolor{keyword}{const} T\& Unwrap(std::reference\_wrapper<T> v) \{}
\DoxyCodeLine{754     \textcolor{keywordflow}{return} v;}
\DoxyCodeLine{755   \}}
\DoxyCodeLine{756 }
\DoxyCodeLine{757   Rhs rhs\_;}
\DoxyCodeLine{758 \};}
\DoxyCodeLine{759 }
\DoxyCodeLine{760 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Rhs>}
\DoxyCodeLine{761 \textcolor{keyword}{class }EqMatcher : \textcolor{keyword}{public} ComparisonBase<EqMatcher<Rhs>, Rhs, AnyEq> \{}
\DoxyCodeLine{762  \textcolor{keyword}{public}:}
\DoxyCodeLine{763   \textcolor{keyword}{explicit} EqMatcher(\textcolor{keyword}{const} Rhs\& rhs)}
\DoxyCodeLine{764       : ComparisonBase<EqMatcher<Rhs>, Rhs, AnyEq>(rhs) \{\}}
\DoxyCodeLine{765   \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{char}* Desc() \{ \textcolor{keywordflow}{return} \textcolor{stringliteral}{"{}is equal to"{}}; \}}
\DoxyCodeLine{766   \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{char}* NegatedDesc() \{ \textcolor{keywordflow}{return} \textcolor{stringliteral}{"{}isn't equal to"{}}; \}}
\DoxyCodeLine{767 \};}
\DoxyCodeLine{768 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Rhs>}
\DoxyCodeLine{769 \textcolor{keyword}{class }NeMatcher : \textcolor{keyword}{public} ComparisonBase<NeMatcher<Rhs>, Rhs, AnyNe> \{}
\DoxyCodeLine{770  \textcolor{keyword}{public}:}
\DoxyCodeLine{771   \textcolor{keyword}{explicit} NeMatcher(\textcolor{keyword}{const} Rhs\& rhs)}
\DoxyCodeLine{772       : ComparisonBase<NeMatcher<Rhs>, Rhs, AnyNe>(rhs) \{\}}
\DoxyCodeLine{773   \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{char}* Desc() \{ \textcolor{keywordflow}{return} \textcolor{stringliteral}{"{}isn't equal to"{}}; \}}
\DoxyCodeLine{774   \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{char}* NegatedDesc() \{ \textcolor{keywordflow}{return} \textcolor{stringliteral}{"{}is equal to"{}}; \}}
\DoxyCodeLine{775 \};}
\DoxyCodeLine{776 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Rhs>}
\DoxyCodeLine{777 \textcolor{keyword}{class }LtMatcher : \textcolor{keyword}{public} ComparisonBase<LtMatcher<Rhs>, Rhs, AnyLt> \{}
\DoxyCodeLine{778  \textcolor{keyword}{public}:}
\DoxyCodeLine{779   \textcolor{keyword}{explicit} LtMatcher(\textcolor{keyword}{const} Rhs\& rhs)}
\DoxyCodeLine{780       : ComparisonBase<LtMatcher<Rhs>, Rhs, AnyLt>(rhs) \{\}}
\DoxyCodeLine{781   \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{char}* Desc() \{ \textcolor{keywordflow}{return} \textcolor{stringliteral}{"{}is <"{}}; \}}
\DoxyCodeLine{782   \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{char}* NegatedDesc() \{ \textcolor{keywordflow}{return} \textcolor{stringliteral}{"{}isn't <"{}}; \}}
\DoxyCodeLine{783 \};}
\DoxyCodeLine{784 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Rhs>}
\DoxyCodeLine{785 \textcolor{keyword}{class }GtMatcher : \textcolor{keyword}{public} ComparisonBase<GtMatcher<Rhs>, Rhs, AnyGt> \{}
\DoxyCodeLine{786  \textcolor{keyword}{public}:}
\DoxyCodeLine{787   \textcolor{keyword}{explicit} GtMatcher(\textcolor{keyword}{const} Rhs\& rhs)}
\DoxyCodeLine{788       : ComparisonBase<GtMatcher<Rhs>, Rhs, AnyGt>(rhs) \{\}}
\DoxyCodeLine{789   \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{char}* Desc() \{ \textcolor{keywordflow}{return} \textcolor{stringliteral}{"{}is >"{}}; \}}
\DoxyCodeLine{790   \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{char}* NegatedDesc() \{ \textcolor{keywordflow}{return} \textcolor{stringliteral}{"{}isn't >"{}}; \}}
\DoxyCodeLine{791 \};}
\DoxyCodeLine{792 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Rhs>}
\DoxyCodeLine{793 \textcolor{keyword}{class }LeMatcher : \textcolor{keyword}{public} ComparisonBase<LeMatcher<Rhs>, Rhs, AnyLe> \{}
\DoxyCodeLine{794  \textcolor{keyword}{public}:}
\DoxyCodeLine{795   \textcolor{keyword}{explicit} LeMatcher(\textcolor{keyword}{const} Rhs\& rhs)}
\DoxyCodeLine{796       : ComparisonBase<LeMatcher<Rhs>, Rhs, AnyLe>(rhs) \{\}}
\DoxyCodeLine{797   \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{char}* Desc() \{ \textcolor{keywordflow}{return} \textcolor{stringliteral}{"{}is <="{}}; \}}
\DoxyCodeLine{798   \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{char}* NegatedDesc() \{ \textcolor{keywordflow}{return} \textcolor{stringliteral}{"{}isn't <="{}}; \}}
\DoxyCodeLine{799 \};}
\DoxyCodeLine{800 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Rhs>}
\DoxyCodeLine{801 \textcolor{keyword}{class }GeMatcher : \textcolor{keyword}{public} ComparisonBase<GeMatcher<Rhs>, Rhs, AnyGe> \{}
\DoxyCodeLine{802  \textcolor{keyword}{public}:}
\DoxyCodeLine{803   \textcolor{keyword}{explicit} GeMatcher(\textcolor{keyword}{const} Rhs\& rhs)}
\DoxyCodeLine{804       : ComparisonBase<GeMatcher<Rhs>, Rhs, AnyGe>(rhs) \{\}}
\DoxyCodeLine{805   \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{char}* Desc() \{ \textcolor{keywordflow}{return} \textcolor{stringliteral}{"{}is >="{}}; \}}
\DoxyCodeLine{806   \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{char}* NegatedDesc() \{ \textcolor{keywordflow}{return} \textcolor{stringliteral}{"{}isn't >="{}}; \}}
\DoxyCodeLine{807 \};}
\DoxyCodeLine{808 }
\DoxyCodeLine{809 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T, \textcolor{keyword}{typename} = \textcolor{keyword}{typename} std::enable\_if<}
\DoxyCodeLine{810                           std::is\_constructible<std::string, T>::value>::type>}
\DoxyCodeLine{811 \textcolor{keyword}{using }StringLike = T;}
\DoxyCodeLine{812 }
\DoxyCodeLine{813 \textcolor{comment}{// Implements polymorphic matchers MatchesRegex(regex) and}}
\DoxyCodeLine{814 \textcolor{comment}{// ContainsRegex(regex), which can be used as a Matcher<T> as long as}}
\DoxyCodeLine{815 \textcolor{comment}{// T can be converted to a string.}}
\DoxyCodeLine{816 \textcolor{keyword}{class }MatchesRegexMatcher \{}
\DoxyCodeLine{817  \textcolor{keyword}{public}:}
\DoxyCodeLine{818   MatchesRegexMatcher(\textcolor{keyword}{const} RE* regex, \textcolor{keywordtype}{bool} full\_match)}
\DoxyCodeLine{819       : regex\_(regex), full\_match\_(full\_match) \{\}}
\DoxyCodeLine{820 }
\DoxyCodeLine{821 \textcolor{preprocessor}{\#if GTEST\_INTERNAL\_HAS\_STRING\_VIEW}}
\DoxyCodeLine{822   \textcolor{keywordtype}{bool} MatchAndExplain(\textcolor{keyword}{const} internal::StringView\& s,}
\DoxyCodeLine{823                        MatchResultListener* listener)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{824     \textcolor{keywordflow}{return} MatchAndExplain(std::string(s), listener);}
\DoxyCodeLine{825   \}}
\DoxyCodeLine{826 \textcolor{preprocessor}{\#endif  }\textcolor{comment}{// GTEST\_INTERNAL\_HAS\_STRING\_VIEW}}
\DoxyCodeLine{827 }
\DoxyCodeLine{828   \textcolor{comment}{// Accepts pointer types, particularly:}}
\DoxyCodeLine{829   \textcolor{comment}{//   const char*}}
\DoxyCodeLine{830   \textcolor{comment}{//   char*}}
\DoxyCodeLine{831   \textcolor{comment}{//   const wchar\_t*}}
\DoxyCodeLine{832   \textcolor{comment}{//   wchar\_t*}}
\DoxyCodeLine{833   \textcolor{keyword}{template} <\textcolor{keyword}{typename} CharType>}
\DoxyCodeLine{834   \textcolor{keywordtype}{bool} MatchAndExplain(CharType* s, MatchResultListener* listener)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{835     \textcolor{keywordflow}{return} s != \textcolor{keyword}{nullptr} \&\& MatchAndExplain(std::string(s), listener);}
\DoxyCodeLine{836   \}}
\DoxyCodeLine{837 }
\DoxyCodeLine{838   \textcolor{comment}{// Matches anything that can convert to std::string.}}
\DoxyCodeLine{839   \textcolor{comment}{//}}
\DoxyCodeLine{840   \textcolor{comment}{// This is a template, not just a plain function with const std::string\&,}}
\DoxyCodeLine{841   \textcolor{comment}{// because absl::string\_view has some interfering non-\/explicit constructors.}}
\DoxyCodeLine{842   \textcolor{keyword}{template} <\textcolor{keyword}{class} MatcheeStringType>}
\DoxyCodeLine{843   \textcolor{keywordtype}{bool} MatchAndExplain(\textcolor{keyword}{const} MatcheeStringType\& s,}
\DoxyCodeLine{844                        MatchResultListener* \textcolor{comment}{/* listener */})\textcolor{keyword}{ const }\{}
\DoxyCodeLine{845     \textcolor{keyword}{const} std::string\& s2(s);}
\DoxyCodeLine{846     \textcolor{keywordflow}{return} full\_match\_ ? RE::FullMatch(s2, *regex\_)}
\DoxyCodeLine{847                        : RE::PartialMatch(s2, *regex\_);}
\DoxyCodeLine{848   \}}
\DoxyCodeLine{849 }
\DoxyCodeLine{850   \textcolor{keywordtype}{void} DescribeTo(::std::ostream* os)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{851     *os << (full\_match\_ ? \textcolor{stringliteral}{"{}matches"{}} : \textcolor{stringliteral}{"{}contains"{}}) << \textcolor{stringliteral}{"{} regular expression "{}};}
\DoxyCodeLine{852     UniversalPrinter<std::string>::Print(regex\_-\/>pattern(), os);}
\DoxyCodeLine{853   \}}
\DoxyCodeLine{854 }
\DoxyCodeLine{855   \textcolor{keywordtype}{void} DescribeNegationTo(::std::ostream* os)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{856     *os << \textcolor{stringliteral}{"{}doesn't "{}} << (full\_match\_ ? \textcolor{stringliteral}{"{}match"{}} : \textcolor{stringliteral}{"{}contain"{}})}
\DoxyCodeLine{857         << \textcolor{stringliteral}{"{} regular expression "{}};}
\DoxyCodeLine{858     UniversalPrinter<std::string>::Print(regex\_-\/>pattern(), os);}
\DoxyCodeLine{859   \}}
\DoxyCodeLine{860 }
\DoxyCodeLine{861  \textcolor{keyword}{private}:}
\DoxyCodeLine{862   \textcolor{keyword}{const} std::shared\_ptr<const RE> regex\_;}
\DoxyCodeLine{863   \textcolor{keyword}{const} \textcolor{keywordtype}{bool} full\_match\_;}
\DoxyCodeLine{864 \};}
\DoxyCodeLine{865 \}  \textcolor{comment}{// namespace internal}}
\DoxyCodeLine{866 }
\DoxyCodeLine{867 \textcolor{comment}{// Matches a string that fully matches regular expression 'regex'.}}
\DoxyCodeLine{868 \textcolor{comment}{// The matcher takes ownership of 'regex'.}}
\DoxyCodeLine{869 \textcolor{keyword}{inline} PolymorphicMatcher<internal::MatchesRegexMatcher> MatchesRegex(}
\DoxyCodeLine{870     \textcolor{keyword}{const} internal::RE* regex) \{}
\DoxyCodeLine{871   \textcolor{keywordflow}{return} MakePolymorphicMatcher(internal::MatchesRegexMatcher(regex, \textcolor{keyword}{true}));}
\DoxyCodeLine{872 \}}
\DoxyCodeLine{873 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T = std::\textcolor{keywordtype}{string}>}
\DoxyCodeLine{874 PolymorphicMatcher<internal::MatchesRegexMatcher> MatchesRegex(}
\DoxyCodeLine{875     \textcolor{keyword}{const} internal::StringLike<T>\& regex) \{}
\DoxyCodeLine{876   \textcolor{keywordflow}{return} MatchesRegex(\textcolor{keyword}{new} internal::RE(std::string(regex)));}
\DoxyCodeLine{877 \}}
\DoxyCodeLine{878 }
\DoxyCodeLine{879 \textcolor{comment}{// Matches a string that contains regular expression 'regex'.}}
\DoxyCodeLine{880 \textcolor{comment}{// The matcher takes ownership of 'regex'.}}
\DoxyCodeLine{881 \textcolor{keyword}{inline} PolymorphicMatcher<internal::MatchesRegexMatcher> ContainsRegex(}
\DoxyCodeLine{882     \textcolor{keyword}{const} internal::RE* regex) \{}
\DoxyCodeLine{883   \textcolor{keywordflow}{return} MakePolymorphicMatcher(internal::MatchesRegexMatcher(regex, \textcolor{keyword}{false}));}
\DoxyCodeLine{884 \}}
\DoxyCodeLine{885 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T = std::\textcolor{keywordtype}{string}>}
\DoxyCodeLine{886 PolymorphicMatcher<internal::MatchesRegexMatcher> ContainsRegex(}
\DoxyCodeLine{887     \textcolor{keyword}{const} internal::StringLike<T>\& regex) \{}
\DoxyCodeLine{888   \textcolor{keywordflow}{return} ContainsRegex(\textcolor{keyword}{new} internal::RE(std::string(regex)));}
\DoxyCodeLine{889 \}}
\DoxyCodeLine{890 }
\DoxyCodeLine{891 \textcolor{comment}{// Creates a polymorphic matcher that matches anything equal to x.}}
\DoxyCodeLine{892 \textcolor{comment}{// Note: if the parameter of Eq() were declared as const T\&, Eq("{}foo"{})}}
\DoxyCodeLine{893 \textcolor{comment}{// wouldn't compile.}}
\DoxyCodeLine{894 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{895 \textcolor{keyword}{inline} internal::EqMatcher<T> Eq(T x) \{}
\DoxyCodeLine{896   \textcolor{keywordflow}{return} internal::EqMatcher<T>(x);}
\DoxyCodeLine{897 \}}
\DoxyCodeLine{898 }
\DoxyCodeLine{899 \textcolor{comment}{// Constructs a Matcher<T> from a 'value' of type T.  The constructed}}
\DoxyCodeLine{900 \textcolor{comment}{// matcher matches any value that's equal to 'value'.}}
\DoxyCodeLine{901 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{902 Matcher<T>::Matcher(T value) \{}
\DoxyCodeLine{903   *\textcolor{keyword}{this} = Eq(value);}
\DoxyCodeLine{904 \}}
\DoxyCodeLine{905 }
\DoxyCodeLine{906 \textcolor{comment}{// Creates a monomorphic matcher that matches anything with type Lhs}}
\DoxyCodeLine{907 \textcolor{comment}{// and equal to rhs.  A user may need to use this instead of Eq(...)}}
\DoxyCodeLine{908 \textcolor{comment}{// in order to resolve an overloading ambiguity.}}
\DoxyCodeLine{909 \textcolor{comment}{//}}
\DoxyCodeLine{910 \textcolor{comment}{// TypedEq<T>(x) is just a convenient short-\/hand for Matcher<T>(Eq(x))}}
\DoxyCodeLine{911 \textcolor{comment}{// or Matcher<T>(x), but more readable than the latter.}}
\DoxyCodeLine{912 \textcolor{comment}{//}}
\DoxyCodeLine{913 \textcolor{comment}{// We could define similar monomorphic matchers for other comparison}}
\DoxyCodeLine{914 \textcolor{comment}{// operations (e.g. TypedLt, TypedGe, and etc), but decided not to do}}
\DoxyCodeLine{915 \textcolor{comment}{// it yet as those are used much less than Eq() in practice.  A user}}
\DoxyCodeLine{916 \textcolor{comment}{// can always write Matcher<T>(Lt(5)) to be explicit about the type,}}
\DoxyCodeLine{917 \textcolor{comment}{// for example.}}
\DoxyCodeLine{918 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Lhs, \textcolor{keyword}{typename} Rhs>}
\DoxyCodeLine{919 \textcolor{keyword}{inline} Matcher<Lhs> TypedEq(\textcolor{keyword}{const} Rhs\& rhs) \{}
\DoxyCodeLine{920   \textcolor{keywordflow}{return} Eq(rhs);}
\DoxyCodeLine{921 \}}
\DoxyCodeLine{922 }
\DoxyCodeLine{923 \textcolor{comment}{// Creates a polymorphic matcher that matches anything >= x.}}
\DoxyCodeLine{924 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Rhs>}
\DoxyCodeLine{925 \textcolor{keyword}{inline} internal::GeMatcher<Rhs> Ge(Rhs x) \{}
\DoxyCodeLine{926   \textcolor{keywordflow}{return} internal::GeMatcher<Rhs>(x);}
\DoxyCodeLine{927 \}}
\DoxyCodeLine{928 }
\DoxyCodeLine{929 \textcolor{comment}{// Creates a polymorphic matcher that matches anything > x.}}
\DoxyCodeLine{930 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Rhs>}
\DoxyCodeLine{931 \textcolor{keyword}{inline} internal::GtMatcher<Rhs> Gt(Rhs x) \{}
\DoxyCodeLine{932   \textcolor{keywordflow}{return} internal::GtMatcher<Rhs>(x);}
\DoxyCodeLine{933 \}}
\DoxyCodeLine{934 }
\DoxyCodeLine{935 \textcolor{comment}{// Creates a polymorphic matcher that matches anything <= x.}}
\DoxyCodeLine{936 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Rhs>}
\DoxyCodeLine{937 \textcolor{keyword}{inline} internal::LeMatcher<Rhs> Le(Rhs x) \{}
\DoxyCodeLine{938   \textcolor{keywordflow}{return} internal::LeMatcher<Rhs>(x);}
\DoxyCodeLine{939 \}}
\DoxyCodeLine{940 }
\DoxyCodeLine{941 \textcolor{comment}{// Creates a polymorphic matcher that matches anything < x.}}
\DoxyCodeLine{942 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Rhs>}
\DoxyCodeLine{943 \textcolor{keyword}{inline} internal::LtMatcher<Rhs> Lt(Rhs x) \{}
\DoxyCodeLine{944   \textcolor{keywordflow}{return} internal::LtMatcher<Rhs>(x);}
\DoxyCodeLine{945 \}}
\DoxyCodeLine{946 }
\DoxyCodeLine{947 \textcolor{comment}{// Creates a polymorphic matcher that matches anything != x.}}
\DoxyCodeLine{948 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Rhs>}
\DoxyCodeLine{949 \textcolor{keyword}{inline} internal::NeMatcher<Rhs> Ne(Rhs x) \{}
\DoxyCodeLine{950   \textcolor{keywordflow}{return} internal::NeMatcher<Rhs>(x);}
\DoxyCodeLine{951 \}}
\DoxyCodeLine{952 \}  \textcolor{comment}{// namespace testing}}
\DoxyCodeLine{953 }
\DoxyCodeLine{954 GTEST\_DISABLE\_MSC\_WARNINGS\_POP\_()  \textcolor{comment}{//  4251 5046}}
\DoxyCodeLine{955 }
\DoxyCodeLine{956 \textcolor{preprocessor}{\#endif  }\textcolor{comment}{// GOOGLETEST\_INCLUDE\_GTEST\_GTEST\_MATCHERS\_H\_}}

\end{DoxyCode}
