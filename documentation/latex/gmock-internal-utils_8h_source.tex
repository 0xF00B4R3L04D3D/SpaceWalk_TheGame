\hypertarget{gmock-internal-utils_8h_source}{}\doxysection{gmock-\/internal-\/utils.h}
\label{gmock-internal-utils_8h_source}\index{build/\_deps/googletest-\/src/googlemock/include/gmock/internal/gmock-\/internal-\/utils.h@{build/\_deps/googletest-\/src/googlemock/include/gmock/internal/gmock-\/internal-\/utils.h}}

\begin{DoxyCode}{0}
\DoxyCodeLine{1 \textcolor{comment}{// Copyright 2007, Google Inc.}}
\DoxyCodeLine{2 \textcolor{comment}{// All rights reserved.}}
\DoxyCodeLine{3 \textcolor{comment}{//}}
\DoxyCodeLine{4 \textcolor{comment}{// Redistribution and use in source and binary forms, with or without}}
\DoxyCodeLine{5 \textcolor{comment}{// modification, are permitted provided that the following conditions are}}
\DoxyCodeLine{6 \textcolor{comment}{// met:}}
\DoxyCodeLine{7 \textcolor{comment}{//}}
\DoxyCodeLine{8 \textcolor{comment}{//     * Redistributions of source code must retain the above copyright}}
\DoxyCodeLine{9 \textcolor{comment}{// notice, this list of conditions and the following disclaimer.}}
\DoxyCodeLine{10 \textcolor{comment}{//     * Redistributions in binary form must reproduce the above}}
\DoxyCodeLine{11 \textcolor{comment}{// copyright notice, this list of conditions and the following disclaimer}}
\DoxyCodeLine{12 \textcolor{comment}{// in the documentation and/or other materials provided with the}}
\DoxyCodeLine{13 \textcolor{comment}{// distribution.}}
\DoxyCodeLine{14 \textcolor{comment}{//     * Neither the name of Google Inc. nor the names of its}}
\DoxyCodeLine{15 \textcolor{comment}{// contributors may be used to endorse or promote products derived from}}
\DoxyCodeLine{16 \textcolor{comment}{// this software without specific prior written permission.}}
\DoxyCodeLine{17 \textcolor{comment}{//}}
\DoxyCodeLine{18 \textcolor{comment}{// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS}}
\DoxyCodeLine{19 \textcolor{comment}{// "{}AS IS"{} AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT}}
\DoxyCodeLine{20 \textcolor{comment}{// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR}}
\DoxyCodeLine{21 \textcolor{comment}{// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT}}
\DoxyCodeLine{22 \textcolor{comment}{// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,}}
\DoxyCodeLine{23 \textcolor{comment}{// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT}}
\DoxyCodeLine{24 \textcolor{comment}{// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,}}
\DoxyCodeLine{25 \textcolor{comment}{// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY}}
\DoxyCodeLine{26 \textcolor{comment}{// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT}}
\DoxyCodeLine{27 \textcolor{comment}{// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE}}
\DoxyCodeLine{28 \textcolor{comment}{// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.}}
\DoxyCodeLine{29 }
\DoxyCodeLine{30 \textcolor{comment}{// Google Mock -\/ a framework for writing C++ mock classes.}}
\DoxyCodeLine{31 \textcolor{comment}{//}}
\DoxyCodeLine{32 \textcolor{comment}{// This file defines some utilities useful for implementing Google}}
\DoxyCodeLine{33 \textcolor{comment}{// Mock.  They are subject to change without notice, so please DO NOT}}
\DoxyCodeLine{34 \textcolor{comment}{// USE THEM IN USER CODE.}}
\DoxyCodeLine{35 }
\DoxyCodeLine{36 \textcolor{comment}{// IWYU pragma: private, include "{}gmock/gmock.h"{}}}
\DoxyCodeLine{37 \textcolor{comment}{// IWYU pragma: friend gmock/.*}}
\DoxyCodeLine{38 }
\DoxyCodeLine{39 \textcolor{preprocessor}{\#ifndef GOOGLEMOCK\_INCLUDE\_GMOCK\_INTERNAL\_GMOCK\_INTERNAL\_UTILS\_H\_}}
\DoxyCodeLine{40 \textcolor{preprocessor}{\#define GOOGLEMOCK\_INCLUDE\_GMOCK\_INTERNAL\_GMOCK\_INTERNAL\_UTILS\_H\_}}
\DoxyCodeLine{41 }
\DoxyCodeLine{42 \textcolor{preprocessor}{\#include <stdio.h>}}
\DoxyCodeLine{43 }
\DoxyCodeLine{44 \textcolor{preprocessor}{\#include <ostream>}  \textcolor{comment}{// NOLINT}}
\DoxyCodeLine{45 \textcolor{preprocessor}{\#include <string>}}
\DoxyCodeLine{46 \textcolor{preprocessor}{\#include <type\_traits>}}
\DoxyCodeLine{47 \textcolor{preprocessor}{\#include <vector>}}
\DoxyCodeLine{48 }
\DoxyCodeLine{49 \textcolor{preprocessor}{\#include "{}gmock/internal/gmock-\/port.h"{}}}
\DoxyCodeLine{50 \textcolor{preprocessor}{\#include "{}gtest/gtest.h"{}}}
\DoxyCodeLine{51 }
\DoxyCodeLine{52 \textcolor{keyword}{namespace }testing \{}
\DoxyCodeLine{53 }
\DoxyCodeLine{54 \textcolor{keyword}{template} <\textcolor{keyword}{typename}>}
\DoxyCodeLine{55 \textcolor{keyword}{class }\mbox{\hyperlink{classtesting_1_1Matcher}{Matcher}};}
\DoxyCodeLine{56 }
\DoxyCodeLine{57 \textcolor{keyword}{namespace }internal \{}
\DoxyCodeLine{58 }
\DoxyCodeLine{59 \textcolor{comment}{// Silence MSVC C4100 (unreferenced formal parameter) and}}
\DoxyCodeLine{60 \textcolor{comment}{// C4805('==': unsafe mix of type 'const int' and type 'const bool')}}
\DoxyCodeLine{61 \textcolor{preprocessor}{\#ifdef \_MSC\_VER}}
\DoxyCodeLine{62 \textcolor{preprocessor}{\#pragma warning(push)}}
\DoxyCodeLine{63 \textcolor{preprocessor}{\#pragma warning(disable : 4100)}}
\DoxyCodeLine{64 \textcolor{preprocessor}{\#pragma warning(disable : 4805)}}
\DoxyCodeLine{65 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{66 }
\DoxyCodeLine{67 \textcolor{comment}{// Joins a vector of strings as if they are fields of a tuple; returns}}
\DoxyCodeLine{68 \textcolor{comment}{// the joined string.}}
\DoxyCodeLine{69 GTEST\_API\_ std::string JoinAsKeyValueTuple(}
\DoxyCodeLine{70     \textcolor{keyword}{const} std::vector<const char*>\& names, \textcolor{keyword}{const} Strings\& values);}
\DoxyCodeLine{71 }
\DoxyCodeLine{72 \textcolor{comment}{// Converts an identifier name to a space-\/separated list of lower-\/case}}
\DoxyCodeLine{73 \textcolor{comment}{// words.  Each maximum substring of the form [A-\/Za-\/z][a-\/z]*|\(\backslash\)d+ is}}
\DoxyCodeLine{74 \textcolor{comment}{// treated as one word.  For example, both "{}FooBar123"{} and}}
\DoxyCodeLine{75 \textcolor{comment}{// "{}foo\_bar\_123"{} are converted to "{}foo bar 123"{}.}}
\DoxyCodeLine{76 GTEST\_API\_ std::string ConvertIdentifierNameToWords(\textcolor{keyword}{const} \textcolor{keywordtype}{char}* id\_name);}
\DoxyCodeLine{77 }
\DoxyCodeLine{78 \textcolor{comment}{// GetRawPointer(p) returns the raw pointer underlying p when p is a}}
\DoxyCodeLine{79 \textcolor{comment}{// smart pointer, or returns p itself when p is already a raw pointer.}}
\DoxyCodeLine{80 \textcolor{comment}{// The following default implementation is for the smart pointer case.}}
\DoxyCodeLine{81 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Po\textcolor{keywordtype}{int}er>}
\DoxyCodeLine{82 \textcolor{keyword}{inline} \textcolor{keyword}{const} \textcolor{keyword}{typename} Pointer::element\_type* GetRawPointer(\textcolor{keyword}{const} Pointer\& p) \{}
\DoxyCodeLine{83   \textcolor{keywordflow}{return} p.get();}
\DoxyCodeLine{84 \}}
\DoxyCodeLine{85 \textcolor{comment}{// This overload version is for std::reference\_wrapper, which does not work with}}
\DoxyCodeLine{86 \textcolor{comment}{// the overload above, as it does not have an `element\_type`.}}
\DoxyCodeLine{87 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Element>}
\DoxyCodeLine{88 \textcolor{keyword}{inline} \textcolor{keyword}{const} Element* GetRawPointer(\textcolor{keyword}{const} std::reference\_wrapper<Element>\& r) \{}
\DoxyCodeLine{89   \textcolor{keywordflow}{return} \&r.get();}
\DoxyCodeLine{90 \}}
\DoxyCodeLine{91 }
\DoxyCodeLine{92 \textcolor{comment}{// This overloaded version is for the raw pointer case.}}
\DoxyCodeLine{93 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Element>}
\DoxyCodeLine{94 \textcolor{keyword}{inline} Element* GetRawPointer(Element* p) \{}
\DoxyCodeLine{95   \textcolor{keywordflow}{return} p;}
\DoxyCodeLine{96 \}}
\DoxyCodeLine{97 }
\DoxyCodeLine{98 \textcolor{comment}{// MSVC treats wchar\_t as a native type usually, but treats it as the}}
\DoxyCodeLine{99 \textcolor{comment}{// same as unsigned short when the compiler option /Zc:wchar\_t-\/ is}}
\DoxyCodeLine{100 \textcolor{comment}{// specified.  It defines \_NATIVE\_WCHAR\_T\_DEFINED symbol when wchar\_t}}
\DoxyCodeLine{101 \textcolor{comment}{// is a native type.}}
\DoxyCodeLine{102 \textcolor{preprocessor}{\#if defined(\_MSC\_VER) \&\& !defined(\_NATIVE\_WCHAR\_T\_DEFINED)}}
\DoxyCodeLine{103 \textcolor{comment}{// wchar\_t is a typedef.}}
\DoxyCodeLine{104 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{105 \textcolor{preprocessor}{\#define GMOCK\_WCHAR\_T\_IS\_NATIVE\_ 1}}
\DoxyCodeLine{106 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{107 }
\DoxyCodeLine{108 \textcolor{comment}{// In what follows, we use the term "{}kind"{} to indicate whether a type}}
\DoxyCodeLine{109 \textcolor{comment}{// is bool, an integer type (excluding bool), a floating-\/point type,}}
\DoxyCodeLine{110 \textcolor{comment}{// or none of them.  This categorization is useful for determining}}
\DoxyCodeLine{111 \textcolor{comment}{// when a matcher argument type can be safely converted to another}}
\DoxyCodeLine{112 \textcolor{comment}{// type in the implementation of SafeMatcherCast.}}
\DoxyCodeLine{113 \textcolor{keyword}{enum} TypeKind \{ kBool, kInteger, kFloatingPoint, kOther \};}
\DoxyCodeLine{114 }
\DoxyCodeLine{115 \textcolor{comment}{// KindOf<T>::value is the kind of type T.}}
\DoxyCodeLine{116 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{117 \textcolor{keyword}{struct }\mbox{\hyperlink{structtesting_1_1internal_1_1KindOf}{KindOf}} \{}
\DoxyCodeLine{118   \textcolor{keyword}{enum} \{ value = kOther \};  \textcolor{comment}{// The default kind.}}
\DoxyCodeLine{119 \};}
\DoxyCodeLine{120 }
\DoxyCodeLine{121 \textcolor{comment}{// This macro declares that the kind of 'type' is 'kind'.}}
\DoxyCodeLine{122 \textcolor{preprocessor}{\#define GMOCK\_DECLARE\_KIND\_(type, kind) \(\backslash\)}}
\DoxyCodeLine{123 \textcolor{preprocessor}{  template <>                           \(\backslash\)}}
\DoxyCodeLine{124 \textcolor{preprocessor}{  struct KindOf<type> \{                 \(\backslash\)}}
\DoxyCodeLine{125 \textcolor{preprocessor}{    enum \{ value = kind \};              \(\backslash\)}}
\DoxyCodeLine{126 \textcolor{preprocessor}{  \}}}
\DoxyCodeLine{127 }
\DoxyCodeLine{128 GMOCK\_DECLARE\_KIND\_(\textcolor{keywordtype}{bool}, kBool);}
\DoxyCodeLine{129 }
\DoxyCodeLine{130 \textcolor{comment}{// All standard integer types.}}
\DoxyCodeLine{131 GMOCK\_DECLARE\_KIND\_(\textcolor{keywordtype}{char}, kInteger);}
\DoxyCodeLine{132 GMOCK\_DECLARE\_KIND\_(\textcolor{keywordtype}{signed} \textcolor{keywordtype}{char}, kInteger);}
\DoxyCodeLine{133 GMOCK\_DECLARE\_KIND\_(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char}, kInteger);}
\DoxyCodeLine{134 GMOCK\_DECLARE\_KIND\_(\textcolor{keywordtype}{short}, kInteger);           \textcolor{comment}{// NOLINT}}
\DoxyCodeLine{135 GMOCK\_DECLARE\_KIND\_(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{short}, kInteger);  \textcolor{comment}{// NOLINT}}
\DoxyCodeLine{136 GMOCK\_DECLARE\_KIND\_(\textcolor{keywordtype}{int}, kInteger);}
\DoxyCodeLine{137 GMOCK\_DECLARE\_KIND\_(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int}, kInteger);}
\DoxyCodeLine{138 GMOCK\_DECLARE\_KIND\_(\textcolor{keywordtype}{long}, kInteger);                \textcolor{comment}{// NOLINT}}
\DoxyCodeLine{139 GMOCK\_DECLARE\_KIND\_(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long}, kInteger);       \textcolor{comment}{// NOLINT}}
\DoxyCodeLine{140 GMOCK\_DECLARE\_KIND\_(\textcolor{keywordtype}{long} \textcolor{keywordtype}{long}, kInteger);           \textcolor{comment}{// NOLINT}}
\DoxyCodeLine{141 GMOCK\_DECLARE\_KIND\_(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long}, kInteger);  \textcolor{comment}{// NOLINT}}
\DoxyCodeLine{142 }
\DoxyCodeLine{143 \textcolor{preprocessor}{\#if GMOCK\_WCHAR\_T\_IS\_NATIVE\_}}
\DoxyCodeLine{144 GMOCK\_DECLARE\_KIND\_(\textcolor{keywordtype}{wchar\_t}, kInteger);}
\DoxyCodeLine{145 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{146 }
\DoxyCodeLine{147 \textcolor{comment}{// All standard floating-\/point types.}}
\DoxyCodeLine{148 GMOCK\_DECLARE\_KIND\_(\textcolor{keywordtype}{float}, kFloatingPoint);}
\DoxyCodeLine{149 GMOCK\_DECLARE\_KIND\_(\textcolor{keywordtype}{double}, kFloatingPoint);}
\DoxyCodeLine{150 GMOCK\_DECLARE\_KIND\_(\textcolor{keywordtype}{long} \textcolor{keywordtype}{double}, kFloatingPoint);}
\DoxyCodeLine{151 }
\DoxyCodeLine{152 \textcolor{preprocessor}{\#undef GMOCK\_DECLARE\_KIND\_}}
\DoxyCodeLine{153 }
\DoxyCodeLine{154 \textcolor{comment}{// Evaluates to the kind of 'type'.}}
\DoxyCodeLine{155 \textcolor{preprocessor}{\#define GMOCK\_KIND\_OF\_(type)                   \(\backslash\)}}
\DoxyCodeLine{156 \textcolor{preprocessor}{  static\_cast< ::testing::internal::TypeKind>( \(\backslash\)}}
\DoxyCodeLine{157 \textcolor{preprocessor}{      ::testing::internal::KindOf<type>::value)}}
\DoxyCodeLine{158 }
\DoxyCodeLine{159 \textcolor{comment}{// LosslessArithmeticConvertibleImpl<kFromKind, From, kToKind, To>::value}}
\DoxyCodeLine{160 \textcolor{comment}{// is true if and only if arithmetic type From can be losslessly converted to}}
\DoxyCodeLine{161 \textcolor{comment}{// arithmetic type To.}}
\DoxyCodeLine{162 \textcolor{comment}{//}}
\DoxyCodeLine{163 \textcolor{comment}{// It's the user's responsibility to ensure that both From and To are}}
\DoxyCodeLine{164 \textcolor{comment}{// raw (i.e. has no CV modifier, is not a pointer, and is not a}}
\DoxyCodeLine{165 \textcolor{comment}{// reference) built-\/in arithmetic types, kFromKind is the kind of}}
\DoxyCodeLine{166 \textcolor{comment}{// From, and kToKind is the kind of To; the value is}}
\DoxyCodeLine{167 \textcolor{comment}{// implementation-\/defined when the above pre-\/condition is violated.}}
\DoxyCodeLine{168 \textcolor{keyword}{template} <TypeKind kFromKind, \textcolor{keyword}{typename} From, TypeKind kToKind, \textcolor{keyword}{typename} To>}
\DoxyCodeLine{169 \textcolor{keyword}{using }LosslessArithmeticConvertibleImpl = std::integral\_constant<}
\DoxyCodeLine{170     bool,}
\DoxyCodeLine{171     \textcolor{comment}{// clang-\/format off}}
\DoxyCodeLine{172       \textcolor{comment}{// Converting from bool is always lossless}}
\DoxyCodeLine{173       (kFromKind == kBool) ? \textcolor{keyword}{true}}
\DoxyCodeLine{174       \textcolor{comment}{// Converting between any other type kinds will be lossy if the type}}
\DoxyCodeLine{175       \textcolor{comment}{// kinds are not the same.}}
\DoxyCodeLine{176     : (kFromKind != kToKind) ? false}
\DoxyCodeLine{177     : (kFromKind == kInteger \&\&}
\DoxyCodeLine{178        \textcolor{comment}{// Converting between integers of different widths is allowed so long}}
\DoxyCodeLine{179        \textcolor{comment}{// as the conversion does not go from signed to unsigned.}}
\DoxyCodeLine{180       (((\textcolor{keyword}{sizeof}(From) < \textcolor{keyword}{sizeof}(\mbox{\hyperlink{classtesting_1_1internal_1_1To}{To}})) \&\&}
\DoxyCodeLine{181         !(std::is\_signed<From>::value \&\& !std::is\_signed<To>::value)) ||}
\DoxyCodeLine{182        \textcolor{comment}{// Converting between integers of the same width only requires the}}
\DoxyCodeLine{183        \textcolor{comment}{// two types to have the same signedness.}}
\DoxyCodeLine{184        ((\textcolor{keyword}{sizeof}(From) == \textcolor{keyword}{sizeof}(\mbox{\hyperlink{classtesting_1_1internal_1_1To}{To}})) \&\&}
\DoxyCodeLine{185         (std::is\_signed<From>::value == std::is\_signed<To>::value)))}
\DoxyCodeLine{186        ) ? \textcolor{keyword}{true}}
\DoxyCodeLine{187       \textcolor{comment}{// Floating point conversions are lossless if and only if `To` is at least}}
\DoxyCodeLine{188       \textcolor{comment}{// as wide as `From`.}}
\DoxyCodeLine{189     : (kFromKind == kFloatingPoint \&\& (\textcolor{keyword}{sizeof}(From) <= \textcolor{keyword}{sizeof}(\mbox{\hyperlink{classtesting_1_1internal_1_1To}{To}}))) ? true}
\DoxyCodeLine{190     : \textcolor{keyword}{false}}
\DoxyCodeLine{191     \textcolor{comment}{// clang-\/format on}}
\DoxyCodeLine{192     >;}
\DoxyCodeLine{193 }
\DoxyCodeLine{194 \textcolor{comment}{// LosslessArithmeticConvertible<From, To>::value is true if and only if}}
\DoxyCodeLine{195 \textcolor{comment}{// arithmetic type From can be losslessly converted to arithmetic type To.}}
\DoxyCodeLine{196 \textcolor{comment}{//}}
\DoxyCodeLine{197 \textcolor{comment}{// It's the user's responsibility to ensure that both From and To are}}
\DoxyCodeLine{198 \textcolor{comment}{// raw (i.e. has no CV modifier, is not a pointer, and is not a}}
\DoxyCodeLine{199 \textcolor{comment}{// reference) built-\/in arithmetic types; the value is}}
\DoxyCodeLine{200 \textcolor{comment}{// implementation-\/defined when the above pre-\/condition is violated.}}
\DoxyCodeLine{201 \textcolor{keyword}{template} <\textcolor{keyword}{typename} From, \textcolor{keyword}{typename} To>}
\DoxyCodeLine{202 \textcolor{keyword}{using }LosslessArithmeticConvertible =}
\DoxyCodeLine{203     LosslessArithmeticConvertibleImpl<GMOCK\_KIND\_OF\_(From), From,}
\DoxyCodeLine{204                                       GMOCK\_KIND\_OF\_(\mbox{\hyperlink{classtesting_1_1internal_1_1To}{To}}), \mbox{\hyperlink{classtesting_1_1internal_1_1To}{To}}>;}
\DoxyCodeLine{205 }
\DoxyCodeLine{206 \textcolor{comment}{// This interface knows how to report a Google Mock failure (either}}
\DoxyCodeLine{207 \textcolor{comment}{// non-\/fatal or fatal).}}
\DoxyCodeLine{208 \textcolor{keyword}{class }\mbox{\hyperlink{classtesting_1_1internal_1_1FailureReporterInterface}{FailureReporterInterface}} \{}
\DoxyCodeLine{209  \textcolor{keyword}{public}:}
\DoxyCodeLine{210   \textcolor{comment}{// The type of a failure (either non-\/fatal or fatal).}}
\DoxyCodeLine{211   \textcolor{keyword}{enum} FailureType \{ kNonfatal, kFatal \};}
\DoxyCodeLine{212 }
\DoxyCodeLine{213   \textcolor{keyword}{virtual} \mbox{\hyperlink{classtesting_1_1internal_1_1FailureReporterInterface}{\string~FailureReporterInterface}}() \{\}}
\DoxyCodeLine{214 }
\DoxyCodeLine{215   \textcolor{comment}{// Reports a failure that occurred at the given source file location.}}
\DoxyCodeLine{216   \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} ReportFailure(FailureType type, \textcolor{keyword}{const} \textcolor{keywordtype}{char}* file, \textcolor{keywordtype}{int} line,}
\DoxyCodeLine{217                              \textcolor{keyword}{const} std::string\& message) = 0;}
\DoxyCodeLine{218 \};}
\DoxyCodeLine{219 }
\DoxyCodeLine{220 \textcolor{comment}{// Returns the failure reporter used by Google Mock.}}
\DoxyCodeLine{221 GTEST\_API\_ \mbox{\hyperlink{classtesting_1_1internal_1_1FailureReporterInterface}{FailureReporterInterface}}* GetFailureReporter();}
\DoxyCodeLine{222 }
\DoxyCodeLine{223 \textcolor{comment}{// Asserts that condition is true; aborts the process with the given}}
\DoxyCodeLine{224 \textcolor{comment}{// message if condition is false.  We cannot use LOG(FATAL) or CHECK()}}
\DoxyCodeLine{225 \textcolor{comment}{// as Google Mock might be used to mock the log sink itself.  We}}
\DoxyCodeLine{226 \textcolor{comment}{// inline this function to prevent it from showing up in the stack}}
\DoxyCodeLine{227 \textcolor{comment}{// trace.}}
\DoxyCodeLine{228 \textcolor{keyword}{inline} \textcolor{keywordtype}{void} Assert(\textcolor{keywordtype}{bool} condition, \textcolor{keyword}{const} \textcolor{keywordtype}{char}* file, \textcolor{keywordtype}{int} line,}
\DoxyCodeLine{229                    \textcolor{keyword}{const} std::string\& msg) \{}
\DoxyCodeLine{230   \textcolor{keywordflow}{if} (!condition) \{}
\DoxyCodeLine{231     GetFailureReporter()-\/>ReportFailure(FailureReporterInterface::kFatal, file,}
\DoxyCodeLine{232                                         line, msg);}
\DoxyCodeLine{233   \}}
\DoxyCodeLine{234 \}}
\DoxyCodeLine{235 \textcolor{keyword}{inline} \textcolor{keywordtype}{void} Assert(\textcolor{keywordtype}{bool} condition, \textcolor{keyword}{const} \textcolor{keywordtype}{char}* file, \textcolor{keywordtype}{int} line) \{}
\DoxyCodeLine{236   Assert(condition, file, line, \textcolor{stringliteral}{"{}Assertion failed."{}});}
\DoxyCodeLine{237 \}}
\DoxyCodeLine{238 }
\DoxyCodeLine{239 \textcolor{comment}{// Verifies that condition is true; generates a non-\/fatal failure if}}
\DoxyCodeLine{240 \textcolor{comment}{// condition is false.}}
\DoxyCodeLine{241 \textcolor{keyword}{inline} \textcolor{keywordtype}{void} Expect(\textcolor{keywordtype}{bool} condition, \textcolor{keyword}{const} \textcolor{keywordtype}{char}* file, \textcolor{keywordtype}{int} line,}
\DoxyCodeLine{242                    \textcolor{keyword}{const} std::string\& msg) \{}
\DoxyCodeLine{243   \textcolor{keywordflow}{if} (!condition) \{}
\DoxyCodeLine{244     GetFailureReporter()-\/>ReportFailure(FailureReporterInterface::kNonfatal,}
\DoxyCodeLine{245                                         file, line, msg);}
\DoxyCodeLine{246   \}}
\DoxyCodeLine{247 \}}
\DoxyCodeLine{248 \textcolor{keyword}{inline} \textcolor{keywordtype}{void} Expect(\textcolor{keywordtype}{bool} condition, \textcolor{keyword}{const} \textcolor{keywordtype}{char}* file, \textcolor{keywordtype}{int} line) \{}
\DoxyCodeLine{249   Expect(condition, file, line, \textcolor{stringliteral}{"{}Expectation failed."{}});}
\DoxyCodeLine{250 \}}
\DoxyCodeLine{251 }
\DoxyCodeLine{252 \textcolor{comment}{// Severity level of a log.}}
\DoxyCodeLine{253 \textcolor{keyword}{enum} LogSeverity \{ kInfo = 0, kWarning = 1 \};}
\DoxyCodeLine{254 }
\DoxyCodeLine{255 \textcolor{comment}{// Valid values for the -\/-\/gmock\_verbose flag.}}
\DoxyCodeLine{256 }
\DoxyCodeLine{257 \textcolor{comment}{// All logs (informational and warnings) are printed.}}
\DoxyCodeLine{258 \textcolor{keyword}{const} \textcolor{keywordtype}{char} kInfoVerbosity[] = \textcolor{stringliteral}{"{}info"{}};}
\DoxyCodeLine{259 \textcolor{comment}{// Only warnings are printed.}}
\DoxyCodeLine{260 \textcolor{keyword}{const} \textcolor{keywordtype}{char} kWarningVerbosity[] = \textcolor{stringliteral}{"{}warning"{}};}
\DoxyCodeLine{261 \textcolor{comment}{// No logs are printed.}}
\DoxyCodeLine{262 \textcolor{keyword}{const} \textcolor{keywordtype}{char} kErrorVerbosity[] = \textcolor{stringliteral}{"{}error"{}};}
\DoxyCodeLine{263 }
\DoxyCodeLine{264 \textcolor{comment}{// Returns true if and only if a log with the given severity is visible}}
\DoxyCodeLine{265 \textcolor{comment}{// according to the -\/-\/gmock\_verbose flag.}}
\DoxyCodeLine{266 GTEST\_API\_ \textcolor{keywordtype}{bool} LogIsVisible(LogSeverity severity);}
\DoxyCodeLine{267 }
\DoxyCodeLine{268 \textcolor{comment}{// Prints the given message to stdout if and only if 'severity' >= the level}}
\DoxyCodeLine{269 \textcolor{comment}{// specified by the -\/-\/gmock\_verbose flag.  If stack\_frames\_to\_skip >=}}
\DoxyCodeLine{270 \textcolor{comment}{// 0, also prints the stack trace excluding the top}}
\DoxyCodeLine{271 \textcolor{comment}{// stack\_frames\_to\_skip frames.  In opt mode, any positive}}
\DoxyCodeLine{272 \textcolor{comment}{// stack\_frames\_to\_skip is treated as 0, since we don't know which}}
\DoxyCodeLine{273 \textcolor{comment}{// function calls will be inlined by the compiler and need to be}}
\DoxyCodeLine{274 \textcolor{comment}{// conservative.}}
\DoxyCodeLine{275 GTEST\_API\_ \textcolor{keywordtype}{void} Log(LogSeverity severity, \textcolor{keyword}{const} std::string\& message,}
\DoxyCodeLine{276                     \textcolor{keywordtype}{int} stack\_frames\_to\_skip);}
\DoxyCodeLine{277 }
\DoxyCodeLine{278 \textcolor{comment}{// A marker class that is used to resolve parameterless expectations to the}}
\DoxyCodeLine{279 \textcolor{comment}{// correct overload. This must not be instantiable, to prevent client code from}}
\DoxyCodeLine{280 \textcolor{comment}{// accidentally resolving to the overload; for example:}}
\DoxyCodeLine{281 \textcolor{comment}{//}}
\DoxyCodeLine{282 \textcolor{comment}{//    ON\_CALL(mock, Method(\{\}, nullptr))...}}
\DoxyCodeLine{283 \textcolor{comment}{//}}
\DoxyCodeLine{284 \textcolor{keyword}{class }\mbox{\hyperlink{classtesting_1_1internal_1_1WithoutMatchers}{WithoutMatchers}} \{}
\DoxyCodeLine{285  \textcolor{keyword}{private}:}
\DoxyCodeLine{286   \mbox{\hyperlink{classtesting_1_1internal_1_1WithoutMatchers}{WithoutMatchers}}() \{\}}
\DoxyCodeLine{287   \textcolor{keyword}{friend} GTEST\_API\_ \mbox{\hyperlink{classtesting_1_1internal_1_1WithoutMatchers}{WithoutMatchers}} GetWithoutMatchers();}
\DoxyCodeLine{288 \};}
\DoxyCodeLine{289 }
\DoxyCodeLine{290 \textcolor{comment}{// Internal use only: access the singleton instance of WithoutMatchers.}}
\DoxyCodeLine{291 GTEST\_API\_ \mbox{\hyperlink{classtesting_1_1internal_1_1WithoutMatchers}{WithoutMatchers}} GetWithoutMatchers();}
\DoxyCodeLine{292 }
\DoxyCodeLine{293 \textcolor{comment}{// Disable MSVC warnings for infinite recursion, since in this case the}}
\DoxyCodeLine{294 \textcolor{comment}{// recursion is unreachable.}}
\DoxyCodeLine{295 \textcolor{preprocessor}{\#ifdef \_MSC\_VER}}
\DoxyCodeLine{296 \textcolor{preprocessor}{\#pragma warning(push)}}
\DoxyCodeLine{297 \textcolor{preprocessor}{\#pragma warning(disable : 4717)}}
\DoxyCodeLine{298 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{299 }
\DoxyCodeLine{300 \textcolor{comment}{// Invalid<T>() is usable as an expression of type T, but will terminate}}
\DoxyCodeLine{301 \textcolor{comment}{// the program with an assertion failure if actually run.  This is useful}}
\DoxyCodeLine{302 \textcolor{comment}{// when a value of type T is needed for compilation, but the statement}}
\DoxyCodeLine{303 \textcolor{comment}{// will not really be executed (or we don't care if the statement}}
\DoxyCodeLine{304 \textcolor{comment}{// crashes).}}
\DoxyCodeLine{305 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{306 \textcolor{keyword}{inline} T Invalid() \{}
\DoxyCodeLine{307   Assert(\textcolor{keyword}{false}, \textcolor{stringliteral}{"{}"{}}, -\/1, \textcolor{stringliteral}{"{}Internal error: attempt to return invalid value"{}});}
\DoxyCodeLine{308 \textcolor{preprocessor}{\#if defined(\_\_GNUC\_\_) || defined(\_\_clang\_\_)}}
\DoxyCodeLine{309   \_\_builtin\_unreachable();}
\DoxyCodeLine{310 \textcolor{preprocessor}{\#elif defined(\_MSC\_VER)}}
\DoxyCodeLine{311   \_\_assume(0);}
\DoxyCodeLine{312 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{313   \textcolor{keywordflow}{return} Invalid<T>();}
\DoxyCodeLine{314 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{315 \}}
\DoxyCodeLine{316 }
\DoxyCodeLine{317 \textcolor{preprocessor}{\#ifdef \_MSC\_VER}}
\DoxyCodeLine{318 \textcolor{preprocessor}{\#pragma warning(pop)}}
\DoxyCodeLine{319 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{320 }
\DoxyCodeLine{321 \textcolor{comment}{// Given a raw type (i.e. having no top-\/level reference or const}}
\DoxyCodeLine{322 \textcolor{comment}{// modifier) RawContainer that's either an STL-\/style container or a}}
\DoxyCodeLine{323 \textcolor{comment}{// native array, class StlContainerView<RawContainer> has the}}
\DoxyCodeLine{324 \textcolor{comment}{// following members:}}
\DoxyCodeLine{325 \textcolor{comment}{//}}
\DoxyCodeLine{326 \textcolor{comment}{//   -\/ type is a type that provides an STL-\/style container view to}}
\DoxyCodeLine{327 \textcolor{comment}{//     (i.e. implements the STL container concept for) RawContainer;}}
\DoxyCodeLine{328 \textcolor{comment}{//   -\/ const\_reference is a type that provides a reference to a const}}
\DoxyCodeLine{329 \textcolor{comment}{//     RawContainer;}}
\DoxyCodeLine{330 \textcolor{comment}{//   -\/ ConstReference(raw\_container) returns a const reference to an STL-\/style}}
\DoxyCodeLine{331 \textcolor{comment}{//     container view to raw\_container, which is a RawContainer.}}
\DoxyCodeLine{332 \textcolor{comment}{//   -\/ Copy(raw\_container) returns an STL-\/style container view of a}}
\DoxyCodeLine{333 \textcolor{comment}{//     copy of raw\_container, which is a RawContainer.}}
\DoxyCodeLine{334 \textcolor{comment}{//}}
\DoxyCodeLine{335 \textcolor{comment}{// This generic version is used when RawContainer itself is already an}}
\DoxyCodeLine{336 \textcolor{comment}{// STL-\/style container.}}
\DoxyCodeLine{337 \textcolor{keyword}{template} <\textcolor{keyword}{class} RawContainer>}
\DoxyCodeLine{338 \textcolor{keyword}{class }\mbox{\hyperlink{classtesting_1_1internal_1_1StlContainerView}{StlContainerView}} \{}
\DoxyCodeLine{339  \textcolor{keyword}{public}:}
\DoxyCodeLine{340   \textcolor{keyword}{typedef} RawContainer type;}
\DoxyCodeLine{341   \textcolor{keyword}{typedef} \textcolor{keyword}{const} type\& const\_reference;}
\DoxyCodeLine{342 }
\DoxyCodeLine{343   \textcolor{keyword}{static} const\_reference ConstReference(\textcolor{keyword}{const} RawContainer\& container) \{}
\DoxyCodeLine{344     \textcolor{keyword}{static\_assert}(!std::is\_const<RawContainer>::value,}
\DoxyCodeLine{345                   \textcolor{stringliteral}{"{}RawContainer type must not be const"{}});}
\DoxyCodeLine{346     \textcolor{keywordflow}{return} container;}
\DoxyCodeLine{347   \}}
\DoxyCodeLine{348   \textcolor{keyword}{static} type Copy(\textcolor{keyword}{const} RawContainer\& container) \{ \textcolor{keywordflow}{return} container; \}}
\DoxyCodeLine{349 \};}
\DoxyCodeLine{350 }
\DoxyCodeLine{351 \textcolor{comment}{// This specialization is used when RawContainer is a native array type.}}
\DoxyCodeLine{352 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Element, \textcolor{keywordtype}{size\_t} N>}
\DoxyCodeLine{353 \textcolor{keyword}{class }\mbox{\hyperlink{classtesting_1_1internal_1_1StlContainerView}{StlContainerView}}<Element[N]> \{}
\DoxyCodeLine{354  \textcolor{keyword}{public}:}
\DoxyCodeLine{355   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} std::remove\_const<Element>::type RawElement;}
\DoxyCodeLine{356   \textcolor{keyword}{typedef} \mbox{\hyperlink{classtesting_1_1internal_1_1NativeArray}{internal::NativeArray<RawElement>}} \mbox{\hyperlink{classtesting_1_1internal_1_1NativeArray}{type}};}
\DoxyCodeLine{357   \textcolor{comment}{// NativeArray<T> can represent a native array either by value or by}}
\DoxyCodeLine{358   \textcolor{comment}{// reference (selected by a constructor argument), so 'const type'}}
\DoxyCodeLine{359   \textcolor{comment}{// can be used to reference a const native array.  We cannot}}
\DoxyCodeLine{360   \textcolor{comment}{// 'typedef const type\& const\_reference' here, as that would mean}}
\DoxyCodeLine{361   \textcolor{comment}{// ConstReference() has to return a reference to a local variable.}}
\DoxyCodeLine{362   \textcolor{keyword}{typedef} \textcolor{keyword}{const} \mbox{\hyperlink{classtesting_1_1internal_1_1NativeArray}{type}} \mbox{\hyperlink{classtesting_1_1internal_1_1NativeArray}{const\_reference}};}
\DoxyCodeLine{363 }
\DoxyCodeLine{364   \textcolor{keyword}{static} \mbox{\hyperlink{classtesting_1_1internal_1_1NativeArray}{const\_reference}} ConstReference(\textcolor{keyword}{const} Element (\&array)[N]) \{}
\DoxyCodeLine{365     \textcolor{keyword}{static\_assert}(std::is\_same<Element, RawElement>::value,}
\DoxyCodeLine{366                   \textcolor{stringliteral}{"{}Element type must not be const"{}});}
\DoxyCodeLine{367     \textcolor{keywordflow}{return} \mbox{\hyperlink{classtesting_1_1internal_1_1NativeArray}{type}}(array, N, \mbox{\hyperlink{structtesting_1_1internal_1_1RelationToSourceReference}{RelationToSourceReference}}());}
\DoxyCodeLine{368   \}}
\DoxyCodeLine{369   \textcolor{keyword}{static} \mbox{\hyperlink{classtesting_1_1internal_1_1NativeArray}{type}} Copy(\textcolor{keyword}{const} Element (\&array)[N]) \{}
\DoxyCodeLine{370     \textcolor{keywordflow}{return} \mbox{\hyperlink{classtesting_1_1internal_1_1NativeArray}{type}}(array, N, \mbox{\hyperlink{structtesting_1_1internal_1_1RelationToSourceCopy}{RelationToSourceCopy}}());}
\DoxyCodeLine{371   \}}
\DoxyCodeLine{372 \};}
\DoxyCodeLine{373 }
\DoxyCodeLine{374 \textcolor{comment}{// This specialization is used when RawContainer is a native array}}
\DoxyCodeLine{375 \textcolor{comment}{// represented as a (pointer, size) tuple.}}
\DoxyCodeLine{376 \textcolor{keyword}{template} <\textcolor{keyword}{typename} ElementPo\textcolor{keywordtype}{int}er, \textcolor{keyword}{typename} Size>}
\DoxyCodeLine{377 \textcolor{keyword}{class }\mbox{\hyperlink{classtesting_1_1internal_1_1StlContainerView}{StlContainerView}}< ::std::tuple<ElementPointer, Size> > \{}
\DoxyCodeLine{378  \textcolor{keyword}{public}:}
\DoxyCodeLine{379   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} std::remove\_const<}
\DoxyCodeLine{380       \textcolor{keyword}{typename} std::pointer\_traits<ElementPointer>::element\_type>::type}
\DoxyCodeLine{381       RawElement;}
\DoxyCodeLine{382   \textcolor{keyword}{typedef} \mbox{\hyperlink{classtesting_1_1internal_1_1NativeArray}{internal::NativeArray<RawElement>}} \mbox{\hyperlink{classtesting_1_1internal_1_1NativeArray}{type}};}
\DoxyCodeLine{383   \textcolor{keyword}{typedef} \textcolor{keyword}{const} \mbox{\hyperlink{classtesting_1_1internal_1_1NativeArray}{type}} \mbox{\hyperlink{classtesting_1_1internal_1_1NativeArray}{const\_reference}};}
\DoxyCodeLine{384 }
\DoxyCodeLine{385   \textcolor{keyword}{static} \mbox{\hyperlink{classtesting_1_1internal_1_1NativeArray}{const\_reference}} ConstReference(}
\DoxyCodeLine{386       const ::std::tuple<ElementPointer, Size>\& array) \{}
\DoxyCodeLine{387     \textcolor{keywordflow}{return} \mbox{\hyperlink{classtesting_1_1internal_1_1NativeArray}{type}}(std::get<0>(array), std::get<1>(array),}
\DoxyCodeLine{388                 \mbox{\hyperlink{structtesting_1_1internal_1_1RelationToSourceReference}{RelationToSourceReference}}());}
\DoxyCodeLine{389   \}}
\DoxyCodeLine{390   \textcolor{keyword}{static} \mbox{\hyperlink{classtesting_1_1internal_1_1NativeArray}{type}} Copy(const ::std::tuple<ElementPointer, Size>\& array) \{}
\DoxyCodeLine{391     \textcolor{keywordflow}{return} \mbox{\hyperlink{classtesting_1_1internal_1_1NativeArray}{type}}(std::get<0>(array), std::get<1>(array), \mbox{\hyperlink{structtesting_1_1internal_1_1RelationToSourceCopy}{RelationToSourceCopy}}());}
\DoxyCodeLine{392   \}}
\DoxyCodeLine{393 \};}
\DoxyCodeLine{394 }
\DoxyCodeLine{395 \textcolor{comment}{// The following specialization prevents the user from instantiating}}
\DoxyCodeLine{396 \textcolor{comment}{// StlContainer with a reference type.}}
\DoxyCodeLine{397 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{398 \textcolor{keyword}{class }\mbox{\hyperlink{classtesting_1_1internal_1_1StlContainerView}{StlContainerView}}<T\&>;}
\DoxyCodeLine{399 }
\DoxyCodeLine{400 \textcolor{comment}{// A type transform to remove constness from the first part of a pair.}}
\DoxyCodeLine{401 \textcolor{comment}{// Pairs like that are used as the value\_type of associative containers,}}
\DoxyCodeLine{402 \textcolor{comment}{// and this transform produces a similar but assignable pair.}}
\DoxyCodeLine{403 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{404 \textcolor{keyword}{struct }\mbox{\hyperlink{structtesting_1_1internal_1_1RemoveConstFromKey}{RemoveConstFromKey}} \{}
\DoxyCodeLine{405   \textcolor{keyword}{typedef} T type;}
\DoxyCodeLine{406 \};}
\DoxyCodeLine{407 }
\DoxyCodeLine{408 \textcolor{comment}{// Partially specialized to remove constness from std::pair<const K, V>.}}
\DoxyCodeLine{409 \textcolor{keyword}{template} <\textcolor{keyword}{typename} K, \textcolor{keyword}{typename} V>}
\DoxyCodeLine{410 \textcolor{keyword}{struct }\mbox{\hyperlink{structtesting_1_1internal_1_1RemoveConstFromKey}{RemoveConstFromKey}}<std::pair<const K, V> > \{}
\DoxyCodeLine{411   \textcolor{keyword}{typedef} std::pair<K, V> type;}
\DoxyCodeLine{412 \};}
\DoxyCodeLine{413 }
\DoxyCodeLine{414 \textcolor{comment}{// Emit an assertion failure due to incorrect DoDefault() usage. Out-\/of-\/lined to}}
\DoxyCodeLine{415 \textcolor{comment}{// reduce code size.}}
\DoxyCodeLine{416 GTEST\_API\_ \textcolor{keywordtype}{void} IllegalDoDefault(\textcolor{keyword}{const} \textcolor{keywordtype}{char}* file, \textcolor{keywordtype}{int} line);}
\DoxyCodeLine{417 }
\DoxyCodeLine{418 \textcolor{keyword}{template} <\textcolor{keyword}{typename} F, \textcolor{keyword}{typename} Tuple, \textcolor{keywordtype}{size\_t}... Idx>}
\DoxyCodeLine{419 \textcolor{keyword}{auto} ApplyImpl(F\&\& f, Tuple\&\& args, \mbox{\hyperlink{structtesting_1_1internal_1_1IndexSequence}{IndexSequence<Idx...>}})}
\DoxyCodeLine{420     -\/> \textcolor{keyword}{decltype}(std::forward<F>(f)(}
\DoxyCodeLine{421         std::get<Idx>(std::forward<Tuple>(args))...)) \{}
\DoxyCodeLine{422   \textcolor{keywordflow}{return} std::forward<F>(f)(std::get<Idx>(std::forward<Tuple>(args))...);}
\DoxyCodeLine{423 \}}
\DoxyCodeLine{424 }
\DoxyCodeLine{425 \textcolor{comment}{// Apply the function to a tuple of arguments.}}
\DoxyCodeLine{426 \textcolor{keyword}{template} <\textcolor{keyword}{typename} F, \textcolor{keyword}{typename} Tuple>}
\DoxyCodeLine{427 \textcolor{keyword}{auto} Apply(F\&\& f, Tuple\&\& args) -\/> \textcolor{keyword}{decltype}(ApplyImpl(}
\DoxyCodeLine{428     std::forward<F>(f), std::forward<Tuple>(args),}
\DoxyCodeLine{429     MakeIndexSequence<std::tuple\_size<}
\DoxyCodeLine{430         \textcolor{keyword}{typename} std::remove\_reference<Tuple>::type>::value>())) \{}
\DoxyCodeLine{431   \textcolor{keywordflow}{return} ApplyImpl(std::forward<F>(f), std::forward<Tuple>(args),}
\DoxyCodeLine{432                    MakeIndexSequence<std::tuple\_size<}
\DoxyCodeLine{433                        \textcolor{keyword}{typename} std::remove\_reference<Tuple>::type>::value>());}
\DoxyCodeLine{434 \}}
\DoxyCodeLine{435 }
\DoxyCodeLine{436 \textcolor{comment}{// Template struct Function<F>, where F must be a function type, contains}}
\DoxyCodeLine{437 \textcolor{comment}{// the following typedefs:}}
\DoxyCodeLine{438 \textcolor{comment}{//}}
\DoxyCodeLine{439 \textcolor{comment}{//   Result:               the function's return type.}}
\DoxyCodeLine{440 \textcolor{comment}{//   Arg<N>:               the type of the N-\/th argument, where N starts with 0.}}
\DoxyCodeLine{441 \textcolor{comment}{//   ArgumentTuple:        the tuple type consisting of all parameters of F.}}
\DoxyCodeLine{442 \textcolor{comment}{//   ArgumentMatcherTuple: the tuple type consisting of Matchers for all}}
\DoxyCodeLine{443 \textcolor{comment}{//                         parameters of F.}}
\DoxyCodeLine{444 \textcolor{comment}{//   MakeResultVoid:       the function type obtained by substituting void}}
\DoxyCodeLine{445 \textcolor{comment}{//                         for the return type of F.}}
\DoxyCodeLine{446 \textcolor{comment}{//   MakeResultIgnoredValue:}}
\DoxyCodeLine{447 \textcolor{comment}{//                         the function type obtained by substituting Something}}
\DoxyCodeLine{448 \textcolor{comment}{//                         for the return type of F.}}
\DoxyCodeLine{449 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{450 \textcolor{keyword}{struct }\mbox{\hyperlink{structtesting_1_1internal_1_1Function}{Function}};}
\DoxyCodeLine{451 }
\DoxyCodeLine{452 \textcolor{keyword}{template} <\textcolor{keyword}{typename} R, \textcolor{keyword}{typename}... Args>}
\DoxyCodeLine{453 \textcolor{keyword}{struct }\mbox{\hyperlink{structtesting_1_1internal_1_1Function}{Function}}<R(Args...)> \{}
\DoxyCodeLine{454   \textcolor{keyword}{using }Result = R;}
\DoxyCodeLine{455   \textcolor{keyword}{static} \textcolor{keyword}{constexpr} \textcolor{keywordtype}{size\_t} ArgumentCount = \textcolor{keyword}{sizeof}...(Args);}
\DoxyCodeLine{456   \textcolor{keyword}{template} <\textcolor{keywordtype}{size\_t} I>}
\DoxyCodeLine{457   \textcolor{keyword}{using }\mbox{\hyperlink{structtesting_1_1internal_1_1ElemFromList}{Arg}} = \mbox{\hyperlink{structtesting_1_1internal_1_1ElemFromList}{ElemFromList}}<I, Args...>;}
\DoxyCodeLine{458   \textcolor{keyword}{using }ArgumentTuple = std::tuple<Args...>;}
\DoxyCodeLine{459   \textcolor{keyword}{using }ArgumentMatcherTuple = std::tuple<Matcher<Args>...>;}
\DoxyCodeLine{460   \textcolor{keyword}{using }MakeResultVoid = void(Args...);}
\DoxyCodeLine{461   \textcolor{keyword}{using }MakeResultIgnoredValue = \mbox{\hyperlink{classtesting_1_1internal_1_1IgnoredValue}{IgnoredValue}}(Args...);}
\DoxyCodeLine{462 \};}
\DoxyCodeLine{463 }
\DoxyCodeLine{464 \textcolor{keyword}{template} <\textcolor{keyword}{typename} R, \textcolor{keyword}{typename}... Args>}
\DoxyCodeLine{465 \textcolor{keyword}{constexpr} \textcolor{keywordtype}{size\_t} \mbox{\hyperlink{structtesting_1_1internal_1_1Function}{Function}}<R(Args...)>::ArgumentCount;}
\DoxyCodeLine{466 }
\DoxyCodeLine{467 \textcolor{keywordtype}{bool} Base64Unescape(\textcolor{keyword}{const} std::string\& encoded, std::string* decoded);}
\DoxyCodeLine{468 }
\DoxyCodeLine{469 \textcolor{preprocessor}{\#ifdef \_MSC\_VER}}
\DoxyCodeLine{470 \textcolor{preprocessor}{\#pragma warning(pop)}}
\DoxyCodeLine{471 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{472 }
\DoxyCodeLine{473 \}  \textcolor{comment}{// namespace internal}}
\DoxyCodeLine{474 \}  \textcolor{comment}{// namespace testing}}
\DoxyCodeLine{475 }
\DoxyCodeLine{476 \textcolor{preprocessor}{\#endif  }\textcolor{comment}{// GOOGLEMOCK\_INCLUDE\_GMOCK\_INTERNAL\_GMOCK\_INTERNAL\_UTILS\_H\_}}

\end{DoxyCode}
