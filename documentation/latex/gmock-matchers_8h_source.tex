\hypertarget{gmock-matchers_8h_source}{}\doxysection{gmock-\/matchers.h}
\label{gmock-matchers_8h_source}\index{build/\_deps/googletest-\/src/googlemock/include/gmock/gmock-\/matchers.h@{build/\_deps/googletest-\/src/googlemock/include/gmock/gmock-\/matchers.h}}

\begin{DoxyCode}{0}
\DoxyCodeLine{1 \textcolor{comment}{// Copyright 2007, Google Inc.}}
\DoxyCodeLine{2 \textcolor{comment}{// All rights reserved.}}
\DoxyCodeLine{3 \textcolor{comment}{//}}
\DoxyCodeLine{4 \textcolor{comment}{// Redistribution and use in source and binary forms, with or without}}
\DoxyCodeLine{5 \textcolor{comment}{// modification, are permitted provided that the following conditions are}}
\DoxyCodeLine{6 \textcolor{comment}{// met:}}
\DoxyCodeLine{7 \textcolor{comment}{//}}
\DoxyCodeLine{8 \textcolor{comment}{//     * Redistributions of source code must retain the above copyright}}
\DoxyCodeLine{9 \textcolor{comment}{// notice, this list of conditions and the following disclaimer.}}
\DoxyCodeLine{10 \textcolor{comment}{//     * Redistributions in binary form must reproduce the above}}
\DoxyCodeLine{11 \textcolor{comment}{// copyright notice, this list of conditions and the following disclaimer}}
\DoxyCodeLine{12 \textcolor{comment}{// in the documentation and/or other materials provided with the}}
\DoxyCodeLine{13 \textcolor{comment}{// distribution.}}
\DoxyCodeLine{14 \textcolor{comment}{//     * Neither the name of Google Inc. nor the names of its}}
\DoxyCodeLine{15 \textcolor{comment}{// contributors may be used to endorse or promote products derived from}}
\DoxyCodeLine{16 \textcolor{comment}{// this software without specific prior written permission.}}
\DoxyCodeLine{17 \textcolor{comment}{//}}
\DoxyCodeLine{18 \textcolor{comment}{// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS}}
\DoxyCodeLine{19 \textcolor{comment}{// "{}AS IS"{} AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT}}
\DoxyCodeLine{20 \textcolor{comment}{// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR}}
\DoxyCodeLine{21 \textcolor{comment}{// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT}}
\DoxyCodeLine{22 \textcolor{comment}{// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,}}
\DoxyCodeLine{23 \textcolor{comment}{// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT}}
\DoxyCodeLine{24 \textcolor{comment}{// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,}}
\DoxyCodeLine{25 \textcolor{comment}{// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY}}
\DoxyCodeLine{26 \textcolor{comment}{// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT}}
\DoxyCodeLine{27 \textcolor{comment}{// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE}}
\DoxyCodeLine{28 \textcolor{comment}{// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.}}
\DoxyCodeLine{29 }
\DoxyCodeLine{30 \textcolor{comment}{// Google Mock -\/ a framework for writing C++ mock classes.}}
\DoxyCodeLine{31 \textcolor{comment}{//}}
\DoxyCodeLine{32 \textcolor{comment}{// The MATCHER* family of macros can be used in a namespace scope to}}
\DoxyCodeLine{33 \textcolor{comment}{// define custom matchers easily.}}
\DoxyCodeLine{34 \textcolor{comment}{//}}
\DoxyCodeLine{35 \textcolor{comment}{// Basic Usage}}
\DoxyCodeLine{36 \textcolor{comment}{// ===========}}
\DoxyCodeLine{37 \textcolor{comment}{//}}
\DoxyCodeLine{38 \textcolor{comment}{// The syntax}}
\DoxyCodeLine{39 \textcolor{comment}{//}}
\DoxyCodeLine{40 \textcolor{comment}{//   MATCHER(name, description\_string) \{ statements; \}}}
\DoxyCodeLine{41 \textcolor{comment}{//}}
\DoxyCodeLine{42 \textcolor{comment}{// defines a matcher with the given name that executes the statements,}}
\DoxyCodeLine{43 \textcolor{comment}{// which must return a bool to indicate if the match succeeds.  Inside}}
\DoxyCodeLine{44 \textcolor{comment}{// the statements, you can refer to the value being matched by 'arg',}}
\DoxyCodeLine{45 \textcolor{comment}{// and refer to its type by 'arg\_type'.}}
\DoxyCodeLine{46 \textcolor{comment}{//}}
\DoxyCodeLine{47 \textcolor{comment}{// The description string documents what the matcher does, and is used}}
\DoxyCodeLine{48 \textcolor{comment}{// to generate the failure message when the match fails.  Since a}}
\DoxyCodeLine{49 \textcolor{comment}{// MATCHER() is usually defined in a header file shared by multiple}}
\DoxyCodeLine{50 \textcolor{comment}{// C++ source files, we require the description to be a C-\/string}}
\DoxyCodeLine{51 \textcolor{comment}{// literal to avoid possible side effects.  It can be empty, in which}}
\DoxyCodeLine{52 \textcolor{comment}{// case we'll use the sequence of words in the matcher name as the}}
\DoxyCodeLine{53 \textcolor{comment}{// description.}}
\DoxyCodeLine{54 \textcolor{comment}{//}}
\DoxyCodeLine{55 \textcolor{comment}{// For example:}}
\DoxyCodeLine{56 \textcolor{comment}{//}}
\DoxyCodeLine{57 \textcolor{comment}{//   MATCHER(IsEven, "{}"{}) \{ return (arg \% 2) == 0; \}}}
\DoxyCodeLine{58 \textcolor{comment}{//}}
\DoxyCodeLine{59 \textcolor{comment}{// allows you to write}}
\DoxyCodeLine{60 \textcolor{comment}{//}}
\DoxyCodeLine{61 \textcolor{comment}{//   // Expects mock\_foo.Bar(n) to be called where n is even.}}
\DoxyCodeLine{62 \textcolor{comment}{//   EXPECT\_CALL(mock\_foo, Bar(IsEven()));}}
\DoxyCodeLine{63 \textcolor{comment}{//}}
\DoxyCodeLine{64 \textcolor{comment}{// or,}}
\DoxyCodeLine{65 \textcolor{comment}{//}}
\DoxyCodeLine{66 \textcolor{comment}{//   // Verifies that the value of some\_expression is even.}}
\DoxyCodeLine{67 \textcolor{comment}{//   EXPECT\_THAT(some\_expression, IsEven());}}
\DoxyCodeLine{68 \textcolor{comment}{//}}
\DoxyCodeLine{69 \textcolor{comment}{// If the above assertion fails, it will print something like:}}
\DoxyCodeLine{70 \textcolor{comment}{//}}
\DoxyCodeLine{71 \textcolor{comment}{//   Value of: some\_expression}}
\DoxyCodeLine{72 \textcolor{comment}{//   Expected: is even}}
\DoxyCodeLine{73 \textcolor{comment}{//     Actual: 7}}
\DoxyCodeLine{74 \textcolor{comment}{//}}
\DoxyCodeLine{75 \textcolor{comment}{// where the description "{}is even"{} is automatically calculated from the}}
\DoxyCodeLine{76 \textcolor{comment}{// matcher name IsEven.}}
\DoxyCodeLine{77 \textcolor{comment}{//}}
\DoxyCodeLine{78 \textcolor{comment}{// Argument Type}}
\DoxyCodeLine{79 \textcolor{comment}{// =============}}
\DoxyCodeLine{80 \textcolor{comment}{//}}
\DoxyCodeLine{81 \textcolor{comment}{// Note that the type of the value being matched (arg\_type) is}}
\DoxyCodeLine{82 \textcolor{comment}{// determined by the context in which you use the matcher and is}}
\DoxyCodeLine{83 \textcolor{comment}{// supplied to you by the compiler, so you don't need to worry about}}
\DoxyCodeLine{84 \textcolor{comment}{// declaring it (nor can you).  This allows the matcher to be}}
\DoxyCodeLine{85 \textcolor{comment}{// polymorphic.  For example, IsEven() can be used to match any type}}
\DoxyCodeLine{86 \textcolor{comment}{// where the value of "{}(arg \% 2) == 0"{} can be implicitly converted to}}
\DoxyCodeLine{87 \textcolor{comment}{// a bool.  In the "{}Bar(IsEven())"{} example above, if method Bar()}}
\DoxyCodeLine{88 \textcolor{comment}{// takes an int, 'arg\_type' will be int; if it takes an unsigned long,}}
\DoxyCodeLine{89 \textcolor{comment}{// 'arg\_type' will be unsigned long; and so on.}}
\DoxyCodeLine{90 \textcolor{comment}{//}}
\DoxyCodeLine{91 \textcolor{comment}{// Parameterizing Matchers}}
\DoxyCodeLine{92 \textcolor{comment}{// =======================}}
\DoxyCodeLine{93 \textcolor{comment}{//}}
\DoxyCodeLine{94 \textcolor{comment}{// Sometimes you'll want to parameterize the matcher.  For that you}}
\DoxyCodeLine{95 \textcolor{comment}{// can use another macro:}}
\DoxyCodeLine{96 \textcolor{comment}{//}}
\DoxyCodeLine{97 \textcolor{comment}{//   MATCHER\_P(name, param\_name, description\_string) \{ statements; \}}}
\DoxyCodeLine{98 \textcolor{comment}{//}}
\DoxyCodeLine{99 \textcolor{comment}{// For example:}}
\DoxyCodeLine{100 \textcolor{comment}{//}}
\DoxyCodeLine{101 \textcolor{comment}{//   MATCHER\_P(HasAbsoluteValue, value, "{}"{}) \{ return abs(arg) == value; \}}}
\DoxyCodeLine{102 \textcolor{comment}{//}}
\DoxyCodeLine{103 \textcolor{comment}{// will allow you to write:}}
\DoxyCodeLine{104 \textcolor{comment}{//}}
\DoxyCodeLine{105 \textcolor{comment}{//   EXPECT\_THAT(Blah("{}a"{}), HasAbsoluteValue(n));}}
\DoxyCodeLine{106 \textcolor{comment}{//}}
\DoxyCodeLine{107 \textcolor{comment}{// which may lead to this message (assuming n is 10):}}
\DoxyCodeLine{108 \textcolor{comment}{//}}
\DoxyCodeLine{109 \textcolor{comment}{//   Value of: Blah("{}a"{})}}
\DoxyCodeLine{110 \textcolor{comment}{//   Expected: has absolute value 10}}
\DoxyCodeLine{111 \textcolor{comment}{//     Actual: -\/9}}
\DoxyCodeLine{112 \textcolor{comment}{//}}
\DoxyCodeLine{113 \textcolor{comment}{// Note that both the matcher description and its parameter are}}
\DoxyCodeLine{114 \textcolor{comment}{// printed, making the message human-\/friendly.}}
\DoxyCodeLine{115 \textcolor{comment}{//}}
\DoxyCodeLine{116 \textcolor{comment}{// In the matcher definition body, you can write 'foo\_type' to}}
\DoxyCodeLine{117 \textcolor{comment}{// reference the type of a parameter named 'foo'.  For example, in the}}
\DoxyCodeLine{118 \textcolor{comment}{// body of MATCHER\_P(HasAbsoluteValue, value) above, you can write}}
\DoxyCodeLine{119 \textcolor{comment}{// 'value\_type' to refer to the type of 'value'.}}
\DoxyCodeLine{120 \textcolor{comment}{//}}
\DoxyCodeLine{121 \textcolor{comment}{// We also provide MATCHER\_P2, MATCHER\_P3, ..., up to MATCHER\_P\$n to}}
\DoxyCodeLine{122 \textcolor{comment}{// support multi-\/parameter matchers.}}
\DoxyCodeLine{123 \textcolor{comment}{//}}
\DoxyCodeLine{124 \textcolor{comment}{// Describing Parameterized Matchers}}
\DoxyCodeLine{125 \textcolor{comment}{// =================================}}
\DoxyCodeLine{126 \textcolor{comment}{//}}
\DoxyCodeLine{127 \textcolor{comment}{// The last argument to MATCHER*() is a string-\/typed expression.  The}}
\DoxyCodeLine{128 \textcolor{comment}{// expression can reference all of the matcher's parameters and a}}
\DoxyCodeLine{129 \textcolor{comment}{// special bool-\/typed variable named 'negation'.  When 'negation' is}}
\DoxyCodeLine{130 \textcolor{comment}{// false, the expression should evaluate to the matcher's description;}}
\DoxyCodeLine{131 \textcolor{comment}{// otherwise it should evaluate to the description of the negation of}}
\DoxyCodeLine{132 \textcolor{comment}{// the matcher.  For example,}}
\DoxyCodeLine{133 \textcolor{comment}{//}}
\DoxyCodeLine{134 \textcolor{comment}{//   using testing::PrintToString;}}
\DoxyCodeLine{135 \textcolor{comment}{//}}
\DoxyCodeLine{136 \textcolor{comment}{//   MATCHER\_P2(InClosedRange, low, hi,}}
\DoxyCodeLine{137 \textcolor{comment}{//       std::string(negation ? "{}is not"{} : "{}is"{}) + "{} in range ["{} +}}
\DoxyCodeLine{138 \textcolor{comment}{//       PrintToString(low) + "{}, "{} + PrintToString(hi) + "{}]"{}) \{}}
\DoxyCodeLine{139 \textcolor{comment}{//     return low <= arg \&\& arg <= hi;}}
\DoxyCodeLine{140 \textcolor{comment}{//   \}}}
\DoxyCodeLine{141 \textcolor{comment}{//   ...}}
\DoxyCodeLine{142 \textcolor{comment}{//   EXPECT\_THAT(3, InClosedRange(4, 6));}}
\DoxyCodeLine{143 \textcolor{comment}{//   EXPECT\_THAT(3, Not(InClosedRange(2, 4)));}}
\DoxyCodeLine{144 \textcolor{comment}{//}}
\DoxyCodeLine{145 \textcolor{comment}{// would generate two failures that contain the text:}}
\DoxyCodeLine{146 \textcolor{comment}{//}}
\DoxyCodeLine{147 \textcolor{comment}{//   Expected: is in range [4, 6]}}
\DoxyCodeLine{148 \textcolor{comment}{//   ...}}
\DoxyCodeLine{149 \textcolor{comment}{//   Expected: is not in range [2, 4]}}
\DoxyCodeLine{150 \textcolor{comment}{//}}
\DoxyCodeLine{151 \textcolor{comment}{// If you specify "{}"{} as the description, the failure message will}}
\DoxyCodeLine{152 \textcolor{comment}{// contain the sequence of words in the matcher name followed by the}}
\DoxyCodeLine{153 \textcolor{comment}{// parameter values printed as a tuple.  For example,}}
\DoxyCodeLine{154 \textcolor{comment}{//}}
\DoxyCodeLine{155 \textcolor{comment}{//   MATCHER\_P2(InClosedRange, low, hi, "{}"{}) \{ ... \}}}
\DoxyCodeLine{156 \textcolor{comment}{//   ...}}
\DoxyCodeLine{157 \textcolor{comment}{//   EXPECT\_THAT(3, InClosedRange(4, 6));}}
\DoxyCodeLine{158 \textcolor{comment}{//   EXPECT\_THAT(3, Not(InClosedRange(2, 4)));}}
\DoxyCodeLine{159 \textcolor{comment}{//}}
\DoxyCodeLine{160 \textcolor{comment}{// would generate two failures that contain the text:}}
\DoxyCodeLine{161 \textcolor{comment}{//}}
\DoxyCodeLine{162 \textcolor{comment}{//   Expected: in closed range (4, 6)}}
\DoxyCodeLine{163 \textcolor{comment}{//   ...}}
\DoxyCodeLine{164 \textcolor{comment}{//   Expected: not (in closed range (2, 4))}}
\DoxyCodeLine{165 \textcolor{comment}{//}}
\DoxyCodeLine{166 \textcolor{comment}{// Types of Matcher Parameters}}
\DoxyCodeLine{167 \textcolor{comment}{// ===========================}}
\DoxyCodeLine{168 \textcolor{comment}{//}}
\DoxyCodeLine{169 \textcolor{comment}{// For the purpose of typing, you can view}}
\DoxyCodeLine{170 \textcolor{comment}{//}}
\DoxyCodeLine{171 \textcolor{comment}{//   MATCHER\_Pk(Foo, p1, ..., pk, description\_string) \{ ... \}}}
\DoxyCodeLine{172 \textcolor{comment}{//}}
\DoxyCodeLine{173 \textcolor{comment}{// as shorthand for}}
\DoxyCodeLine{174 \textcolor{comment}{//}}
\DoxyCodeLine{175 \textcolor{comment}{//   template <typename p1\_type, ..., typename pk\_type>}}
\DoxyCodeLine{176 \textcolor{comment}{//   FooMatcherPk<p1\_type, ..., pk\_type>}}
\DoxyCodeLine{177 \textcolor{comment}{//   Foo(p1\_type p1, ..., pk\_type pk) \{ ... \}}}
\DoxyCodeLine{178 \textcolor{comment}{//}}
\DoxyCodeLine{179 \textcolor{comment}{// When you write Foo(v1, ..., vk), the compiler infers the types of}}
\DoxyCodeLine{180 \textcolor{comment}{// the parameters v1, ..., and vk for you.  If you are not happy with}}
\DoxyCodeLine{181 \textcolor{comment}{// the result of the type inference, you can specify the types by}}
\DoxyCodeLine{182 \textcolor{comment}{// explicitly instantiating the template, as in Foo<long, bool>(5,}}
\DoxyCodeLine{183 \textcolor{comment}{// false).  As said earlier, you don't get to (or need to) specify}}
\DoxyCodeLine{184 \textcolor{comment}{// 'arg\_type' as that's determined by the context in which the matcher}}
\DoxyCodeLine{185 \textcolor{comment}{// is used.  You can assign the result of expression Foo(p1, ..., pk)}}
\DoxyCodeLine{186 \textcolor{comment}{// to a variable of type FooMatcherPk<p1\_type, ..., pk\_type>.  This}}
\DoxyCodeLine{187 \textcolor{comment}{// can be useful when composing matchers.}}
\DoxyCodeLine{188 \textcolor{comment}{//}}
\DoxyCodeLine{189 \textcolor{comment}{// While you can instantiate a matcher template with reference types,}}
\DoxyCodeLine{190 \textcolor{comment}{// passing the parameters by pointer usually makes your code more}}
\DoxyCodeLine{191 \textcolor{comment}{// readable.  If, however, you still want to pass a parameter by}}
\DoxyCodeLine{192 \textcolor{comment}{// reference, be aware that in the failure message generated by the}}
\DoxyCodeLine{193 \textcolor{comment}{// matcher you will see the value of the referenced object but not its}}
\DoxyCodeLine{194 \textcolor{comment}{// address.}}
\DoxyCodeLine{195 \textcolor{comment}{//}}
\DoxyCodeLine{196 \textcolor{comment}{// Explaining Match Results}}
\DoxyCodeLine{197 \textcolor{comment}{// ========================}}
\DoxyCodeLine{198 \textcolor{comment}{//}}
\DoxyCodeLine{199 \textcolor{comment}{// Sometimes the matcher description alone isn't enough to explain why}}
\DoxyCodeLine{200 \textcolor{comment}{// the match has failed or succeeded.  For example, when expecting a}}
\DoxyCodeLine{201 \textcolor{comment}{// long string, it can be very helpful to also print the diff between}}
\DoxyCodeLine{202 \textcolor{comment}{// the expected string and the actual one.  To achieve that, you can}}
\DoxyCodeLine{203 \textcolor{comment}{// optionally stream additional information to a special variable}}
\DoxyCodeLine{204 \textcolor{comment}{// named result\_listener, whose type is a pointer to class}}
\DoxyCodeLine{205 \textcolor{comment}{// MatchResultListener:}}
\DoxyCodeLine{206 \textcolor{comment}{//}}
\DoxyCodeLine{207 \textcolor{comment}{//   MATCHER\_P(EqualsLongString, str, "{}"{}) \{}}
\DoxyCodeLine{208 \textcolor{comment}{//     if (arg == str) return true;}}
\DoxyCodeLine{209 \textcolor{comment}{//}}
\DoxyCodeLine{210 \textcolor{comment}{//     *result\_listener << "{}the difference: "{}}}
\DoxyCodeLine{212 \textcolor{comment}{}\textcolor{comment}{//     return false;}}
\DoxyCodeLine{213 \textcolor{comment}{//   \}}}
\DoxyCodeLine{214 \textcolor{comment}{//}}
\DoxyCodeLine{215 \textcolor{comment}{// Overloading Matchers}}
\DoxyCodeLine{216 \textcolor{comment}{// ====================}}
\DoxyCodeLine{217 \textcolor{comment}{//}}
\DoxyCodeLine{218 \textcolor{comment}{// You can overload matchers with different numbers of parameters:}}
\DoxyCodeLine{219 \textcolor{comment}{//}}
\DoxyCodeLine{220 \textcolor{comment}{//   MATCHER\_P(Blah, a, description\_string1) \{ ... \}}}
\DoxyCodeLine{221 \textcolor{comment}{//   MATCHER\_P2(Blah, a, b, description\_string2) \{ ... \}}}
\DoxyCodeLine{222 \textcolor{comment}{//}}
\DoxyCodeLine{223 \textcolor{comment}{// Caveats}}
\DoxyCodeLine{224 \textcolor{comment}{// =======}}
\DoxyCodeLine{225 \textcolor{comment}{//}}
\DoxyCodeLine{226 \textcolor{comment}{// When defining a new matcher, you should also consider implementing}}
\DoxyCodeLine{227 \textcolor{comment}{// MatcherInterface or using MakePolymorphicMatcher().  These}}
\DoxyCodeLine{228 \textcolor{comment}{// approaches require more work than the MATCHER* macros, but also}}
\DoxyCodeLine{229 \textcolor{comment}{// give you more control on the types of the value being matched and}}
\DoxyCodeLine{230 \textcolor{comment}{// the matcher parameters, which may leads to better compiler error}}
\DoxyCodeLine{231 \textcolor{comment}{// messages when the matcher is used wrong.  They also allow}}
\DoxyCodeLine{232 \textcolor{comment}{// overloading matchers based on parameter types (as opposed to just}}
\DoxyCodeLine{233 \textcolor{comment}{// based on the number of parameters).}}
\DoxyCodeLine{234 \textcolor{comment}{//}}
\DoxyCodeLine{235 \textcolor{comment}{// MATCHER*() can only be used in a namespace scope as templates cannot be}}
\DoxyCodeLine{236 \textcolor{comment}{// declared inside of a local class.}}
\DoxyCodeLine{237 \textcolor{comment}{//}}
\DoxyCodeLine{238 \textcolor{comment}{// More Information}}
\DoxyCodeLine{239 \textcolor{comment}{// ================}}
\DoxyCodeLine{240 \textcolor{comment}{//}}
\DoxyCodeLine{241 \textcolor{comment}{// To learn more about using these macros, please search for 'MATCHER'}}
\DoxyCodeLine{242 \textcolor{comment}{// on}}
\DoxyCodeLine{243 \textcolor{comment}{// https://github.com/google/googletest/blob/master/docs/gmock\_cook\_book.md}}
\DoxyCodeLine{244 \textcolor{comment}{//}}
\DoxyCodeLine{245 \textcolor{comment}{// This file also implements some commonly used argument matchers.  More}}
\DoxyCodeLine{246 \textcolor{comment}{// matchers can be defined by the user implementing the}}
\DoxyCodeLine{247 \textcolor{comment}{// MatcherInterface<T> interface if necessary.}}
\DoxyCodeLine{248 \textcolor{comment}{//}}
\DoxyCodeLine{249 \textcolor{comment}{// See googletest/include/gtest/gtest-\/matchers.h for the definition of class}}
\DoxyCodeLine{250 \textcolor{comment}{// Matcher, class MatcherInterface, and others.}}
\DoxyCodeLine{251 }
\DoxyCodeLine{252 \textcolor{comment}{// IWYU pragma: private, include "{}gmock/gmock.h"{}}}
\DoxyCodeLine{253 \textcolor{comment}{// IWYU pragma: friend gmock/.*}}
\DoxyCodeLine{254 }
\DoxyCodeLine{255 \textcolor{preprocessor}{\#ifndef GOOGLEMOCK\_INCLUDE\_GMOCK\_GMOCK\_MATCHERS\_H\_}}
\DoxyCodeLine{256 \textcolor{preprocessor}{\#define GOOGLEMOCK\_INCLUDE\_GMOCK\_GMOCK\_MATCHERS\_H\_}}
\DoxyCodeLine{257 }
\DoxyCodeLine{258 \textcolor{preprocessor}{\#include <algorithm>}}
\DoxyCodeLine{259 \textcolor{preprocessor}{\#include <cmath>}}
\DoxyCodeLine{260 \textcolor{preprocessor}{\#include <initializer\_list>}}
\DoxyCodeLine{261 \textcolor{preprocessor}{\#include <iterator>}}
\DoxyCodeLine{262 \textcolor{preprocessor}{\#include <limits>}}
\DoxyCodeLine{263 \textcolor{preprocessor}{\#include <memory>}}
\DoxyCodeLine{264 \textcolor{preprocessor}{\#include <ostream>}  \textcolor{comment}{// NOLINT}}
\DoxyCodeLine{265 \textcolor{preprocessor}{\#include <sstream>}}
\DoxyCodeLine{266 \textcolor{preprocessor}{\#include <string>}}
\DoxyCodeLine{267 \textcolor{preprocessor}{\#include <type\_traits>}}
\DoxyCodeLine{268 \textcolor{preprocessor}{\#include <utility>}}
\DoxyCodeLine{269 \textcolor{preprocessor}{\#include <vector>}}
\DoxyCodeLine{270 }
\DoxyCodeLine{271 \textcolor{preprocessor}{\#include "{}gmock/internal/gmock-\/internal-\/utils.h"{}}}
\DoxyCodeLine{272 \textcolor{preprocessor}{\#include "{}gmock/internal/gmock-\/port.h"{}}}
\DoxyCodeLine{273 \textcolor{preprocessor}{\#include "{}gmock/internal/gmock-\/pp.h"{}}}
\DoxyCodeLine{274 \textcolor{preprocessor}{\#include "{}gtest/gtest.h"{}}}
\DoxyCodeLine{275 }
\DoxyCodeLine{276 \textcolor{comment}{// MSVC warning C5046 is new as of VS2017 version 15.8.}}
\DoxyCodeLine{277 \textcolor{preprocessor}{\#if defined(\_MSC\_VER) \&\& \_MSC\_VER >= 1915}}
\DoxyCodeLine{278 \textcolor{preprocessor}{\#define GMOCK\_MAYBE\_5046\_ 5046}}
\DoxyCodeLine{279 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{280 \textcolor{preprocessor}{\#define GMOCK\_MAYBE\_5046\_}}
\DoxyCodeLine{281 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{282 }
\DoxyCodeLine{283 GTEST\_DISABLE\_MSC\_WARNINGS\_PUSH\_(}
\DoxyCodeLine{284     4251 GMOCK\_MAYBE\_5046\_ \textcolor{comment}{/* class A needs to have dll-\/interface to be used by}}
\DoxyCodeLine{285 \textcolor{comment}{                              clients of class B */}}
\DoxyCodeLine{286     \textcolor{comment}{/* Symbol involving type with internal linkage not defined */})}
\DoxyCodeLine{287 }
\DoxyCodeLine{288 \textcolor{keyword}{namespace }testing \{}
\DoxyCodeLine{289 }
\DoxyCodeLine{290 \textcolor{comment}{// To implement a matcher Foo for type T, define:}}
\DoxyCodeLine{291 \textcolor{comment}{//   1. a class FooMatcherImpl that implements the}}
\DoxyCodeLine{292 \textcolor{comment}{//      MatcherInterface<T> interface, and}}
\DoxyCodeLine{293 \textcolor{comment}{//   2. a factory function that creates a Matcher<T> object from a}}
\DoxyCodeLine{294 \textcolor{comment}{//      FooMatcherImpl*.}}
\DoxyCodeLine{295 \textcolor{comment}{//}}
\DoxyCodeLine{296 \textcolor{comment}{// The two-\/level delegation design makes it possible to allow a user}}
\DoxyCodeLine{297 \textcolor{comment}{// to write "{}v"{} instead of "{}Eq(v)"{} where a Matcher is expected, which}}
\DoxyCodeLine{298 \textcolor{comment}{// is impossible if we pass matchers by pointers.  It also eases}}
\DoxyCodeLine{299 \textcolor{comment}{// ownership management as Matcher objects can now be copied like}}
\DoxyCodeLine{300 \textcolor{comment}{// plain values.}}
\DoxyCodeLine{301 }
\DoxyCodeLine{302 \textcolor{comment}{// A match result listener that stores the explanation in a string.}}
\DoxyCodeLine{303 \textcolor{keyword}{class }StringMatchResultListener : \textcolor{keyword}{public} MatchResultListener \{}
\DoxyCodeLine{304  \textcolor{keyword}{public}:}
\DoxyCodeLine{305   StringMatchResultListener() : MatchResultListener(\&ss\_) \{\}}
\DoxyCodeLine{306 }
\DoxyCodeLine{307   \textcolor{comment}{// Returns the explanation accumulated so far.}}
\DoxyCodeLine{308   std::string str()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} ss\_.str(); \}}
\DoxyCodeLine{309 }
\DoxyCodeLine{310   \textcolor{comment}{// Clears the explanation accumulated so far.}}
\DoxyCodeLine{311   \textcolor{keywordtype}{void} Clear() \{ ss\_.str(\textcolor{stringliteral}{"{}"{}}); \}}
\DoxyCodeLine{312 }
\DoxyCodeLine{313  \textcolor{keyword}{private}:}
\DoxyCodeLine{314   ::std::stringstream ss\_;}
\DoxyCodeLine{315 }
\DoxyCodeLine{316   StringMatchResultListener(\textcolor{keyword}{const} StringMatchResultListener\&) = \textcolor{keyword}{delete};}
\DoxyCodeLine{317   StringMatchResultListener\& operator=(\textcolor{keyword}{const} StringMatchResultListener\&) =}
\DoxyCodeLine{318       \textcolor{keyword}{delete};}
\DoxyCodeLine{319 \};}
\DoxyCodeLine{320 }
\DoxyCodeLine{321 \textcolor{comment}{// Anything inside the 'internal' namespace IS INTERNAL IMPLEMENTATION}}
\DoxyCodeLine{322 \textcolor{comment}{// and MUST NOT BE USED IN USER CODE!!!}}
\DoxyCodeLine{323 \textcolor{keyword}{namespace }internal \{}
\DoxyCodeLine{324 }
\DoxyCodeLine{325 \textcolor{comment}{// The MatcherCastImpl class template is a helper for implementing}}
\DoxyCodeLine{326 \textcolor{comment}{// MatcherCast().  We need this helper in order to partially}}
\DoxyCodeLine{327 \textcolor{comment}{// specialize the implementation of MatcherCast() (C++ allows}}
\DoxyCodeLine{328 \textcolor{comment}{// class/struct templates to be partially specialized, but not}}
\DoxyCodeLine{329 \textcolor{comment}{// function templates.).}}
\DoxyCodeLine{330 }
\DoxyCodeLine{331 \textcolor{comment}{// This general version is used when MatcherCast()'s argument is a}}
\DoxyCodeLine{332 \textcolor{comment}{// polymorphic matcher (i.e. something that can be converted to a}}
\DoxyCodeLine{333 \textcolor{comment}{// Matcher but is not one yet; for example, Eq(value)) or a value (for}}
\DoxyCodeLine{334 \textcolor{comment}{// example, "{}hello"{}).}}
\DoxyCodeLine{335 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T, \textcolor{keyword}{typename} M>}
\DoxyCodeLine{336 \textcolor{keyword}{class }MatcherCastImpl \{}
\DoxyCodeLine{337  \textcolor{keyword}{public}:}
\DoxyCodeLine{338   \textcolor{keyword}{static} Matcher<T> Cast(\textcolor{keyword}{const} M\& polymorphic\_matcher\_or\_value) \{}
\DoxyCodeLine{339     \textcolor{comment}{// M can be a polymorphic matcher, in which case we want to use}}
\DoxyCodeLine{340     \textcolor{comment}{// its conversion operator to create Matcher<T>.  Or it can be a value}}
\DoxyCodeLine{341     \textcolor{comment}{// that should be passed to the Matcher<T>'s constructor.}}
\DoxyCodeLine{342     \textcolor{comment}{//}}
\DoxyCodeLine{343     \textcolor{comment}{// We can't call Matcher<T>(polymorphic\_matcher\_or\_value) when M is a}}
\DoxyCodeLine{344     \textcolor{comment}{// polymorphic matcher because it'll be ambiguous if T has an implicit}}
\DoxyCodeLine{345     \textcolor{comment}{// constructor from M (this usually happens when T has an implicit}}
\DoxyCodeLine{346     \textcolor{comment}{// constructor from any type).}}
\DoxyCodeLine{347     \textcolor{comment}{//}}
\DoxyCodeLine{348     \textcolor{comment}{// It won't work to unconditionally implicit\_cast}}
\DoxyCodeLine{349     \textcolor{comment}{// polymorphic\_matcher\_or\_value to Matcher<T> because it won't trigger}}
\DoxyCodeLine{350     \textcolor{comment}{// a user-\/defined conversion from M to T if one exists (assuming M is}}
\DoxyCodeLine{351     \textcolor{comment}{// a value).}}
\DoxyCodeLine{352     \textcolor{keywordflow}{return} CastImpl(polymorphic\_matcher\_or\_value,}
\DoxyCodeLine{353                     std::is\_convertible<M, Matcher<T>>\{\},}
\DoxyCodeLine{354                     std::is\_convertible<M, T>\{\});}
\DoxyCodeLine{355   \}}
\DoxyCodeLine{356 }
\DoxyCodeLine{357  \textcolor{keyword}{private}:}
\DoxyCodeLine{358   \textcolor{keyword}{template} <\textcolor{keywordtype}{bool} Ignore>}
\DoxyCodeLine{359   \textcolor{keyword}{static} Matcher<T> CastImpl(\textcolor{keyword}{const} M\& polymorphic\_matcher\_or\_value,}
\DoxyCodeLine{360                              std::true\_type \textcolor{comment}{/* convertible\_to\_matcher */},}
\DoxyCodeLine{361                              std::integral\_constant<bool, Ignore>) \{}
\DoxyCodeLine{362     \textcolor{comment}{// M is implicitly convertible to Matcher<T>, which means that either}}
\DoxyCodeLine{363     \textcolor{comment}{// M is a polymorphic matcher or Matcher<T> has an implicit constructor}}
\DoxyCodeLine{364     \textcolor{comment}{// from M.  In both cases using the implicit conversion will produce a}}
\DoxyCodeLine{365     \textcolor{comment}{// matcher.}}
\DoxyCodeLine{366     \textcolor{comment}{//}}
\DoxyCodeLine{367     \textcolor{comment}{// Even if T has an implicit constructor from M, it won't be called because}}
\DoxyCodeLine{368     \textcolor{comment}{// creating Matcher<T> would require a chain of two user-\/defined conversions}}
\DoxyCodeLine{369     \textcolor{comment}{// (first to create T from M and then to create Matcher<T> from T).}}
\DoxyCodeLine{370     \textcolor{keywordflow}{return} polymorphic\_matcher\_or\_value;}
\DoxyCodeLine{371   \}}
\DoxyCodeLine{372 }
\DoxyCodeLine{373   \textcolor{comment}{// M can't be implicitly converted to Matcher<T>, so M isn't a polymorphic}}
\DoxyCodeLine{374   \textcolor{comment}{// matcher. It's a value of a type implicitly convertible to T. Use direct}}
\DoxyCodeLine{375   \textcolor{comment}{// initialization to create a matcher.}}
\DoxyCodeLine{376   \textcolor{keyword}{static} Matcher<T> CastImpl(\textcolor{keyword}{const} M\& value,}
\DoxyCodeLine{377                              std::false\_type \textcolor{comment}{/* convertible\_to\_matcher */},}
\DoxyCodeLine{378                              std::true\_type \textcolor{comment}{/* convertible\_to\_T */}) \{}
\DoxyCodeLine{379     \textcolor{keywordflow}{return} Matcher<T>(ImplicitCast\_<T>(value));}
\DoxyCodeLine{380   \}}
\DoxyCodeLine{381 }
\DoxyCodeLine{382   \textcolor{comment}{// M can't be implicitly converted to either Matcher<T> or T. Attempt to use}}
\DoxyCodeLine{383   \textcolor{comment}{// polymorphic matcher Eq(value) in this case.}}
\DoxyCodeLine{384   \textcolor{comment}{//}}
\DoxyCodeLine{385   \textcolor{comment}{// Note that we first attempt to perform an implicit cast on the value and}}
\DoxyCodeLine{386   \textcolor{comment}{// only fall back to the polymorphic Eq() matcher afterwards because the}}
\DoxyCodeLine{387   \textcolor{comment}{// latter calls bool operator==(const Lhs\& lhs, const Rhs\& rhs) in the end}}
\DoxyCodeLine{388   \textcolor{comment}{// which might be undefined even when Rhs is implicitly convertible to Lhs}}
\DoxyCodeLine{389   \textcolor{comment}{// (e.g. std::pair<const int, int> vs. std::pair<int, int>).}}
\DoxyCodeLine{390   \textcolor{comment}{//}}
\DoxyCodeLine{391   \textcolor{comment}{// We don't define this method inline as we need the declaration of Eq().}}
\DoxyCodeLine{392   \textcolor{keyword}{static} Matcher<T> CastImpl(\textcolor{keyword}{const} M\& value,}
\DoxyCodeLine{393                              std::false\_type \textcolor{comment}{/* convertible\_to\_matcher */},}
\DoxyCodeLine{394                              std::false\_type \textcolor{comment}{/* convertible\_to\_T */});}
\DoxyCodeLine{395 \};}
\DoxyCodeLine{396 }
\DoxyCodeLine{397 \textcolor{comment}{// This more specialized version is used when MatcherCast()'s argument}}
\DoxyCodeLine{398 \textcolor{comment}{// is already a Matcher.  This only compiles when type T can be}}
\DoxyCodeLine{399 \textcolor{comment}{// statically converted to type U.}}
\DoxyCodeLine{400 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T, \textcolor{keyword}{typename} U>}
\DoxyCodeLine{401 \textcolor{keyword}{class }MatcherCastImpl<T, Matcher<U>> \{}
\DoxyCodeLine{402  \textcolor{keyword}{public}:}
\DoxyCodeLine{403   \textcolor{keyword}{static} Matcher<T> Cast(\textcolor{keyword}{const} Matcher<U>\& source\_matcher) \{}
\DoxyCodeLine{404     \textcolor{keywordflow}{return} Matcher<T>(\textcolor{keyword}{new} Impl(source\_matcher));}
\DoxyCodeLine{405   \}}
\DoxyCodeLine{406 }
\DoxyCodeLine{407  \textcolor{keyword}{private}:}
\DoxyCodeLine{408   \textcolor{keyword}{class }Impl : \textcolor{keyword}{public} MatcherInterface<T> \{}
\DoxyCodeLine{409    \textcolor{keyword}{public}:}
\DoxyCodeLine{410     \textcolor{keyword}{explicit} Impl(\textcolor{keyword}{const} Matcher<U>\& source\_matcher)}
\DoxyCodeLine{411         : source\_matcher\_(source\_matcher) \{\}}
\DoxyCodeLine{412 }
\DoxyCodeLine{413     \textcolor{comment}{// We delegate the matching logic to the source matcher.}}
\DoxyCodeLine{414     \textcolor{keywordtype}{bool} MatchAndExplain(T x, MatchResultListener* listener)\textcolor{keyword}{ const override }\{}
\DoxyCodeLine{415       \textcolor{keyword}{using }FromType = \textcolor{keyword}{typename} std::remove\_cv<\textcolor{keyword}{typename} std::remove\_pointer<}
\DoxyCodeLine{416           \textcolor{keyword}{typename} std::remove\_reference<T>::type>::type>::type;}
\DoxyCodeLine{417       \textcolor{keyword}{using }ToType = \textcolor{keyword}{typename} std::remove\_cv<\textcolor{keyword}{typename} std::remove\_pointer<}
\DoxyCodeLine{418           \textcolor{keyword}{typename} std::remove\_reference<U>::type>::type>::type;}
\DoxyCodeLine{419       \textcolor{comment}{// Do not allow implicitly converting base*/\& to derived*/\&.}}
\DoxyCodeLine{420       \textcolor{keyword}{static\_assert}(}
\DoxyCodeLine{421           \textcolor{comment}{// Do not trigger if only one of them is a pointer. That implies a}}
\DoxyCodeLine{422           \textcolor{comment}{// regular conversion and not a down\_cast.}}
\DoxyCodeLine{423           (std::is\_pointer<typename std::remove\_reference<T>::type>::value !=}
\DoxyCodeLine{424            std::is\_pointer<typename std::remove\_reference<U>::type>::value) ||}
\DoxyCodeLine{425               std::is\_same<FromType, ToType>::value ||}
\DoxyCodeLine{426               !std::is\_base\_of<FromType, ToType>::value,}
\DoxyCodeLine{427           \textcolor{stringliteral}{"{}Can't implicitly convert from <base> to <derived>"{}});}
\DoxyCodeLine{428 }
\DoxyCodeLine{429       \textcolor{comment}{// Do the cast to `U` explicitly if necessary.}}
\DoxyCodeLine{430       \textcolor{comment}{// Otherwise, let implicit conversions do the trick.}}
\DoxyCodeLine{431       \textcolor{keyword}{using }CastType =}
\DoxyCodeLine{432           \textcolor{keyword}{typename} std::conditional<std::is\_convertible<T\&, const U\&>::value,}
\DoxyCodeLine{433                                     T\&, U>::type;}
\DoxyCodeLine{434 }
\DoxyCodeLine{435       \textcolor{keywordflow}{return} source\_matcher\_.MatchAndExplain(\textcolor{keyword}{static\_cast<}CastType\textcolor{keyword}{>}(x),}
\DoxyCodeLine{436                                              listener);}
\DoxyCodeLine{437     \}}
\DoxyCodeLine{438 }
\DoxyCodeLine{439     \textcolor{keywordtype}{void} DescribeTo(::std::ostream* os)\textcolor{keyword}{ const override }\{}
\DoxyCodeLine{440       source\_matcher\_.DescribeTo(os);}
\DoxyCodeLine{441     \}}
\DoxyCodeLine{442 }
\DoxyCodeLine{443     \textcolor{keywordtype}{void} DescribeNegationTo(::std::ostream* os)\textcolor{keyword}{ const override }\{}
\DoxyCodeLine{444       source\_matcher\_.DescribeNegationTo(os);}
\DoxyCodeLine{445     \}}
\DoxyCodeLine{446 }
\DoxyCodeLine{447    \textcolor{keyword}{private}:}
\DoxyCodeLine{448     \textcolor{keyword}{const} Matcher<U> source\_matcher\_;}
\DoxyCodeLine{449   \};}
\DoxyCodeLine{450 \};}
\DoxyCodeLine{451 }
\DoxyCodeLine{452 \textcolor{comment}{// This even more specialized version is used for efficiently casting}}
\DoxyCodeLine{453 \textcolor{comment}{// a matcher to its own type.}}
\DoxyCodeLine{454 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{455 \textcolor{keyword}{class }MatcherCastImpl<T, Matcher<T>> \{}
\DoxyCodeLine{456  \textcolor{keyword}{public}:}
\DoxyCodeLine{457   \textcolor{keyword}{static} Matcher<T> Cast(\textcolor{keyword}{const} Matcher<T>\& matcher) \{ \textcolor{keywordflow}{return} matcher; \}}
\DoxyCodeLine{458 \};}
\DoxyCodeLine{459 }
\DoxyCodeLine{460 \textcolor{comment}{// Template specialization for parameterless Matcher.}}
\DoxyCodeLine{461 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Derived>}
\DoxyCodeLine{462 \textcolor{keyword}{class }MatcherBaseImpl \{}
\DoxyCodeLine{463  \textcolor{keyword}{public}:}
\DoxyCodeLine{464   MatcherBaseImpl() = \textcolor{keywordflow}{default};}
\DoxyCodeLine{465 }
\DoxyCodeLine{466   \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{467   operator ::testing::Matcher<T>()\textcolor{keyword}{ const }\{  \textcolor{comment}{// NOLINT(runtime/explicit)}}
\DoxyCodeLine{468     return ::testing::Matcher<T>(\textcolor{keyword}{new}}
\DoxyCodeLine{469                                  \textcolor{keyword}{typename} Derived::template gmock\_Impl<T>());}
\DoxyCodeLine{470   \}}
\DoxyCodeLine{471 \};}
\DoxyCodeLine{472 }
\DoxyCodeLine{473 \textcolor{comment}{// Template specialization for Matcher with parameters.}}
\DoxyCodeLine{474 \textcolor{keyword}{template} <\textcolor{keyword}{template} <\textcolor{keyword}{typename}...> \textcolor{keyword}{class }Derived, \textcolor{keyword}{typename}... Ts>}
\DoxyCodeLine{475 \textcolor{keyword}{class }MatcherBaseImpl<Derived<Ts...>> \{}
\DoxyCodeLine{476  \textcolor{keyword}{public}:}
\DoxyCodeLine{477   \textcolor{comment}{// Mark the constructor explicit for single argument T to avoid implicit}}
\DoxyCodeLine{478   \textcolor{comment}{// conversions.}}
\DoxyCodeLine{479   \textcolor{keyword}{template} <\textcolor{keyword}{typename} E = std::enable\_if<\textcolor{keyword}{sizeof}...(Ts) == 1>,}
\DoxyCodeLine{480             \textcolor{keyword}{typename} E::type* = \textcolor{keyword}{nullptr}>}
\DoxyCodeLine{481   \textcolor{keyword}{explicit} MatcherBaseImpl(Ts... params)}
\DoxyCodeLine{482       : params\_(std::forward<Ts>(params)...) \{\}}
\DoxyCodeLine{483   \textcolor{keyword}{template} <\textcolor{keyword}{typename} E = std::enable\_if<\textcolor{keyword}{sizeof}...(Ts) != 1>,}
\DoxyCodeLine{484             \textcolor{keyword}{typename} = \textcolor{keyword}{typename} E::type>}
\DoxyCodeLine{485   MatcherBaseImpl(Ts... params)  \textcolor{comment}{// NOLINT}}
\DoxyCodeLine{486       : params\_(std::forward<Ts>(params)...) \{\}}
\DoxyCodeLine{487 }
\DoxyCodeLine{488   \textcolor{keyword}{template} <\textcolor{keyword}{typename} F>}
\DoxyCodeLine{489   operator ::testing::Matcher<F>()\textcolor{keyword}{ const }\{  \textcolor{comment}{// NOLINT(runtime/explicit)}}
\DoxyCodeLine{490     \textcolor{keywordflow}{return} Apply<F>(MakeIndexSequence<\textcolor{keyword}{sizeof}...(Ts)>\{\});}
\DoxyCodeLine{491   \}}
\DoxyCodeLine{492 }
\DoxyCodeLine{493  \textcolor{keyword}{private}:}
\DoxyCodeLine{494   \textcolor{keyword}{template} <\textcolor{keyword}{typename} F, std::size\_t... tuple\_ids>}
\DoxyCodeLine{495   \mbox{\hyperlink{classtesting_1_1Matcher}{::testing::Matcher<F>}} Apply(IndexSequence<tuple\_ids...>)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{496     return ::testing::Matcher<F>(}
\DoxyCodeLine{497         \textcolor{keyword}{new} \textcolor{keyword}{typename} Derived<Ts...>::template gmock\_Impl<F>(}
\DoxyCodeLine{498             std::get<tuple\_ids>(params\_)...));}
\DoxyCodeLine{499   \}}
\DoxyCodeLine{500 }
\DoxyCodeLine{501   \textcolor{keyword}{const} std::tuple<Ts...> params\_;}
\DoxyCodeLine{502 \};}
\DoxyCodeLine{503 }
\DoxyCodeLine{504 \}  \textcolor{comment}{// namespace internal}}
\DoxyCodeLine{505 }
\DoxyCodeLine{506 \textcolor{comment}{// In order to be safe and clear, casting between different matcher}}
\DoxyCodeLine{507 \textcolor{comment}{// types is done explicitly via MatcherCast<T>(m), which takes a}}
\DoxyCodeLine{508 \textcolor{comment}{// matcher m and returns a Matcher<T>.  It compiles only when T can be}}
\DoxyCodeLine{509 \textcolor{comment}{// statically converted to the argument type of m.}}
\DoxyCodeLine{510 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T, \textcolor{keyword}{typename} M>}
\DoxyCodeLine{511 \textcolor{keyword}{inline} Matcher<T> MatcherCast(\textcolor{keyword}{const} M\& matcher) \{}
\DoxyCodeLine{512   \textcolor{keywordflow}{return} internal::MatcherCastImpl<T, M>::Cast(matcher);}
\DoxyCodeLine{513 \}}
\DoxyCodeLine{514 }
\DoxyCodeLine{515 \textcolor{comment}{// This overload handles polymorphic matchers and values only since}}
\DoxyCodeLine{516 \textcolor{comment}{// monomorphic matchers are handled by the next one.}}
\DoxyCodeLine{517 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T, \textcolor{keyword}{typename} M>}
\DoxyCodeLine{518 \textcolor{keyword}{inline} Matcher<T> SafeMatcherCast(\textcolor{keyword}{const} M\& polymorphic\_matcher\_or\_value) \{}
\DoxyCodeLine{519   \textcolor{keywordflow}{return} MatcherCast<T>(polymorphic\_matcher\_or\_value);}
\DoxyCodeLine{520 \}}
\DoxyCodeLine{521 }
\DoxyCodeLine{522 \textcolor{comment}{// This overload handles monomorphic matchers.}}
\DoxyCodeLine{523 \textcolor{comment}{//}}
\DoxyCodeLine{524 \textcolor{comment}{// In general, if type T can be implicitly converted to type U, we can}}
\DoxyCodeLine{525 \textcolor{comment}{// safely convert a Matcher<U> to a Matcher<T> (i.e. Matcher is}}
\DoxyCodeLine{526 \textcolor{comment}{// contravariant): just keep a copy of the original Matcher<U>, convert the}}
\DoxyCodeLine{527 \textcolor{comment}{// argument from type T to U, and then pass it to the underlying Matcher<U>.}}
\DoxyCodeLine{528 \textcolor{comment}{// The only exception is when U is a reference and T is not, as the}}
\DoxyCodeLine{529 \textcolor{comment}{// underlying Matcher<U> may be interested in the argument's address, which}}
\DoxyCodeLine{530 \textcolor{comment}{// is not preserved in the conversion from T to U.}}
\DoxyCodeLine{531 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T, \textcolor{keyword}{typename} U>}
\DoxyCodeLine{532 \textcolor{keyword}{inline} Matcher<T> SafeMatcherCast(\textcolor{keyword}{const} Matcher<U>\& matcher) \{}
\DoxyCodeLine{533   \textcolor{comment}{// Enforce that T can be implicitly converted to U.}}
\DoxyCodeLine{534   \textcolor{keyword}{static\_assert}(std::is\_convertible<const T\&, const U\&>::value,}
\DoxyCodeLine{535                 \textcolor{stringliteral}{"{}T must be implicitly convertible to U"{}});}
\DoxyCodeLine{536   \textcolor{comment}{// Enforce that we are not converting a non-\/reference type T to a reference}}
\DoxyCodeLine{537   \textcolor{comment}{// type U.}}
\DoxyCodeLine{538   \textcolor{keyword}{static\_assert}(std::is\_reference<T>::value || !std::is\_reference<U>::value,}
\DoxyCodeLine{539                 \textcolor{stringliteral}{"{}cannot convert non reference arg to reference"{}});}
\DoxyCodeLine{540   \textcolor{comment}{// In case both T and U are arithmetic types, enforce that the}}
\DoxyCodeLine{541   \textcolor{comment}{// conversion is not lossy.}}
\DoxyCodeLine{542   \textcolor{keyword}{typedef} GTEST\_REMOVE\_REFERENCE\_AND\_CONST\_(T) RawT;}
\DoxyCodeLine{543   \textcolor{keyword}{typedef} GTEST\_REMOVE\_REFERENCE\_AND\_CONST\_(U) RawU;}
\DoxyCodeLine{544   \textcolor{keyword}{constexpr} \textcolor{keywordtype}{bool} kTIsOther = GMOCK\_KIND\_OF\_(RawT) == internal::kOther;}
\DoxyCodeLine{545   \textcolor{keyword}{constexpr} \textcolor{keywordtype}{bool} kUIsOther = GMOCK\_KIND\_OF\_(RawU) == internal::kOther;}
\DoxyCodeLine{546   \textcolor{keyword}{static\_assert}(}
\DoxyCodeLine{547       kTIsOther || kUIsOther ||}
\DoxyCodeLine{548           (internal::LosslessArithmeticConvertible<RawT, RawU>::value),}
\DoxyCodeLine{549       \textcolor{stringliteral}{"{}conversion of arithmetic types must be lossless"{}});}
\DoxyCodeLine{550   \textcolor{keywordflow}{return} MatcherCast<T>(matcher);}
\DoxyCodeLine{551 \}}
\DoxyCodeLine{552 }
\DoxyCodeLine{553 \textcolor{comment}{// A<T>() returns a matcher that matches any value of type T.}}
\DoxyCodeLine{554 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{555 Matcher<T> A();}
\DoxyCodeLine{556 }
\DoxyCodeLine{557 \textcolor{comment}{// Anything inside the 'internal' namespace IS INTERNAL IMPLEMENTATION}}
\DoxyCodeLine{558 \textcolor{comment}{// and MUST NOT BE USED IN USER CODE!!!}}
\DoxyCodeLine{559 \textcolor{keyword}{namespace }internal \{}
\DoxyCodeLine{560 }
\DoxyCodeLine{561 \textcolor{comment}{// If the explanation is not empty, prints it to the ostream.}}
\DoxyCodeLine{562 \textcolor{keyword}{inline} \textcolor{keywordtype}{void} PrintIfNotEmpty(\textcolor{keyword}{const} std::string\& explanation,}
\DoxyCodeLine{563                             ::std::ostream* os) \{}
\DoxyCodeLine{564   \textcolor{keywordflow}{if} (explanation != \textcolor{stringliteral}{"{}"{}} \&\& os != \textcolor{keyword}{nullptr}) \{}
\DoxyCodeLine{565     *os << \textcolor{stringliteral}{"{}, "{}} << explanation;}
\DoxyCodeLine{566   \}}
\DoxyCodeLine{567 \}}
\DoxyCodeLine{568 }
\DoxyCodeLine{569 \textcolor{comment}{// Returns true if the given type name is easy to read by a human.}}
\DoxyCodeLine{570 \textcolor{comment}{// This is used to decide whether printing the type of a value might}}
\DoxyCodeLine{571 \textcolor{comment}{// be helpful.}}
\DoxyCodeLine{572 \textcolor{keyword}{inline} \textcolor{keywordtype}{bool} IsReadableTypeName(\textcolor{keyword}{const} std::string\& type\_name) \{}
\DoxyCodeLine{573   \textcolor{comment}{// We consider a type name readable if it's short or doesn't contain}}
\DoxyCodeLine{574   \textcolor{comment}{// a template or function type.}}
\DoxyCodeLine{575   \textcolor{keywordflow}{return} (type\_name.length() <= 20 ||}
\DoxyCodeLine{576           type\_name.find\_first\_of(\textcolor{stringliteral}{"{}<("{}}) == std::string::npos);}
\DoxyCodeLine{577 \}}
\DoxyCodeLine{578 }
\DoxyCodeLine{579 \textcolor{comment}{// Matches the value against the given matcher, prints the value and explains}}
\DoxyCodeLine{580 \textcolor{comment}{// the match result to the listener. Returns the match result.}}
\DoxyCodeLine{581 \textcolor{comment}{// 'listener' must not be NULL.}}
\DoxyCodeLine{582 \textcolor{comment}{// Value cannot be passed by const reference, because some matchers take a}}
\DoxyCodeLine{583 \textcolor{comment}{// non-\/const argument.}}
\DoxyCodeLine{584 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Value, \textcolor{keyword}{typename} T>}
\DoxyCodeLine{585 \textcolor{keywordtype}{bool} MatchPrintAndExplain(Value\& value, \textcolor{keyword}{const} Matcher<T>\& matcher,}
\DoxyCodeLine{586                           MatchResultListener* listener) \{}
\DoxyCodeLine{587   \textcolor{keywordflow}{if} (!listener-\/>IsInterested()) \{}
\DoxyCodeLine{588     \textcolor{comment}{// If the listener is not interested, we do not need to construct the}}
\DoxyCodeLine{589     \textcolor{comment}{// inner explanation.}}
\DoxyCodeLine{590     \textcolor{keywordflow}{return} matcher.Matches(value);}
\DoxyCodeLine{591   \}}
\DoxyCodeLine{592 }
\DoxyCodeLine{593   StringMatchResultListener inner\_listener;}
\DoxyCodeLine{594   \textcolor{keyword}{const} \textcolor{keywordtype}{bool} match = matcher.MatchAndExplain(value, \&inner\_listener);}
\DoxyCodeLine{595 }
\DoxyCodeLine{596   UniversalPrint(value, listener-\/>stream());}
\DoxyCodeLine{597 \textcolor{preprocessor}{\#if GTEST\_HAS\_RTTI}}
\DoxyCodeLine{598   \textcolor{keyword}{const} std::string\& type\_name = GetTypeName<Value>();}
\DoxyCodeLine{599   \textcolor{keywordflow}{if} (IsReadableTypeName(type\_name))}
\DoxyCodeLine{600     *listener-\/>stream() << \textcolor{stringliteral}{"{} (of type "{}} << type\_name << \textcolor{stringliteral}{"{})"{}};}
\DoxyCodeLine{601 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{602   PrintIfNotEmpty(inner\_listener.str(), listener-\/>stream());}
\DoxyCodeLine{603 }
\DoxyCodeLine{604   \textcolor{keywordflow}{return} match;}
\DoxyCodeLine{605 \}}
\DoxyCodeLine{606 }
\DoxyCodeLine{607 \textcolor{comment}{// An internal helper class for doing compile-\/time loop on a tuple's}}
\DoxyCodeLine{608 \textcolor{comment}{// fields.}}
\DoxyCodeLine{609 \textcolor{keyword}{template} <\textcolor{keywordtype}{size\_t} N>}
\DoxyCodeLine{610 \textcolor{keyword}{class }TuplePrefix \{}
\DoxyCodeLine{611  \textcolor{keyword}{public}:}
\DoxyCodeLine{612   \textcolor{comment}{// TuplePrefix<N>::Matches(matcher\_tuple, value\_tuple) returns true}}
\DoxyCodeLine{613   \textcolor{comment}{// if and only if the first N fields of matcher\_tuple matches}}
\DoxyCodeLine{614   \textcolor{comment}{// the first N fields of value\_tuple, respectively.}}
\DoxyCodeLine{615   \textcolor{keyword}{template} <\textcolor{keyword}{typename} MatcherTuple, \textcolor{keyword}{typename} ValueTuple>}
\DoxyCodeLine{616   \textcolor{keyword}{static} \textcolor{keywordtype}{bool} Matches(\textcolor{keyword}{const} MatcherTuple\& matcher\_tuple,}
\DoxyCodeLine{617                       \textcolor{keyword}{const} ValueTuple\& value\_tuple) \{}
\DoxyCodeLine{618     \textcolor{keywordflow}{return} TuplePrefix<N -\/ 1>::Matches(matcher\_tuple, value\_tuple) \&\&}
\DoxyCodeLine{619            std::get<N -\/ 1>(matcher\_tuple).Matches(std::get<N -\/ 1>(value\_tuple));}
\DoxyCodeLine{620   \}}
\DoxyCodeLine{621 }
\DoxyCodeLine{622   \textcolor{comment}{// TuplePrefix<N>::ExplainMatchFailuresTo(matchers, values, os)}}
\DoxyCodeLine{623   \textcolor{comment}{// describes failures in matching the first N fields of matchers}}
\DoxyCodeLine{624   \textcolor{comment}{// against the first N fields of values.  If there is no failure,}}
\DoxyCodeLine{625   \textcolor{comment}{// nothing will be streamed to os.}}
\DoxyCodeLine{626   \textcolor{keyword}{template} <\textcolor{keyword}{typename} MatcherTuple, \textcolor{keyword}{typename} ValueTuple>}
\DoxyCodeLine{627   \textcolor{keyword}{static} \textcolor{keywordtype}{void} ExplainMatchFailuresTo(\textcolor{keyword}{const} MatcherTuple\& matchers,}
\DoxyCodeLine{628                                      \textcolor{keyword}{const} ValueTuple\& values,}
\DoxyCodeLine{629                                      ::std::ostream* os) \{}
\DoxyCodeLine{630     \textcolor{comment}{// First, describes failures in the first N -\/ 1 fields.}}
\DoxyCodeLine{631     TuplePrefix<N -\/ 1>::ExplainMatchFailuresTo(matchers, values, os);}
\DoxyCodeLine{632 }
\DoxyCodeLine{633     \textcolor{comment}{// Then describes the failure (if any) in the (N -\/ 1)-\/th (0-\/based)}}
\DoxyCodeLine{634     \textcolor{comment}{// field.}}
\DoxyCodeLine{635     \textcolor{keyword}{typename} std::tuple\_element<N -\/ 1, MatcherTuple>::type matcher =}
\DoxyCodeLine{636         std::get<N -\/ 1>(matchers);}
\DoxyCodeLine{637     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} std::tuple\_element<N -\/ 1, ValueTuple>::type Value;}
\DoxyCodeLine{638     \textcolor{keyword}{const} Value\& value = std::get<N -\/ 1>(values);}
\DoxyCodeLine{639     StringMatchResultListener listener;}
\DoxyCodeLine{640     \textcolor{keywordflow}{if} (!matcher.MatchAndExplain(value, \&listener)) \{}
\DoxyCodeLine{641       *os << \textcolor{stringliteral}{"{}  Expected arg \#"{}} << N -\/ 1 << \textcolor{stringliteral}{"{}: "{}};}
\DoxyCodeLine{642       std::get<N -\/ 1>(matchers).DescribeTo(os);}
\DoxyCodeLine{643       *os << \textcolor{stringliteral}{"{}\(\backslash\)n           Actual: "{}};}
\DoxyCodeLine{644       \textcolor{comment}{// We remove the reference in type Value to prevent the}}
\DoxyCodeLine{645       \textcolor{comment}{// universal printer from printing the address of value, which}}
\DoxyCodeLine{646       \textcolor{comment}{// isn't interesting to the user most of the time.  The}}
\DoxyCodeLine{647       \textcolor{comment}{// matcher's MatchAndExplain() method handles the case when}}
\DoxyCodeLine{648       \textcolor{comment}{// the address is interesting.}}
\DoxyCodeLine{649       internal::UniversalPrint(value, os);}
\DoxyCodeLine{650       PrintIfNotEmpty(listener.str(), os);}
\DoxyCodeLine{651       *os << \textcolor{stringliteral}{"{}\(\backslash\)n"{}};}
\DoxyCodeLine{652     \}}
\DoxyCodeLine{653   \}}
\DoxyCodeLine{654 \};}
\DoxyCodeLine{655 }
\DoxyCodeLine{656 \textcolor{comment}{// The base case.}}
\DoxyCodeLine{657 \textcolor{keyword}{template} <>}
\DoxyCodeLine{658 \textcolor{keyword}{class }TuplePrefix<0> \{}
\DoxyCodeLine{659  \textcolor{keyword}{public}:}
\DoxyCodeLine{660   \textcolor{keyword}{template} <\textcolor{keyword}{typename} MatcherTuple, \textcolor{keyword}{typename} ValueTuple>}
\DoxyCodeLine{661   \textcolor{keyword}{static} \textcolor{keywordtype}{bool} Matches(\textcolor{keyword}{const} MatcherTuple\& \textcolor{comment}{/* matcher\_tuple */},}
\DoxyCodeLine{662                       \textcolor{keyword}{const} ValueTuple\& \textcolor{comment}{/* value\_tuple */}) \{}
\DoxyCodeLine{663     \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{664   \}}
\DoxyCodeLine{665 }
\DoxyCodeLine{666   \textcolor{keyword}{template} <\textcolor{keyword}{typename} MatcherTuple, \textcolor{keyword}{typename} ValueTuple>}
\DoxyCodeLine{667   \textcolor{keyword}{static} \textcolor{keywordtype}{void} ExplainMatchFailuresTo(\textcolor{keyword}{const} MatcherTuple\& \textcolor{comment}{/* matchers */},}
\DoxyCodeLine{668                                      \textcolor{keyword}{const} ValueTuple\& \textcolor{comment}{/* values */},}
\DoxyCodeLine{669                                      ::std::ostream* \textcolor{comment}{/* os */}) \{\}}
\DoxyCodeLine{670 \};}
\DoxyCodeLine{671 }
\DoxyCodeLine{672 \textcolor{comment}{// TupleMatches(matcher\_tuple, value\_tuple) returns true if and only if}}
\DoxyCodeLine{673 \textcolor{comment}{// all matchers in matcher\_tuple match the corresponding fields in}}
\DoxyCodeLine{674 \textcolor{comment}{// value\_tuple.  It is a compiler error if matcher\_tuple and}}
\DoxyCodeLine{675 \textcolor{comment}{// value\_tuple have different number of fields or incompatible field}}
\DoxyCodeLine{676 \textcolor{comment}{// types.}}
\DoxyCodeLine{677 \textcolor{keyword}{template} <\textcolor{keyword}{typename} MatcherTuple, \textcolor{keyword}{typename} ValueTuple>}
\DoxyCodeLine{678 \textcolor{keywordtype}{bool} TupleMatches(\textcolor{keyword}{const} MatcherTuple\& matcher\_tuple,}
\DoxyCodeLine{679                   \textcolor{keyword}{const} ValueTuple\& value\_tuple) \{}
\DoxyCodeLine{680   \textcolor{comment}{// Makes sure that matcher\_tuple and value\_tuple have the same}}
\DoxyCodeLine{681   \textcolor{comment}{// number of fields.}}
\DoxyCodeLine{682   \textcolor{keyword}{static\_assert}(std::tuple\_size<MatcherTuple>::value ==}
\DoxyCodeLine{683                     std::tuple\_size<ValueTuple>::value,}
\DoxyCodeLine{684                 \textcolor{stringliteral}{"{}matcher and value have different numbers of fields"{}});}
\DoxyCodeLine{685   \textcolor{keywordflow}{return} TuplePrefix<std::tuple\_size<ValueTuple>::value>::Matches(matcher\_tuple,}
\DoxyCodeLine{686                                                                   value\_tuple);}
\DoxyCodeLine{687 \}}
\DoxyCodeLine{688 }
\DoxyCodeLine{689 \textcolor{comment}{// Describes failures in matching matchers against values.  If there}}
\DoxyCodeLine{690 \textcolor{comment}{// is no failure, nothing will be streamed to os.}}
\DoxyCodeLine{691 \textcolor{keyword}{template} <\textcolor{keyword}{typename} MatcherTuple, \textcolor{keyword}{typename} ValueTuple>}
\DoxyCodeLine{692 \textcolor{keywordtype}{void} ExplainMatchFailureTupleTo(\textcolor{keyword}{const} MatcherTuple\& matchers,}
\DoxyCodeLine{693                                 \textcolor{keyword}{const} ValueTuple\& values, ::std::ostream* os) \{}
\DoxyCodeLine{694   TuplePrefix<std::tuple\_size<MatcherTuple>::value>::ExplainMatchFailuresTo(}
\DoxyCodeLine{695       matchers, values, os);}
\DoxyCodeLine{696 \}}
\DoxyCodeLine{697 }
\DoxyCodeLine{698 \textcolor{comment}{// TransformTupleValues and its helper.}}
\DoxyCodeLine{699 \textcolor{comment}{//}}
\DoxyCodeLine{700 \textcolor{comment}{// TransformTupleValuesHelper hides the internal machinery that}}
\DoxyCodeLine{701 \textcolor{comment}{// TransformTupleValues uses to implement a tuple traversal.}}
\DoxyCodeLine{702 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Tuple, \textcolor{keyword}{typename} Func, \textcolor{keyword}{typename} OutIter>}
\DoxyCodeLine{703 \textcolor{keyword}{class }TransformTupleValuesHelper \{}
\DoxyCodeLine{704  \textcolor{keyword}{private}:}
\DoxyCodeLine{705   typedef ::std::tuple\_size<Tuple> TupleSize;}
\DoxyCodeLine{706 }
\DoxyCodeLine{707  \textcolor{keyword}{public}:}
\DoxyCodeLine{708   \textcolor{comment}{// For each member of tuple 't', taken in order, evaluates '*out++ = f(t)'.}}
\DoxyCodeLine{709   \textcolor{comment}{// Returns the final value of 'out' in case the caller needs it.}}
\DoxyCodeLine{710   \textcolor{keyword}{static} OutIter Run(Func f, \textcolor{keyword}{const} Tuple\& t, OutIter out) \{}
\DoxyCodeLine{711     \textcolor{keywordflow}{return} IterateOverTuple<Tuple, TupleSize::value>()(f, t, out);}
\DoxyCodeLine{712   \}}
\DoxyCodeLine{713 }
\DoxyCodeLine{714  \textcolor{keyword}{private}:}
\DoxyCodeLine{715   \textcolor{keyword}{template} <\textcolor{keyword}{typename} Tup, \textcolor{keywordtype}{size\_t} kRemainingSize>}
\DoxyCodeLine{716   \textcolor{keyword}{struct }IterateOverTuple \{}
\DoxyCodeLine{717     OutIter operator()(Func f, \textcolor{keyword}{const} Tup\& t, OutIter out)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{718       *out++ = f(::std::get<TupleSize::value -\/ kRemainingSize>(t));}
\DoxyCodeLine{719       \textcolor{keywordflow}{return} IterateOverTuple<Tup, kRemainingSize -\/ 1>()(f, t, out);}
\DoxyCodeLine{720     \}}
\DoxyCodeLine{721   \};}
\DoxyCodeLine{722   \textcolor{keyword}{template} <\textcolor{keyword}{typename} Tup>}
\DoxyCodeLine{723   \textcolor{keyword}{struct }IterateOverTuple<Tup, 0> \{}
\DoxyCodeLine{724     OutIter operator()(Func \textcolor{comment}{/* f */}, \textcolor{keyword}{const} Tup\& \textcolor{comment}{/* t */}, OutIter out)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{725       \textcolor{keywordflow}{return} out;}
\DoxyCodeLine{726     \}}
\DoxyCodeLine{727   \};}
\DoxyCodeLine{728 \};}
\DoxyCodeLine{729 }
\DoxyCodeLine{730 \textcolor{comment}{// Successively invokes 'f(element)' on each element of the tuple 't',}}
\DoxyCodeLine{731 \textcolor{comment}{// appending each result to the 'out' iterator. Returns the final value}}
\DoxyCodeLine{732 \textcolor{comment}{// of 'out'.}}
\DoxyCodeLine{733 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Tuple, \textcolor{keyword}{typename} Func, \textcolor{keyword}{typename} OutIter>}
\DoxyCodeLine{734 OutIter TransformTupleValues(Func f, \textcolor{keyword}{const} Tuple\& t, OutIter out) \{}
\DoxyCodeLine{735   \textcolor{keywordflow}{return} TransformTupleValuesHelper<Tuple, Func, OutIter>::Run(f, t, out);}
\DoxyCodeLine{736 \}}
\DoxyCodeLine{737 }
\DoxyCodeLine{738 \textcolor{comment}{// Implements \_, a matcher that matches any value of any}}
\DoxyCodeLine{739 \textcolor{comment}{// type.  This is a polymorphic matcher, so we need a template type}}
\DoxyCodeLine{740 \textcolor{comment}{// conversion operator to make it appearing as a Matcher<T> for any}}
\DoxyCodeLine{741 \textcolor{comment}{// type T.}}
\DoxyCodeLine{742 \textcolor{keyword}{class }AnythingMatcher \{}
\DoxyCodeLine{743  \textcolor{keyword}{public}:}
\DoxyCodeLine{744   \textcolor{keyword}{using }is\_gtest\_matcher = void;}
\DoxyCodeLine{745 }
\DoxyCodeLine{746   \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{747   \textcolor{keywordtype}{bool} MatchAndExplain(\textcolor{keyword}{const} T\& \textcolor{comment}{/* x */}, std::ostream* \textcolor{comment}{/* listener */})\textcolor{keyword}{ const }\{}
\DoxyCodeLine{748     \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{749   \}}
\DoxyCodeLine{750   \textcolor{keywordtype}{void} DescribeTo(std::ostream* os)\textcolor{keyword}{ const }\{ *os << \textcolor{stringliteral}{"{}is anything"{}}; \}}
\DoxyCodeLine{751   \textcolor{keywordtype}{void} DescribeNegationTo(::std::ostream* os)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{752     \textcolor{comment}{// This is mostly for completeness' sake, as it's not very useful}}
\DoxyCodeLine{753     \textcolor{comment}{// to write Not(A<bool>()).  However we cannot completely rule out}}
\DoxyCodeLine{754     \textcolor{comment}{// such a possibility, and it doesn't hurt to be prepared.}}
\DoxyCodeLine{755     *os << \textcolor{stringliteral}{"{}never matches"{}};}
\DoxyCodeLine{756   \}}
\DoxyCodeLine{757 \};}
\DoxyCodeLine{758 }
\DoxyCodeLine{759 \textcolor{comment}{// Implements the polymorphic IsNull() matcher, which matches any raw or smart}}
\DoxyCodeLine{760 \textcolor{comment}{// pointer that is NULL.}}
\DoxyCodeLine{761 \textcolor{keyword}{class }IsNullMatcher \{}
\DoxyCodeLine{762  \textcolor{keyword}{public}:}
\DoxyCodeLine{763   \textcolor{keyword}{template} <\textcolor{keyword}{typename} Po\textcolor{keywordtype}{int}er>}
\DoxyCodeLine{764   \textcolor{keywordtype}{bool} MatchAndExplain(\textcolor{keyword}{const} Pointer\& p,}
\DoxyCodeLine{765                        MatchResultListener* \textcolor{comment}{/* listener */})\textcolor{keyword}{ const }\{}
\DoxyCodeLine{766     \textcolor{keywordflow}{return} p == \textcolor{keyword}{nullptr};}
\DoxyCodeLine{767   \}}
\DoxyCodeLine{768 }
\DoxyCodeLine{769   \textcolor{keywordtype}{void} DescribeTo(::std::ostream* os)\textcolor{keyword}{ const }\{ *os << \textcolor{stringliteral}{"{}is NULL"{}}; \}}
\DoxyCodeLine{770   \textcolor{keywordtype}{void} DescribeNegationTo(::std::ostream* os)\textcolor{keyword}{ const }\{ *os << \textcolor{stringliteral}{"{}isn't NULL"{}}; \}}
\DoxyCodeLine{771 \};}
\DoxyCodeLine{772 }
\DoxyCodeLine{773 \textcolor{comment}{// Implements the polymorphic NotNull() matcher, which matches any raw or smart}}
\DoxyCodeLine{774 \textcolor{comment}{// pointer that is not NULL.}}
\DoxyCodeLine{775 \textcolor{keyword}{class }NotNullMatcher \{}
\DoxyCodeLine{776  \textcolor{keyword}{public}:}
\DoxyCodeLine{777   \textcolor{keyword}{template} <\textcolor{keyword}{typename} Po\textcolor{keywordtype}{int}er>}
\DoxyCodeLine{778   \textcolor{keywordtype}{bool} MatchAndExplain(\textcolor{keyword}{const} Pointer\& p,}
\DoxyCodeLine{779                        MatchResultListener* \textcolor{comment}{/* listener */})\textcolor{keyword}{ const }\{}
\DoxyCodeLine{780     \textcolor{keywordflow}{return} p != \textcolor{keyword}{nullptr};}
\DoxyCodeLine{781   \}}
\DoxyCodeLine{782 }
\DoxyCodeLine{783   \textcolor{keywordtype}{void} DescribeTo(::std::ostream* os)\textcolor{keyword}{ const }\{ *os << \textcolor{stringliteral}{"{}isn't NULL"{}}; \}}
\DoxyCodeLine{784   \textcolor{keywordtype}{void} DescribeNegationTo(::std::ostream* os)\textcolor{keyword}{ const }\{ *os << \textcolor{stringliteral}{"{}is NULL"{}}; \}}
\DoxyCodeLine{785 \};}
\DoxyCodeLine{786 }
\DoxyCodeLine{787 \textcolor{comment}{// Ref(variable) matches any argument that is a reference to}}
\DoxyCodeLine{788 \textcolor{comment}{// 'variable'.  This matcher is polymorphic as it can match any}}
\DoxyCodeLine{789 \textcolor{comment}{// super type of the type of 'variable'.}}
\DoxyCodeLine{790 \textcolor{comment}{//}}
\DoxyCodeLine{791 \textcolor{comment}{// The RefMatcher template class implements Ref(variable).  It can}}
\DoxyCodeLine{792 \textcolor{comment}{// only be instantiated with a reference type.  This prevents a user}}
\DoxyCodeLine{793 \textcolor{comment}{// from mistakenly using Ref(x) to match a non-\/reference function}}
\DoxyCodeLine{794 \textcolor{comment}{// argument.  For example, the following will righteously cause a}}
\DoxyCodeLine{795 \textcolor{comment}{// compiler error:}}
\DoxyCodeLine{796 \textcolor{comment}{//}}
\DoxyCodeLine{797 \textcolor{comment}{//   int n;}}
\DoxyCodeLine{798 \textcolor{comment}{//   Matcher<int> m1 = Ref(n);   // This won't compile.}}
\DoxyCodeLine{799 \textcolor{comment}{//   Matcher<int\&> m2 = Ref(n);  // This will compile.}}
\DoxyCodeLine{800 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{801 \textcolor{keyword}{class }RefMatcher;}
\DoxyCodeLine{802 }
\DoxyCodeLine{803 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{804 \textcolor{keyword}{class }RefMatcher<T\&> \{}
\DoxyCodeLine{805   \textcolor{comment}{// Google Mock is a generic framework and thus needs to support}}
\DoxyCodeLine{806   \textcolor{comment}{// mocking any function types, including those that take non-\/const}}
\DoxyCodeLine{807   \textcolor{comment}{// reference arguments.  Therefore the template parameter T (and}}
\DoxyCodeLine{808   \textcolor{comment}{// Super below) can be instantiated to either a const type or a}}
\DoxyCodeLine{809   \textcolor{comment}{// non-\/const type.}}
\DoxyCodeLine{810  \textcolor{keyword}{public}:}
\DoxyCodeLine{811   \textcolor{comment}{// RefMatcher() takes a T\& instead of const T\&, as we want the}}
\DoxyCodeLine{812   \textcolor{comment}{// compiler to catch using Ref(const\_value) as a matcher for a}}
\DoxyCodeLine{813   \textcolor{comment}{// non-\/const reference.}}
\DoxyCodeLine{814   \textcolor{keyword}{explicit} RefMatcher(T\& x) : object\_(x) \{\}  \textcolor{comment}{// NOLINT}}
\DoxyCodeLine{815 }
\DoxyCodeLine{816   \textcolor{keyword}{template} <\textcolor{keyword}{typename} Super>}
\DoxyCodeLine{817   \textcolor{keyword}{operator} Matcher<Super\&>()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{818     \textcolor{comment}{// By passing object\_ (type T\&) to Impl(), which expects a Super\&,}}
\DoxyCodeLine{819     \textcolor{comment}{// we make sure that Super is a super type of T.  In particular,}}
\DoxyCodeLine{820     \textcolor{comment}{// this catches using Ref(const\_value) as a matcher for a}}
\DoxyCodeLine{821     \textcolor{comment}{// non-\/const reference, as you cannot implicitly convert a const}}
\DoxyCodeLine{822     \textcolor{comment}{// reference to a non-\/const reference.}}
\DoxyCodeLine{823     \textcolor{keywordflow}{return} MakeMatcher(\textcolor{keyword}{new} Impl<Super>(object\_));}
\DoxyCodeLine{824   \}}
\DoxyCodeLine{825 }
\DoxyCodeLine{826  \textcolor{keyword}{private}:}
\DoxyCodeLine{827   \textcolor{keyword}{template} <\textcolor{keyword}{typename} Super>}
\DoxyCodeLine{828   \textcolor{keyword}{class }Impl : \textcolor{keyword}{public} MatcherInterface<Super\&> \{}
\DoxyCodeLine{829    \textcolor{keyword}{public}:}
\DoxyCodeLine{830     \textcolor{keyword}{explicit} Impl(Super\& x) : object\_(x) \{\}  \textcolor{comment}{// NOLINT}}
\DoxyCodeLine{831 }
\DoxyCodeLine{832     \textcolor{comment}{// MatchAndExplain() takes a Super\& (as opposed to const Super\&)}}
\DoxyCodeLine{833     \textcolor{comment}{// in order to match the interface MatcherInterface<Super\&>.}}
\DoxyCodeLine{834     \textcolor{keywordtype}{bool} MatchAndExplain(Super\& x,}
\DoxyCodeLine{835                          MatchResultListener* listener)\textcolor{keyword}{ const override }\{}
\DoxyCodeLine{836       *listener << \textcolor{stringliteral}{"{}which is located @"{}} << \textcolor{keyword}{static\_cast<}\textcolor{keyword}{const }\textcolor{keywordtype}{void}*\textcolor{keyword}{>}(\&x);}
\DoxyCodeLine{837       \textcolor{keywordflow}{return} \&x == \&object\_;}
\DoxyCodeLine{838     \}}
\DoxyCodeLine{839 }
\DoxyCodeLine{840     \textcolor{keywordtype}{void} DescribeTo(::std::ostream* os)\textcolor{keyword}{ const override }\{}
\DoxyCodeLine{841       *os << \textcolor{stringliteral}{"{}references the variable "{}};}
\DoxyCodeLine{842       UniversalPrinter<Super\&>::Print(object\_, os);}
\DoxyCodeLine{843     \}}
\DoxyCodeLine{844 }
\DoxyCodeLine{845     \textcolor{keywordtype}{void} DescribeNegationTo(::std::ostream* os)\textcolor{keyword}{ const override }\{}
\DoxyCodeLine{846       *os << \textcolor{stringliteral}{"{}does not reference the variable "{}};}
\DoxyCodeLine{847       UniversalPrinter<Super\&>::Print(object\_, os);}
\DoxyCodeLine{848     \}}
\DoxyCodeLine{849 }
\DoxyCodeLine{850    \textcolor{keyword}{private}:}
\DoxyCodeLine{851     \textcolor{keyword}{const} Super\& object\_;}
\DoxyCodeLine{852   \};}
\DoxyCodeLine{853 }
\DoxyCodeLine{854   T\& object\_;}
\DoxyCodeLine{855 \};}
\DoxyCodeLine{856 }
\DoxyCodeLine{857 \textcolor{comment}{// Polymorphic helper functions for narrow and wide string matchers.}}
\DoxyCodeLine{858 \textcolor{keyword}{inline} \textcolor{keywordtype}{bool} CaseInsensitiveCStringEquals(\textcolor{keyword}{const} \textcolor{keywordtype}{char}* lhs, \textcolor{keyword}{const} \textcolor{keywordtype}{char}* rhs) \{}
\DoxyCodeLine{859   \textcolor{keywordflow}{return} String::CaseInsensitiveCStringEquals(lhs, rhs);}
\DoxyCodeLine{860 \}}
\DoxyCodeLine{861 }
\DoxyCodeLine{862 \textcolor{keyword}{inline} \textcolor{keywordtype}{bool} CaseInsensitiveCStringEquals(\textcolor{keyword}{const} \textcolor{keywordtype}{wchar\_t}* lhs,}
\DoxyCodeLine{863                                          \textcolor{keyword}{const} \textcolor{keywordtype}{wchar\_t}* rhs) \{}
\DoxyCodeLine{864   \textcolor{keywordflow}{return} String::CaseInsensitiveWideCStringEquals(lhs, rhs);}
\DoxyCodeLine{865 \}}
\DoxyCodeLine{866 }
\DoxyCodeLine{867 \textcolor{comment}{// String comparison for narrow or wide strings that can have embedded NUL}}
\DoxyCodeLine{868 \textcolor{comment}{// characters.}}
\DoxyCodeLine{869 \textcolor{keyword}{template} <\textcolor{keyword}{typename} StringType>}
\DoxyCodeLine{870 \textcolor{keywordtype}{bool} CaseInsensitiveStringEquals(\textcolor{keyword}{const} StringType\& s1, \textcolor{keyword}{const} StringType\& s2) \{}
\DoxyCodeLine{871   \textcolor{comment}{// Are the heads equal?}}
\DoxyCodeLine{872   \textcolor{keywordflow}{if} (!CaseInsensitiveCStringEquals(s1.c\_str(), s2.c\_str())) \{}
\DoxyCodeLine{873     \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{874   \}}
\DoxyCodeLine{875 }
\DoxyCodeLine{876   \textcolor{comment}{// Skip the equal heads.}}
\DoxyCodeLine{877   \textcolor{keyword}{const} \textcolor{keyword}{typename} StringType::value\_type nul = 0;}
\DoxyCodeLine{878   \textcolor{keyword}{const} \textcolor{keywordtype}{size\_t} i1 = s1.find(nul), i2 = s2.find(nul);}
\DoxyCodeLine{879 }
\DoxyCodeLine{880   \textcolor{comment}{// Are we at the end of either s1 or s2?}}
\DoxyCodeLine{881   \textcolor{keywordflow}{if} (i1 == StringType::npos || i2 == StringType::npos) \{}
\DoxyCodeLine{882     \textcolor{keywordflow}{return} i1 == i2;}
\DoxyCodeLine{883   \}}
\DoxyCodeLine{884 }
\DoxyCodeLine{885   \textcolor{comment}{// Are the tails equal?}}
\DoxyCodeLine{886   \textcolor{keywordflow}{return} CaseInsensitiveStringEquals(s1.substr(i1 + 1), s2.substr(i2 + 1));}
\DoxyCodeLine{887 \}}
\DoxyCodeLine{888 }
\DoxyCodeLine{889 \textcolor{comment}{// String matchers.}}
\DoxyCodeLine{890 }
\DoxyCodeLine{891 \textcolor{comment}{// Implements equality-\/based string matchers like StrEq, StrCaseNe, and etc.}}
\DoxyCodeLine{892 \textcolor{keyword}{template} <\textcolor{keyword}{typename} StringType>}
\DoxyCodeLine{893 \textcolor{keyword}{class }StrEqualityMatcher \{}
\DoxyCodeLine{894  \textcolor{keyword}{public}:}
\DoxyCodeLine{895   StrEqualityMatcher(StringType str, \textcolor{keywordtype}{bool} expect\_eq, \textcolor{keywordtype}{bool} case\_sensitive)}
\DoxyCodeLine{896       : string\_(std::move(str)),}
\DoxyCodeLine{897         expect\_eq\_(expect\_eq),}
\DoxyCodeLine{898         case\_sensitive\_(case\_sensitive) \{\}}
\DoxyCodeLine{899 }
\DoxyCodeLine{900 \textcolor{preprocessor}{\#if GTEST\_INTERNAL\_HAS\_STRING\_VIEW}}
\DoxyCodeLine{901   \textcolor{keywordtype}{bool} MatchAndExplain(\textcolor{keyword}{const} internal::StringView\& s,}
\DoxyCodeLine{902                        MatchResultListener* listener)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{903     \textcolor{comment}{// This should fail to compile if StringView is used with wide}}
\DoxyCodeLine{904     \textcolor{comment}{// strings.}}
\DoxyCodeLine{905     \textcolor{keyword}{const} StringType\& str = std::string(s);}
\DoxyCodeLine{906     \textcolor{keywordflow}{return} MatchAndExplain(str, listener);}
\DoxyCodeLine{907   \}}
\DoxyCodeLine{908 \textcolor{preprocessor}{\#endif  }\textcolor{comment}{// GTEST\_INTERNAL\_HAS\_STRING\_VIEW}}
\DoxyCodeLine{909 }
\DoxyCodeLine{910   \textcolor{comment}{// Accepts pointer types, particularly:}}
\DoxyCodeLine{911   \textcolor{comment}{//   const char*}}
\DoxyCodeLine{912   \textcolor{comment}{//   char*}}
\DoxyCodeLine{913   \textcolor{comment}{//   const wchar\_t*}}
\DoxyCodeLine{914   \textcolor{comment}{//   wchar\_t*}}
\DoxyCodeLine{915   \textcolor{keyword}{template} <\textcolor{keyword}{typename} CharType>}
\DoxyCodeLine{916   \textcolor{keywordtype}{bool} MatchAndExplain(CharType* s, MatchResultListener* listener)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{917     \textcolor{keywordflow}{if} (s == \textcolor{keyword}{nullptr}) \{}
\DoxyCodeLine{918       \textcolor{keywordflow}{return} !expect\_eq\_;}
\DoxyCodeLine{919     \}}
\DoxyCodeLine{920     \textcolor{keywordflow}{return} MatchAndExplain(StringType(s), listener);}
\DoxyCodeLine{921   \}}
\DoxyCodeLine{922 }
\DoxyCodeLine{923   \textcolor{comment}{// Matches anything that can convert to StringType.}}
\DoxyCodeLine{924   \textcolor{comment}{//}}
\DoxyCodeLine{925   \textcolor{comment}{// This is a template, not just a plain function with const StringType\&,}}
\DoxyCodeLine{926   \textcolor{comment}{// because StringView has some interfering non-\/explicit constructors.}}
\DoxyCodeLine{927   \textcolor{keyword}{template} <\textcolor{keyword}{typename} MatcheeStringType>}
\DoxyCodeLine{928   \textcolor{keywordtype}{bool} MatchAndExplain(\textcolor{keyword}{const} MatcheeStringType\& s,}
\DoxyCodeLine{929                        MatchResultListener* \textcolor{comment}{/* listener */})\textcolor{keyword}{ const }\{}
\DoxyCodeLine{930     \textcolor{keyword}{const} StringType s2(s);}
\DoxyCodeLine{931     \textcolor{keyword}{const} \textcolor{keywordtype}{bool} eq = case\_sensitive\_ ? s2 == string\_}
\DoxyCodeLine{932                                     : CaseInsensitiveStringEquals(s2, string\_);}
\DoxyCodeLine{933     \textcolor{keywordflow}{return} expect\_eq\_ == eq;}
\DoxyCodeLine{934   \}}
\DoxyCodeLine{935 }
\DoxyCodeLine{936   \textcolor{keywordtype}{void} DescribeTo(::std::ostream* os)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{937     DescribeToHelper(expect\_eq\_, os);}
\DoxyCodeLine{938   \}}
\DoxyCodeLine{939 }
\DoxyCodeLine{940   \textcolor{keywordtype}{void} DescribeNegationTo(::std::ostream* os)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{941     DescribeToHelper(!expect\_eq\_, os);}
\DoxyCodeLine{942   \}}
\DoxyCodeLine{943 }
\DoxyCodeLine{944  \textcolor{keyword}{private}:}
\DoxyCodeLine{945   \textcolor{keywordtype}{void} DescribeToHelper(\textcolor{keywordtype}{bool} expect\_eq, ::std::ostream* os)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{946     *os << (expect\_eq ? \textcolor{stringliteral}{"{}is "{}} : \textcolor{stringliteral}{"{}isn't "{}});}
\DoxyCodeLine{947     *os << \textcolor{stringliteral}{"{}equal to "{}};}
\DoxyCodeLine{948     \textcolor{keywordflow}{if} (!case\_sensitive\_) \{}
\DoxyCodeLine{949       *os << \textcolor{stringliteral}{"{}(ignoring case) "{}};}
\DoxyCodeLine{950     \}}
\DoxyCodeLine{951     UniversalPrint(string\_, os);}
\DoxyCodeLine{952   \}}
\DoxyCodeLine{953 }
\DoxyCodeLine{954   \textcolor{keyword}{const} StringType string\_;}
\DoxyCodeLine{955   \textcolor{keyword}{const} \textcolor{keywordtype}{bool} expect\_eq\_;}
\DoxyCodeLine{956   \textcolor{keyword}{const} \textcolor{keywordtype}{bool} case\_sensitive\_;}
\DoxyCodeLine{957 \};}
\DoxyCodeLine{958 }
\DoxyCodeLine{959 \textcolor{comment}{// Implements the polymorphic HasSubstr(substring) matcher, which}}
\DoxyCodeLine{960 \textcolor{comment}{// can be used as a Matcher<T> as long as T can be converted to a}}
\DoxyCodeLine{961 \textcolor{comment}{// string.}}
\DoxyCodeLine{962 \textcolor{keyword}{template} <\textcolor{keyword}{typename} StringType>}
\DoxyCodeLine{963 \textcolor{keyword}{class }HasSubstrMatcher \{}
\DoxyCodeLine{964  \textcolor{keyword}{public}:}
\DoxyCodeLine{965   \textcolor{keyword}{explicit} HasSubstrMatcher(\textcolor{keyword}{const} StringType\& substring)}
\DoxyCodeLine{966       : substring\_(substring) \{\}}
\DoxyCodeLine{967 }
\DoxyCodeLine{968 \textcolor{preprocessor}{\#if GTEST\_INTERNAL\_HAS\_STRING\_VIEW}}
\DoxyCodeLine{969   \textcolor{keywordtype}{bool} MatchAndExplain(\textcolor{keyword}{const} internal::StringView\& s,}
\DoxyCodeLine{970                        MatchResultListener* listener)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{971     \textcolor{comment}{// This should fail to compile if StringView is used with wide}}
\DoxyCodeLine{972     \textcolor{comment}{// strings.}}
\DoxyCodeLine{973     \textcolor{keyword}{const} StringType\& str = std::string(s);}
\DoxyCodeLine{974     \textcolor{keywordflow}{return} MatchAndExplain(str, listener);}
\DoxyCodeLine{975   \}}
\DoxyCodeLine{976 \textcolor{preprocessor}{\#endif  }\textcolor{comment}{// GTEST\_INTERNAL\_HAS\_STRING\_VIEW}}
\DoxyCodeLine{977 }
\DoxyCodeLine{978   \textcolor{comment}{// Accepts pointer types, particularly:}}
\DoxyCodeLine{979   \textcolor{comment}{//   const char*}}
\DoxyCodeLine{980   \textcolor{comment}{//   char*}}
\DoxyCodeLine{981   \textcolor{comment}{//   const wchar\_t*}}
\DoxyCodeLine{982   \textcolor{comment}{//   wchar\_t*}}
\DoxyCodeLine{983   \textcolor{keyword}{template} <\textcolor{keyword}{typename} CharType>}
\DoxyCodeLine{984   \textcolor{keywordtype}{bool} MatchAndExplain(CharType* s, MatchResultListener* listener)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{985     \textcolor{keywordflow}{return} s != \textcolor{keyword}{nullptr} \&\& MatchAndExplain(StringType(s), listener);}
\DoxyCodeLine{986   \}}
\DoxyCodeLine{987 }
\DoxyCodeLine{988   \textcolor{comment}{// Matches anything that can convert to StringType.}}
\DoxyCodeLine{989   \textcolor{comment}{//}}
\DoxyCodeLine{990   \textcolor{comment}{// This is a template, not just a plain function with const StringType\&,}}
\DoxyCodeLine{991   \textcolor{comment}{// because StringView has some interfering non-\/explicit constructors.}}
\DoxyCodeLine{992   \textcolor{keyword}{template} <\textcolor{keyword}{typename} MatcheeStringType>}
\DoxyCodeLine{993   \textcolor{keywordtype}{bool} MatchAndExplain(\textcolor{keyword}{const} MatcheeStringType\& s,}
\DoxyCodeLine{994                        MatchResultListener* \textcolor{comment}{/* listener */})\textcolor{keyword}{ const }\{}
\DoxyCodeLine{995     \textcolor{keywordflow}{return} StringType(s).find(substring\_) != StringType::npos;}
\DoxyCodeLine{996   \}}
\DoxyCodeLine{997 }
\DoxyCodeLine{998   \textcolor{comment}{// Describes what this matcher matches.}}
\DoxyCodeLine{999   \textcolor{keywordtype}{void} DescribeTo(::std::ostream* os)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{1000     *os << \textcolor{stringliteral}{"{}has substring "{}};}
\DoxyCodeLine{1001     UniversalPrint(substring\_, os);}
\DoxyCodeLine{1002   \}}
\DoxyCodeLine{1003 }
\DoxyCodeLine{1004   \textcolor{keywordtype}{void} DescribeNegationTo(::std::ostream* os)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{1005     *os << \textcolor{stringliteral}{"{}has no substring "{}};}
\DoxyCodeLine{1006     UniversalPrint(substring\_, os);}
\DoxyCodeLine{1007   \}}
\DoxyCodeLine{1008 }
\DoxyCodeLine{1009  \textcolor{keyword}{private}:}
\DoxyCodeLine{1010   \textcolor{keyword}{const} StringType substring\_;}
\DoxyCodeLine{1011 \};}
\DoxyCodeLine{1012 }
\DoxyCodeLine{1013 \textcolor{comment}{// Implements the polymorphic StartsWith(substring) matcher, which}}
\DoxyCodeLine{1014 \textcolor{comment}{// can be used as a Matcher<T> as long as T can be converted to a}}
\DoxyCodeLine{1015 \textcolor{comment}{// string.}}
\DoxyCodeLine{1016 \textcolor{keyword}{template} <\textcolor{keyword}{typename} StringType>}
\DoxyCodeLine{1017 \textcolor{keyword}{class }StartsWithMatcher \{}
\DoxyCodeLine{1018  \textcolor{keyword}{public}:}
\DoxyCodeLine{1019   \textcolor{keyword}{explicit} StartsWithMatcher(\textcolor{keyword}{const} StringType\& prefix) : prefix\_(prefix) \{\}}
\DoxyCodeLine{1020 }
\DoxyCodeLine{1021 \textcolor{preprocessor}{\#if GTEST\_INTERNAL\_HAS\_STRING\_VIEW}}
\DoxyCodeLine{1022   \textcolor{keywordtype}{bool} MatchAndExplain(\textcolor{keyword}{const} internal::StringView\& s,}
\DoxyCodeLine{1023                        MatchResultListener* listener)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{1024     \textcolor{comment}{// This should fail to compile if StringView is used with wide}}
\DoxyCodeLine{1025     \textcolor{comment}{// strings.}}
\DoxyCodeLine{1026     \textcolor{keyword}{const} StringType\& str = std::string(s);}
\DoxyCodeLine{1027     \textcolor{keywordflow}{return} MatchAndExplain(str, listener);}
\DoxyCodeLine{1028   \}}
\DoxyCodeLine{1029 \textcolor{preprocessor}{\#endif  }\textcolor{comment}{// GTEST\_INTERNAL\_HAS\_STRING\_VIEW}}
\DoxyCodeLine{1030 }
\DoxyCodeLine{1031   \textcolor{comment}{// Accepts pointer types, particularly:}}
\DoxyCodeLine{1032   \textcolor{comment}{//   const char*}}
\DoxyCodeLine{1033   \textcolor{comment}{//   char*}}
\DoxyCodeLine{1034   \textcolor{comment}{//   const wchar\_t*}}
\DoxyCodeLine{1035   \textcolor{comment}{//   wchar\_t*}}
\DoxyCodeLine{1036   \textcolor{keyword}{template} <\textcolor{keyword}{typename} CharType>}
\DoxyCodeLine{1037   \textcolor{keywordtype}{bool} MatchAndExplain(CharType* s, MatchResultListener* listener)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{1038     \textcolor{keywordflow}{return} s != \textcolor{keyword}{nullptr} \&\& MatchAndExplain(StringType(s), listener);}
\DoxyCodeLine{1039   \}}
\DoxyCodeLine{1040 }
\DoxyCodeLine{1041   \textcolor{comment}{// Matches anything that can convert to StringType.}}
\DoxyCodeLine{1042   \textcolor{comment}{//}}
\DoxyCodeLine{1043   \textcolor{comment}{// This is a template, not just a plain function with const StringType\&,}}
\DoxyCodeLine{1044   \textcolor{comment}{// because StringView has some interfering non-\/explicit constructors.}}
\DoxyCodeLine{1045   \textcolor{keyword}{template} <\textcolor{keyword}{typename} MatcheeStringType>}
\DoxyCodeLine{1046   \textcolor{keywordtype}{bool} MatchAndExplain(\textcolor{keyword}{const} MatcheeStringType\& s,}
\DoxyCodeLine{1047                        MatchResultListener* \textcolor{comment}{/* listener */})\textcolor{keyword}{ const }\{}
\DoxyCodeLine{1048     \textcolor{keyword}{const} StringType\& s2(s);}
\DoxyCodeLine{1049     \textcolor{keywordflow}{return} s2.length() >= prefix\_.length() \&\&}
\DoxyCodeLine{1050            s2.substr(0, prefix\_.length()) == prefix\_;}
\DoxyCodeLine{1051   \}}
\DoxyCodeLine{1052 }
\DoxyCodeLine{1053   \textcolor{keywordtype}{void} DescribeTo(::std::ostream* os)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{1054     *os << \textcolor{stringliteral}{"{}starts with "{}};}
\DoxyCodeLine{1055     UniversalPrint(prefix\_, os);}
\DoxyCodeLine{1056   \}}
\DoxyCodeLine{1057 }
\DoxyCodeLine{1058   \textcolor{keywordtype}{void} DescribeNegationTo(::std::ostream* os)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{1059     *os << \textcolor{stringliteral}{"{}doesn't start with "{}};}
\DoxyCodeLine{1060     UniversalPrint(prefix\_, os);}
\DoxyCodeLine{1061   \}}
\DoxyCodeLine{1062 }
\DoxyCodeLine{1063  \textcolor{keyword}{private}:}
\DoxyCodeLine{1064   \textcolor{keyword}{const} StringType prefix\_;}
\DoxyCodeLine{1065 \};}
\DoxyCodeLine{1066 }
\DoxyCodeLine{1067 \textcolor{comment}{// Implements the polymorphic EndsWith(substring) matcher, which}}
\DoxyCodeLine{1068 \textcolor{comment}{// can be used as a Matcher<T> as long as T can be converted to a}}
\DoxyCodeLine{1069 \textcolor{comment}{// string.}}
\DoxyCodeLine{1070 \textcolor{keyword}{template} <\textcolor{keyword}{typename} StringType>}
\DoxyCodeLine{1071 \textcolor{keyword}{class }EndsWithMatcher \{}
\DoxyCodeLine{1072  \textcolor{keyword}{public}:}
\DoxyCodeLine{1073   \textcolor{keyword}{explicit} EndsWithMatcher(\textcolor{keyword}{const} StringType\& suffix) : suffix\_(suffix) \{\}}
\DoxyCodeLine{1074 }
\DoxyCodeLine{1075 \textcolor{preprocessor}{\#if GTEST\_INTERNAL\_HAS\_STRING\_VIEW}}
\DoxyCodeLine{1076   \textcolor{keywordtype}{bool} MatchAndExplain(\textcolor{keyword}{const} internal::StringView\& s,}
\DoxyCodeLine{1077                        MatchResultListener* listener)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{1078     \textcolor{comment}{// This should fail to compile if StringView is used with wide}}
\DoxyCodeLine{1079     \textcolor{comment}{// strings.}}
\DoxyCodeLine{1080     \textcolor{keyword}{const} StringType\& str = std::string(s);}
\DoxyCodeLine{1081     \textcolor{keywordflow}{return} MatchAndExplain(str, listener);}
\DoxyCodeLine{1082   \}}
\DoxyCodeLine{1083 \textcolor{preprocessor}{\#endif  }\textcolor{comment}{// GTEST\_INTERNAL\_HAS\_STRING\_VIEW}}
\DoxyCodeLine{1084 }
\DoxyCodeLine{1085   \textcolor{comment}{// Accepts pointer types, particularly:}}
\DoxyCodeLine{1086   \textcolor{comment}{//   const char*}}
\DoxyCodeLine{1087   \textcolor{comment}{//   char*}}
\DoxyCodeLine{1088   \textcolor{comment}{//   const wchar\_t*}}
\DoxyCodeLine{1089   \textcolor{comment}{//   wchar\_t*}}
\DoxyCodeLine{1090   \textcolor{keyword}{template} <\textcolor{keyword}{typename} CharType>}
\DoxyCodeLine{1091   \textcolor{keywordtype}{bool} MatchAndExplain(CharType* s, MatchResultListener* listener)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{1092     \textcolor{keywordflow}{return} s != \textcolor{keyword}{nullptr} \&\& MatchAndExplain(StringType(s), listener);}
\DoxyCodeLine{1093   \}}
\DoxyCodeLine{1094 }
\DoxyCodeLine{1095   \textcolor{comment}{// Matches anything that can convert to StringType.}}
\DoxyCodeLine{1096   \textcolor{comment}{//}}
\DoxyCodeLine{1097   \textcolor{comment}{// This is a template, not just a plain function with const StringType\&,}}
\DoxyCodeLine{1098   \textcolor{comment}{// because StringView has some interfering non-\/explicit constructors.}}
\DoxyCodeLine{1099   \textcolor{keyword}{template} <\textcolor{keyword}{typename} MatcheeStringType>}
\DoxyCodeLine{1100   \textcolor{keywordtype}{bool} MatchAndExplain(\textcolor{keyword}{const} MatcheeStringType\& s,}
\DoxyCodeLine{1101                        MatchResultListener* \textcolor{comment}{/* listener */})\textcolor{keyword}{ const }\{}
\DoxyCodeLine{1102     \textcolor{keyword}{const} StringType\& s2(s);}
\DoxyCodeLine{1103     \textcolor{keywordflow}{return} s2.length() >= suffix\_.length() \&\&}
\DoxyCodeLine{1104            s2.substr(s2.length() -\/ suffix\_.length()) == suffix\_;}
\DoxyCodeLine{1105   \}}
\DoxyCodeLine{1106 }
\DoxyCodeLine{1107   \textcolor{keywordtype}{void} DescribeTo(::std::ostream* os)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{1108     *os << \textcolor{stringliteral}{"{}ends with "{}};}
\DoxyCodeLine{1109     UniversalPrint(suffix\_, os);}
\DoxyCodeLine{1110   \}}
\DoxyCodeLine{1111 }
\DoxyCodeLine{1112   \textcolor{keywordtype}{void} DescribeNegationTo(::std::ostream* os)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{1113     *os << \textcolor{stringliteral}{"{}doesn't end with "{}};}
\DoxyCodeLine{1114     UniversalPrint(suffix\_, os);}
\DoxyCodeLine{1115   \}}
\DoxyCodeLine{1116 }
\DoxyCodeLine{1117  \textcolor{keyword}{private}:}
\DoxyCodeLine{1118   \textcolor{keyword}{const} StringType suffix\_;}
\DoxyCodeLine{1119 \};}
\DoxyCodeLine{1120 }
\DoxyCodeLine{1121 \textcolor{comment}{// Implements the polymorphic WhenBase64Unescaped(matcher) matcher, which can be}}
\DoxyCodeLine{1122 \textcolor{comment}{// used as a Matcher<T> as long as T can be converted to a string.}}
\DoxyCodeLine{1123 \textcolor{keyword}{class }WhenBase64UnescapedMatcher \{}
\DoxyCodeLine{1124  \textcolor{keyword}{public}:}
\DoxyCodeLine{1125   \textcolor{keyword}{using }is\_gtest\_matcher = void;}
\DoxyCodeLine{1126 }
\DoxyCodeLine{1127   \textcolor{keyword}{explicit} WhenBase64UnescapedMatcher(}
\DoxyCodeLine{1128       \textcolor{keyword}{const} Matcher<const std::string\&>\& internal\_matcher)}
\DoxyCodeLine{1129       : internal\_matcher\_(internal\_matcher) \{\}}
\DoxyCodeLine{1130 }
\DoxyCodeLine{1131   \textcolor{comment}{// Matches anything that can convert to std::string.}}
\DoxyCodeLine{1132   \textcolor{keyword}{template} <\textcolor{keyword}{typename} MatcheeStringType>}
\DoxyCodeLine{1133   \textcolor{keywordtype}{bool} MatchAndExplain(\textcolor{keyword}{const} MatcheeStringType\& s,}
\DoxyCodeLine{1134                        MatchResultListener* listener)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{1135     \textcolor{keyword}{const} std::string s2(s);  \textcolor{comment}{// NOLINT (needed for working with string\_view).}}
\DoxyCodeLine{1136     std::string unescaped;}
\DoxyCodeLine{1137     \textcolor{keywordflow}{if} (!internal::Base64Unescape(s2, \&unescaped)) \{}
\DoxyCodeLine{1138       \textcolor{keywordflow}{if} (listener != \textcolor{keyword}{nullptr}) \{}
\DoxyCodeLine{1139         *listener << \textcolor{stringliteral}{"{}is not a valid base64 escaped string"{}};}
\DoxyCodeLine{1140       \}}
\DoxyCodeLine{1141       \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{1142     \}}
\DoxyCodeLine{1143     \textcolor{keywordflow}{return} MatchPrintAndExplain(unescaped, internal\_matcher\_, listener);}
\DoxyCodeLine{1144   \}}
\DoxyCodeLine{1145 }
\DoxyCodeLine{1146   \textcolor{keywordtype}{void} DescribeTo(::std::ostream* os)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{1147     *os << \textcolor{stringliteral}{"{}matches after Base64Unescape "{}};}
\DoxyCodeLine{1148     internal\_matcher\_.DescribeTo(os);}
\DoxyCodeLine{1149   \}}
\DoxyCodeLine{1150 }
\DoxyCodeLine{1151   \textcolor{keywordtype}{void} DescribeNegationTo(::std::ostream* os)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{1152     *os << \textcolor{stringliteral}{"{}does not match after Base64Unescape "{}};}
\DoxyCodeLine{1153     internal\_matcher\_.DescribeTo(os);}
\DoxyCodeLine{1154   \}}
\DoxyCodeLine{1155 }
\DoxyCodeLine{1156  \textcolor{keyword}{private}:}
\DoxyCodeLine{1157   \textcolor{keyword}{const} Matcher<const std::string\&> internal\_matcher\_;}
\DoxyCodeLine{1158 \};}
\DoxyCodeLine{1159 }
\DoxyCodeLine{1160 \textcolor{comment}{// Implements a matcher that compares the two fields of a 2-\/tuple}}
\DoxyCodeLine{1161 \textcolor{comment}{// using one of the ==, <=, <, etc, operators.  The two fields being}}
\DoxyCodeLine{1162 \textcolor{comment}{// compared don't have to have the same type.}}
\DoxyCodeLine{1163 \textcolor{comment}{//}}
\DoxyCodeLine{1164 \textcolor{comment}{// The matcher defined here is polymorphic (for example, Eq() can be}}
\DoxyCodeLine{1165 \textcolor{comment}{// used to match a std::tuple<int, short>, a std::tuple<const long\&, double>,}}
\DoxyCodeLine{1166 \textcolor{comment}{// etc).  Therefore we use a template type conversion operator in the}}
\DoxyCodeLine{1167 \textcolor{comment}{// implementation.}}
\DoxyCodeLine{1168 \textcolor{keyword}{template} <\textcolor{keyword}{typename} D, \textcolor{keyword}{typename} Op>}
\DoxyCodeLine{1169 \textcolor{keyword}{class }PairMatchBase \{}
\DoxyCodeLine{1170  \textcolor{keyword}{public}:}
\DoxyCodeLine{1171   \textcolor{keyword}{template} <\textcolor{keyword}{typename} T1, \textcolor{keyword}{typename} T2>}
\DoxyCodeLine{1172   \textcolor{keyword}{operator} Matcher<::std::tuple<T1, T2>>() \textcolor{keyword}{const} \{}
\DoxyCodeLine{1173     \textcolor{keywordflow}{return} Matcher<::std::tuple<T1, T2>>(\textcolor{keyword}{new} Impl<const ::std::tuple<T1, T2>\&>);}
\DoxyCodeLine{1174   \}}
\DoxyCodeLine{1175   \textcolor{keyword}{template} <\textcolor{keyword}{typename} T1, \textcolor{keyword}{typename} T2>}
\DoxyCodeLine{1176   \textcolor{keyword}{operator} Matcher<const ::std::tuple<T1, T2>\&>() \textcolor{keyword}{const} \{}
\DoxyCodeLine{1177     \textcolor{keywordflow}{return} MakeMatcher(\textcolor{keyword}{new} Impl<const ::std::tuple<T1, T2>\&>);}
\DoxyCodeLine{1178   \}}
\DoxyCodeLine{1179 }
\DoxyCodeLine{1180  \textcolor{keyword}{private}:}
\DoxyCodeLine{1181   static ::std::ostream\& GetDesc(::std::ostream\& os) \{  \textcolor{comment}{// NOLINT}}
\DoxyCodeLine{1182     \textcolor{keywordflow}{return} os << D::Desc();}
\DoxyCodeLine{1183   \}}
\DoxyCodeLine{1184 }
\DoxyCodeLine{1185   \textcolor{keyword}{template} <\textcolor{keyword}{typename} Tuple>}
\DoxyCodeLine{1186   \textcolor{keyword}{class }Impl : \textcolor{keyword}{public} MatcherInterface<Tuple> \{}
\DoxyCodeLine{1187    \textcolor{keyword}{public}:}
\DoxyCodeLine{1188     \textcolor{keywordtype}{bool} MatchAndExplain(Tuple args,}
\DoxyCodeLine{1189                          MatchResultListener* \textcolor{comment}{/* listener */})\textcolor{keyword}{ const override }\{}
\DoxyCodeLine{1190       \textcolor{keywordflow}{return} Op()(::std::get<0>(args), ::std::get<1>(args));}
\DoxyCodeLine{1191     \}}
\DoxyCodeLine{1192     \textcolor{keywordtype}{void} DescribeTo(::std::ostream* os)\textcolor{keyword}{ const override }\{}
\DoxyCodeLine{1193       *os << \textcolor{stringliteral}{"{}are "{}} << GetDesc;}
\DoxyCodeLine{1194     \}}
\DoxyCodeLine{1195     \textcolor{keywordtype}{void} DescribeNegationTo(::std::ostream* os)\textcolor{keyword}{ const override }\{}
\DoxyCodeLine{1196       *os << \textcolor{stringliteral}{"{}aren't "{}} << GetDesc;}
\DoxyCodeLine{1197     \}}
\DoxyCodeLine{1198   \};}
\DoxyCodeLine{1199 \};}
\DoxyCodeLine{1200 }
\DoxyCodeLine{1201 \textcolor{keyword}{class }Eq2Matcher : \textcolor{keyword}{public} PairMatchBase<Eq2Matcher, AnyEq> \{}
\DoxyCodeLine{1202  \textcolor{keyword}{public}:}
\DoxyCodeLine{1203   \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{char}* Desc() \{ \textcolor{keywordflow}{return} \textcolor{stringliteral}{"{}an equal pair"{}}; \}}
\DoxyCodeLine{1204 \};}
\DoxyCodeLine{1205 \textcolor{keyword}{class }Ne2Matcher : \textcolor{keyword}{public} PairMatchBase<Ne2Matcher, AnyNe> \{}
\DoxyCodeLine{1206  \textcolor{keyword}{public}:}
\DoxyCodeLine{1207   \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{char}* Desc() \{ \textcolor{keywordflow}{return} \textcolor{stringliteral}{"{}an unequal pair"{}}; \}}
\DoxyCodeLine{1208 \};}
\DoxyCodeLine{1209 \textcolor{keyword}{class }Lt2Matcher : \textcolor{keyword}{public} PairMatchBase<Lt2Matcher, AnyLt> \{}
\DoxyCodeLine{1210  \textcolor{keyword}{public}:}
\DoxyCodeLine{1211   \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{char}* Desc() \{ \textcolor{keywordflow}{return} \textcolor{stringliteral}{"{}a pair where the first < the second"{}}; \}}
\DoxyCodeLine{1212 \};}
\DoxyCodeLine{1213 \textcolor{keyword}{class }Gt2Matcher : \textcolor{keyword}{public} PairMatchBase<Gt2Matcher, AnyGt> \{}
\DoxyCodeLine{1214  \textcolor{keyword}{public}:}
\DoxyCodeLine{1215   \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{char}* Desc() \{ \textcolor{keywordflow}{return} \textcolor{stringliteral}{"{}a pair where the first > the second"{}}; \}}
\DoxyCodeLine{1216 \};}
\DoxyCodeLine{1217 \textcolor{keyword}{class }Le2Matcher : \textcolor{keyword}{public} PairMatchBase<Le2Matcher, AnyLe> \{}
\DoxyCodeLine{1218  \textcolor{keyword}{public}:}
\DoxyCodeLine{1219   \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{char}* Desc() \{ \textcolor{keywordflow}{return} \textcolor{stringliteral}{"{}a pair where the first <= the second"{}}; \}}
\DoxyCodeLine{1220 \};}
\DoxyCodeLine{1221 \textcolor{keyword}{class }Ge2Matcher : \textcolor{keyword}{public} PairMatchBase<Ge2Matcher, AnyGe> \{}
\DoxyCodeLine{1222  \textcolor{keyword}{public}:}
\DoxyCodeLine{1223   \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{char}* Desc() \{ \textcolor{keywordflow}{return} \textcolor{stringliteral}{"{}a pair where the first >= the second"{}}; \}}
\DoxyCodeLine{1224 \};}
\DoxyCodeLine{1225 }
\DoxyCodeLine{1226 \textcolor{comment}{// Implements the Not(...) matcher for a particular argument type T.}}
\DoxyCodeLine{1227 \textcolor{comment}{// We do not nest it inside the NotMatcher class template, as that}}
\DoxyCodeLine{1228 \textcolor{comment}{// will prevent different instantiations of NotMatcher from sharing}}
\DoxyCodeLine{1229 \textcolor{comment}{// the same NotMatcherImpl<T> class.}}
\DoxyCodeLine{1230 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{1231 \textcolor{keyword}{class }NotMatcherImpl : \textcolor{keyword}{public} MatcherInterface<const T\&> \{}
\DoxyCodeLine{1232  \textcolor{keyword}{public}:}
\DoxyCodeLine{1233   \textcolor{keyword}{explicit} NotMatcherImpl(\textcolor{keyword}{const} Matcher<T>\& matcher) : matcher\_(matcher) \{\}}
\DoxyCodeLine{1234 }
\DoxyCodeLine{1235   \textcolor{keywordtype}{bool} MatchAndExplain(\textcolor{keyword}{const} T\& x,}
\DoxyCodeLine{1236                        MatchResultListener* listener)\textcolor{keyword}{ const override }\{}
\DoxyCodeLine{1237     \textcolor{keywordflow}{return} !matcher\_.MatchAndExplain(x, listener);}
\DoxyCodeLine{1238   \}}
\DoxyCodeLine{1239 }
\DoxyCodeLine{1240   \textcolor{keywordtype}{void} DescribeTo(::std::ostream* os)\textcolor{keyword}{ const override }\{}
\DoxyCodeLine{1241     matcher\_.DescribeNegationTo(os);}
\DoxyCodeLine{1242   \}}
\DoxyCodeLine{1243 }
\DoxyCodeLine{1244   \textcolor{keywordtype}{void} DescribeNegationTo(::std::ostream* os)\textcolor{keyword}{ const override }\{}
\DoxyCodeLine{1245     matcher\_.DescribeTo(os);}
\DoxyCodeLine{1246   \}}
\DoxyCodeLine{1247 }
\DoxyCodeLine{1248  \textcolor{keyword}{private}:}
\DoxyCodeLine{1249   \textcolor{keyword}{const} Matcher<T> matcher\_;}
\DoxyCodeLine{1250 \};}
\DoxyCodeLine{1251 }
\DoxyCodeLine{1252 \textcolor{comment}{// Implements the Not(m) matcher, which matches a value that doesn't}}
\DoxyCodeLine{1253 \textcolor{comment}{// match matcher m.}}
\DoxyCodeLine{1254 \textcolor{keyword}{template} <\textcolor{keyword}{typename} InnerMatcher>}
\DoxyCodeLine{1255 \textcolor{keyword}{class }NotMatcher \{}
\DoxyCodeLine{1256  \textcolor{keyword}{public}:}
\DoxyCodeLine{1257   \textcolor{keyword}{explicit} NotMatcher(InnerMatcher matcher) : matcher\_(matcher) \{\}}
\DoxyCodeLine{1258 }
\DoxyCodeLine{1259   \textcolor{comment}{// This template type conversion operator allows Not(m) to be used}}
\DoxyCodeLine{1260   \textcolor{comment}{// to match any type m can match.}}
\DoxyCodeLine{1261   \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{1262   \textcolor{keyword}{operator} Matcher<T>()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{1263     \textcolor{keywordflow}{return} Matcher<T>(\textcolor{keyword}{new} NotMatcherImpl<T>(SafeMatcherCast<T>(matcher\_)));}
\DoxyCodeLine{1264   \}}
\DoxyCodeLine{1265 }
\DoxyCodeLine{1266  \textcolor{keyword}{private}:}
\DoxyCodeLine{1267   InnerMatcher matcher\_;}
\DoxyCodeLine{1268 \};}
\DoxyCodeLine{1269 }
\DoxyCodeLine{1270 \textcolor{comment}{// Implements the AllOf(m1, m2) matcher for a particular argument type}}
\DoxyCodeLine{1271 \textcolor{comment}{// T. We do not nest it inside the BothOfMatcher class template, as}}
\DoxyCodeLine{1272 \textcolor{comment}{// that will prevent different instantiations of BothOfMatcher from}}
\DoxyCodeLine{1273 \textcolor{comment}{// sharing the same BothOfMatcherImpl<T> class.}}
\DoxyCodeLine{1274 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{1275 \textcolor{keyword}{class }AllOfMatcherImpl : \textcolor{keyword}{public} MatcherInterface<const T\&> \{}
\DoxyCodeLine{1276  \textcolor{keyword}{public}:}
\DoxyCodeLine{1277   \textcolor{keyword}{explicit} AllOfMatcherImpl(std::vector<Matcher<T>> matchers)}
\DoxyCodeLine{1278       : matchers\_(std::move(matchers)) \{\}}
\DoxyCodeLine{1279 }
\DoxyCodeLine{1280   \textcolor{keywordtype}{void} DescribeTo(::std::ostream* os)\textcolor{keyword}{ const override }\{}
\DoxyCodeLine{1281     *os << \textcolor{stringliteral}{"{}("{}};}
\DoxyCodeLine{1282     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{size\_t} i = 0; i < matchers\_.size(); ++i) \{}
\DoxyCodeLine{1283       \textcolor{keywordflow}{if} (i != 0) *os << \textcolor{stringliteral}{"{}) and ("{}};}
\DoxyCodeLine{1284       matchers\_[i].DescribeTo(os);}
\DoxyCodeLine{1285     \}}
\DoxyCodeLine{1286     *os << \textcolor{stringliteral}{"{})"{}};}
\DoxyCodeLine{1287   \}}
\DoxyCodeLine{1288 }
\DoxyCodeLine{1289   \textcolor{keywordtype}{void} DescribeNegationTo(::std::ostream* os)\textcolor{keyword}{ const override }\{}
\DoxyCodeLine{1290     *os << \textcolor{stringliteral}{"{}("{}};}
\DoxyCodeLine{1291     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{size\_t} i = 0; i < matchers\_.size(); ++i) \{}
\DoxyCodeLine{1292       \textcolor{keywordflow}{if} (i != 0) *os << \textcolor{stringliteral}{"{}) or ("{}};}
\DoxyCodeLine{1293       matchers\_[i].DescribeNegationTo(os);}
\DoxyCodeLine{1294     \}}
\DoxyCodeLine{1295     *os << \textcolor{stringliteral}{"{})"{}};}
\DoxyCodeLine{1296   \}}
\DoxyCodeLine{1297 }
\DoxyCodeLine{1298   \textcolor{keywordtype}{bool} MatchAndExplain(\textcolor{keyword}{const} T\& x,}
\DoxyCodeLine{1299                        MatchResultListener* listener)\textcolor{keyword}{ const override }\{}
\DoxyCodeLine{1300     \textcolor{comment}{// If either matcher1\_ or matcher2\_ doesn't match x, we only need}}
\DoxyCodeLine{1301     \textcolor{comment}{// to explain why one of them fails.}}
\DoxyCodeLine{1302     std::string all\_match\_result;}
\DoxyCodeLine{1303 }
\DoxyCodeLine{1304     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{size\_t} i = 0; i < matchers\_.size(); ++i) \{}
\DoxyCodeLine{1305       StringMatchResultListener slistener;}
\DoxyCodeLine{1306       \textcolor{keywordflow}{if} (matchers\_[i].MatchAndExplain(x, \&slistener)) \{}
\DoxyCodeLine{1307         \textcolor{keywordflow}{if} (all\_match\_result.empty()) \{}
\DoxyCodeLine{1308           all\_match\_result = slistener.str();}
\DoxyCodeLine{1309         \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{1310           std::string result = slistener.str();}
\DoxyCodeLine{1311           \textcolor{keywordflow}{if} (!result.empty()) \{}
\DoxyCodeLine{1312             all\_match\_result += \textcolor{stringliteral}{"{}, and "{}};}
\DoxyCodeLine{1313             all\_match\_result += result;}
\DoxyCodeLine{1314           \}}
\DoxyCodeLine{1315         \}}
\DoxyCodeLine{1316       \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{1317         *listener << slistener.str();}
\DoxyCodeLine{1318         \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{1319       \}}
\DoxyCodeLine{1320     \}}
\DoxyCodeLine{1321 }
\DoxyCodeLine{1322     \textcolor{comment}{// Otherwise we need to explain why *both* of them match.}}
\DoxyCodeLine{1323     *listener << all\_match\_result;}
\DoxyCodeLine{1324     \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{1325   \}}
\DoxyCodeLine{1326 }
\DoxyCodeLine{1327  \textcolor{keyword}{private}:}
\DoxyCodeLine{1328   \textcolor{keyword}{const} std::vector<Matcher<T>> matchers\_;}
\DoxyCodeLine{1329 \};}
\DoxyCodeLine{1330 }
\DoxyCodeLine{1331 \textcolor{comment}{// VariadicMatcher is used for the variadic implementation of}}
\DoxyCodeLine{1332 \textcolor{comment}{// AllOf(m\_1, m\_2, ...) and AnyOf(m\_1, m\_2, ...).}}
\DoxyCodeLine{1333 \textcolor{comment}{// CombiningMatcher<T> is used to recursively combine the provided matchers}}
\DoxyCodeLine{1334 \textcolor{comment}{// (of type Args...).}}
\DoxyCodeLine{1335 \textcolor{keyword}{template} <\textcolor{keyword}{template} <\textcolor{keyword}{typename} T> \textcolor{keyword}{class }CombiningMatcher, \textcolor{keyword}{typename}... Args>}
\DoxyCodeLine{1336 \textcolor{keyword}{class }VariadicMatcher \{}
\DoxyCodeLine{1337  \textcolor{keyword}{public}:}
\DoxyCodeLine{1338   VariadicMatcher(\textcolor{keyword}{const} Args\&... matchers)  \textcolor{comment}{// NOLINT}}
\DoxyCodeLine{1339       : matchers\_(matchers...) \{}
\DoxyCodeLine{1340     \textcolor{keyword}{static\_assert}(\textcolor{keyword}{sizeof}...(Args) > 0, \textcolor{stringliteral}{"{}Must have at least one matcher."{}});}
\DoxyCodeLine{1341   \}}
\DoxyCodeLine{1342 }
\DoxyCodeLine{1343   VariadicMatcher(\textcolor{keyword}{const} VariadicMatcher\&) = \textcolor{keywordflow}{default};}
\DoxyCodeLine{1344   VariadicMatcher\& operator=(\textcolor{keyword}{const} VariadicMatcher\&) = \textcolor{keyword}{delete};}
\DoxyCodeLine{1345 }
\DoxyCodeLine{1346   \textcolor{comment}{// This template type conversion operator allows an}}
\DoxyCodeLine{1347   \textcolor{comment}{// VariadicMatcher<Matcher1, Matcher2...> object to match any type that}}
\DoxyCodeLine{1348   \textcolor{comment}{// all of the provided matchers (Matcher1, Matcher2, ...) can match.}}
\DoxyCodeLine{1349   \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{1350   \textcolor{keyword}{operator} Matcher<T>()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{1351     std::vector<Matcher<T>> values;}
\DoxyCodeLine{1352     CreateVariadicMatcher<T>(\&values, std::integral\_constant<size\_t, 0>());}
\DoxyCodeLine{1353     \textcolor{keywordflow}{return} Matcher<T>(\textcolor{keyword}{new} CombiningMatcher<T>(std::move(values)));}
\DoxyCodeLine{1354   \}}
\DoxyCodeLine{1355 }
\DoxyCodeLine{1356  \textcolor{keyword}{private}:}
\DoxyCodeLine{1357   \textcolor{keyword}{template} <\textcolor{keyword}{typename} T, \textcolor{keywordtype}{size\_t} I>}
\DoxyCodeLine{1358   \textcolor{keywordtype}{void} CreateVariadicMatcher(std::vector<Matcher<T>>* values,}
\DoxyCodeLine{1359                              std::integral\_constant<size\_t, I>)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{1360     values-\/>push\_back(SafeMatcherCast<T>(std::get<I>(matchers\_)));}
\DoxyCodeLine{1361     CreateVariadicMatcher<T>(values, std::integral\_constant<size\_t, I + 1>());}
\DoxyCodeLine{1362   \}}
\DoxyCodeLine{1363 }
\DoxyCodeLine{1364   \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{1365   \textcolor{keywordtype}{void} CreateVariadicMatcher(}
\DoxyCodeLine{1366       std::vector<Matcher<T>>*,}
\DoxyCodeLine{1367       std::integral\_constant<\textcolor{keywordtype}{size\_t}, \textcolor{keyword}{sizeof}...(Args)>)\textcolor{keyword}{ const }\{\}}
\DoxyCodeLine{1368 }
\DoxyCodeLine{1369   std::tuple<Args...> matchers\_;}
\DoxyCodeLine{1370 \};}
\DoxyCodeLine{1371 }
\DoxyCodeLine{1372 \textcolor{keyword}{template} <\textcolor{keyword}{typename}... Args>}
\DoxyCodeLine{1373 \textcolor{keyword}{using }AllOfMatcher = VariadicMatcher<AllOfMatcherImpl, Args...>;}
\DoxyCodeLine{1374 }
\DoxyCodeLine{1375 \textcolor{comment}{// Implements the AnyOf(m1, m2) matcher for a particular argument type}}
\DoxyCodeLine{1376 \textcolor{comment}{// T.  We do not nest it inside the AnyOfMatcher class template, as}}
\DoxyCodeLine{1377 \textcolor{comment}{// that will prevent different instantiations of AnyOfMatcher from}}
\DoxyCodeLine{1378 \textcolor{comment}{// sharing the same EitherOfMatcherImpl<T> class.}}
\DoxyCodeLine{1379 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{1380 \textcolor{keyword}{class }AnyOfMatcherImpl : \textcolor{keyword}{public} MatcherInterface<const T\&> \{}
\DoxyCodeLine{1381  \textcolor{keyword}{public}:}
\DoxyCodeLine{1382   \textcolor{keyword}{explicit} AnyOfMatcherImpl(std::vector<Matcher<T>> matchers)}
\DoxyCodeLine{1383       : matchers\_(std::move(matchers)) \{\}}
\DoxyCodeLine{1384 }
\DoxyCodeLine{1385   \textcolor{keywordtype}{void} DescribeTo(::std::ostream* os)\textcolor{keyword}{ const override }\{}
\DoxyCodeLine{1386     *os << \textcolor{stringliteral}{"{}("{}};}
\DoxyCodeLine{1387     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{size\_t} i = 0; i < matchers\_.size(); ++i) \{}
\DoxyCodeLine{1388       \textcolor{keywordflow}{if} (i != 0) *os << \textcolor{stringliteral}{"{}) or ("{}};}
\DoxyCodeLine{1389       matchers\_[i].DescribeTo(os);}
\DoxyCodeLine{1390     \}}
\DoxyCodeLine{1391     *os << \textcolor{stringliteral}{"{})"{}};}
\DoxyCodeLine{1392   \}}
\DoxyCodeLine{1393 }
\DoxyCodeLine{1394   \textcolor{keywordtype}{void} DescribeNegationTo(::std::ostream* os)\textcolor{keyword}{ const override }\{}
\DoxyCodeLine{1395     *os << \textcolor{stringliteral}{"{}("{}};}
\DoxyCodeLine{1396     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{size\_t} i = 0; i < matchers\_.size(); ++i) \{}
\DoxyCodeLine{1397       \textcolor{keywordflow}{if} (i != 0) *os << \textcolor{stringliteral}{"{}) and ("{}};}
\DoxyCodeLine{1398       matchers\_[i].DescribeNegationTo(os);}
\DoxyCodeLine{1399     \}}
\DoxyCodeLine{1400     *os << \textcolor{stringliteral}{"{})"{}};}
\DoxyCodeLine{1401   \}}
\DoxyCodeLine{1402 }
\DoxyCodeLine{1403   \textcolor{keywordtype}{bool} MatchAndExplain(\textcolor{keyword}{const} T\& x,}
\DoxyCodeLine{1404                        MatchResultListener* listener)\textcolor{keyword}{ const override }\{}
\DoxyCodeLine{1405     std::string no\_match\_result;}
\DoxyCodeLine{1406 }
\DoxyCodeLine{1407     \textcolor{comment}{// If either matcher1\_ or matcher2\_ matches x, we just need to}}
\DoxyCodeLine{1408     \textcolor{comment}{// explain why *one* of them matches.}}
\DoxyCodeLine{1409     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{size\_t} i = 0; i < matchers\_.size(); ++i) \{}
\DoxyCodeLine{1410       StringMatchResultListener slistener;}
\DoxyCodeLine{1411       \textcolor{keywordflow}{if} (matchers\_[i].MatchAndExplain(x, \&slistener)) \{}
\DoxyCodeLine{1412         *listener << slistener.str();}
\DoxyCodeLine{1413         \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{1414       \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{1415         \textcolor{keywordflow}{if} (no\_match\_result.empty()) \{}
\DoxyCodeLine{1416           no\_match\_result = slistener.str();}
\DoxyCodeLine{1417         \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{1418           std::string result = slistener.str();}
\DoxyCodeLine{1419           \textcolor{keywordflow}{if} (!result.empty()) \{}
\DoxyCodeLine{1420             no\_match\_result += \textcolor{stringliteral}{"{}, and "{}};}
\DoxyCodeLine{1421             no\_match\_result += result;}
\DoxyCodeLine{1422           \}}
\DoxyCodeLine{1423         \}}
\DoxyCodeLine{1424       \}}
\DoxyCodeLine{1425     \}}
\DoxyCodeLine{1426 }
\DoxyCodeLine{1427     \textcolor{comment}{// Otherwise we need to explain why *both* of them fail.}}
\DoxyCodeLine{1428     *listener << no\_match\_result;}
\DoxyCodeLine{1429     \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{1430   \}}
\DoxyCodeLine{1431 }
\DoxyCodeLine{1432  \textcolor{keyword}{private}:}
\DoxyCodeLine{1433   \textcolor{keyword}{const} std::vector<Matcher<T>> matchers\_;}
\DoxyCodeLine{1434 \};}
\DoxyCodeLine{1435 }
\DoxyCodeLine{1436 \textcolor{comment}{// AnyOfMatcher is used for the variadic implementation of AnyOf(m\_1, m\_2, ...).}}
\DoxyCodeLine{1437 \textcolor{keyword}{template} <\textcolor{keyword}{typename}... Args>}
\DoxyCodeLine{1438 \textcolor{keyword}{using }AnyOfMatcher = VariadicMatcher<AnyOfMatcherImpl, Args...>;}
\DoxyCodeLine{1439 }
\DoxyCodeLine{1440 \textcolor{comment}{// ConditionalMatcher is the implementation of Conditional(cond, m1, m2)}}
\DoxyCodeLine{1441 \textcolor{keyword}{template} <\textcolor{keyword}{typename} MatcherTrue, \textcolor{keyword}{typename} MatcherFalse>}
\DoxyCodeLine{1442 \textcolor{keyword}{class }ConditionalMatcher \{}
\DoxyCodeLine{1443  \textcolor{keyword}{public}:}
\DoxyCodeLine{1444   ConditionalMatcher(\textcolor{keywordtype}{bool} condition, MatcherTrue matcher\_true,}
\DoxyCodeLine{1445                      MatcherFalse matcher\_false)}
\DoxyCodeLine{1446       : condition\_(condition),}
\DoxyCodeLine{1447         matcher\_true\_(std::move(matcher\_true)),}
\DoxyCodeLine{1448         matcher\_false\_(std::move(matcher\_false)) \{\}}
\DoxyCodeLine{1449 }
\DoxyCodeLine{1450   \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{1451   \textcolor{keyword}{operator} Matcher<T>()\textcolor{keyword}{ const }\{  \textcolor{comment}{// NOLINT(runtime/explicit)}}
\DoxyCodeLine{1452     \textcolor{keywordflow}{return} condition\_ ? SafeMatcherCast<T>(matcher\_true\_)}
\DoxyCodeLine{1453                       : SafeMatcherCast<T>(matcher\_false\_);}
\DoxyCodeLine{1454   \}}
\DoxyCodeLine{1455 }
\DoxyCodeLine{1456  \textcolor{keyword}{private}:}
\DoxyCodeLine{1457   \textcolor{keywordtype}{bool} condition\_;}
\DoxyCodeLine{1458   MatcherTrue matcher\_true\_;}
\DoxyCodeLine{1459   MatcherFalse matcher\_false\_;}
\DoxyCodeLine{1460 \};}
\DoxyCodeLine{1461 }
\DoxyCodeLine{1462 \textcolor{comment}{// Wrapper for implementation of Any/AllOfArray().}}
\DoxyCodeLine{1463 \textcolor{keyword}{template} <\textcolor{keyword}{template} <\textcolor{keyword}{class}> \textcolor{keyword}{class }MatcherImpl, \textcolor{keyword}{typename} T>}
\DoxyCodeLine{1464 \textcolor{keyword}{class }SomeOfArrayMatcher \{}
\DoxyCodeLine{1465  \textcolor{keyword}{public}:}
\DoxyCodeLine{1466   \textcolor{comment}{// Constructs the matcher from a sequence of element values or}}
\DoxyCodeLine{1467   \textcolor{comment}{// element matchers.}}
\DoxyCodeLine{1468   \textcolor{keyword}{template} <\textcolor{keyword}{typename} Iter>}
\DoxyCodeLine{1469   SomeOfArrayMatcher(Iter first, Iter last) : matchers\_(first, last) \{\}}
\DoxyCodeLine{1470 }
\DoxyCodeLine{1471   \textcolor{keyword}{template} <\textcolor{keyword}{typename} U>}
\DoxyCodeLine{1472   \textcolor{keyword}{operator} Matcher<U>()\textcolor{keyword}{ const }\{  \textcolor{comment}{// NOLINT}}
\DoxyCodeLine{1473     \textcolor{keyword}{using }RawU = \textcolor{keyword}{typename} std::decay<U>::type;}
\DoxyCodeLine{1474     std::vector<Matcher<RawU>> matchers;}
\DoxyCodeLine{1475     \textcolor{keywordflow}{for} (\textcolor{keyword}{const} \textcolor{keyword}{auto}\& matcher : matchers\_) \{}
\DoxyCodeLine{1476       matchers.push\_back(MatcherCast<RawU>(matcher));}
\DoxyCodeLine{1477     \}}
\DoxyCodeLine{1478     \textcolor{keywordflow}{return} Matcher<U>(\textcolor{keyword}{new} MatcherImpl<RawU>(std::move(matchers)));}
\DoxyCodeLine{1479   \}}
\DoxyCodeLine{1480 }
\DoxyCodeLine{1481  \textcolor{keyword}{private}:}
\DoxyCodeLine{1482   const ::std::vector<T> matchers\_;}
\DoxyCodeLine{1483 \};}
\DoxyCodeLine{1484 }
\DoxyCodeLine{1485 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{1486 \textcolor{keyword}{using }AllOfArrayMatcher = SomeOfArrayMatcher<AllOfMatcherImpl, T>;}
\DoxyCodeLine{1487 }
\DoxyCodeLine{1488 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{1489 \textcolor{keyword}{using }AnyOfArrayMatcher = SomeOfArrayMatcher<AnyOfMatcherImpl, T>;}
\DoxyCodeLine{1490 }
\DoxyCodeLine{1491 \textcolor{comment}{// Used for implementing Truly(pred), which turns a predicate into a}}
\DoxyCodeLine{1492 \textcolor{comment}{// matcher.}}
\DoxyCodeLine{1493 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Predicate>}
\DoxyCodeLine{1494 \textcolor{keyword}{class }TrulyMatcher \{}
\DoxyCodeLine{1495  \textcolor{keyword}{public}:}
\DoxyCodeLine{1496   \textcolor{keyword}{explicit} TrulyMatcher(Predicate pred) : predicate\_(pred) \{\}}
\DoxyCodeLine{1497 }
\DoxyCodeLine{1498   \textcolor{comment}{// This method template allows Truly(pred) to be used as a matcher}}
\DoxyCodeLine{1499   \textcolor{comment}{// for type T where T is the argument type of predicate 'pred'.  The}}
\DoxyCodeLine{1500   \textcolor{comment}{// argument is passed by reference as the predicate may be}}
\DoxyCodeLine{1501   \textcolor{comment}{// interested in the address of the argument.}}
\DoxyCodeLine{1502   \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{1503   \textcolor{keywordtype}{bool} MatchAndExplain(T\& x,  \textcolor{comment}{// NOLINT}}
\DoxyCodeLine{1504                        MatchResultListener* listener)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{1505     \textcolor{comment}{// Without the if-\/statement, MSVC sometimes warns about converting}}
\DoxyCodeLine{1506     \textcolor{comment}{// a value to bool (warning 4800).}}
\DoxyCodeLine{1507     \textcolor{comment}{//}}
\DoxyCodeLine{1508     \textcolor{comment}{// We cannot write 'return !!predicate\_(x);' as that doesn't work}}
\DoxyCodeLine{1509     \textcolor{comment}{// when predicate\_(x) returns a class convertible to bool but}}
\DoxyCodeLine{1510     \textcolor{comment}{// having no operator!().}}
\DoxyCodeLine{1511     \textcolor{keywordflow}{if} (predicate\_(x)) \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{1512     *listener << \textcolor{stringliteral}{"{}didn't satisfy the given predicate"{}};}
\DoxyCodeLine{1513     \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{1514   \}}
\DoxyCodeLine{1515 }
\DoxyCodeLine{1516   \textcolor{keywordtype}{void} DescribeTo(::std::ostream* os)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{1517     *os << \textcolor{stringliteral}{"{}satisfies the given predicate"{}};}
\DoxyCodeLine{1518   \}}
\DoxyCodeLine{1519 }
\DoxyCodeLine{1520   \textcolor{keywordtype}{void} DescribeNegationTo(::std::ostream* os)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{1521     *os << \textcolor{stringliteral}{"{}doesn't satisfy the given predicate"{}};}
\DoxyCodeLine{1522   \}}
\DoxyCodeLine{1523 }
\DoxyCodeLine{1524  \textcolor{keyword}{private}:}
\DoxyCodeLine{1525   Predicate predicate\_;}
\DoxyCodeLine{1526 \};}
\DoxyCodeLine{1527 }
\DoxyCodeLine{1528 \textcolor{comment}{// Used for implementing Matches(matcher), which turns a matcher into}}
\DoxyCodeLine{1529 \textcolor{comment}{// a predicate.}}
\DoxyCodeLine{1530 \textcolor{keyword}{template} <\textcolor{keyword}{typename} M>}
\DoxyCodeLine{1531 \textcolor{keyword}{class }MatcherAsPredicate \{}
\DoxyCodeLine{1532  \textcolor{keyword}{public}:}
\DoxyCodeLine{1533   \textcolor{keyword}{explicit} MatcherAsPredicate(M matcher) : matcher\_(matcher) \{\}}
\DoxyCodeLine{1534 }
\DoxyCodeLine{1535   \textcolor{comment}{// This template operator() allows Matches(m) to be used as a}}
\DoxyCodeLine{1536   \textcolor{comment}{// predicate on type T where m is a matcher on type T.}}
\DoxyCodeLine{1537   \textcolor{comment}{//}}
\DoxyCodeLine{1538   \textcolor{comment}{// The argument x is passed by reference instead of by value, as}}
\DoxyCodeLine{1539   \textcolor{comment}{// some matcher may be interested in its address (e.g. as in}}
\DoxyCodeLine{1540   \textcolor{comment}{// Matches(Ref(n))(x)).}}
\DoxyCodeLine{1541   \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{1542   \textcolor{keywordtype}{bool} operator()(\textcolor{keyword}{const} T\& x)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{1543     \textcolor{comment}{// We let matcher\_ commit to a particular type here instead of}}
\DoxyCodeLine{1544     \textcolor{comment}{// when the MatcherAsPredicate object was constructed.  This}}
\DoxyCodeLine{1545     \textcolor{comment}{// allows us to write Matches(m) where m is a polymorphic matcher}}
\DoxyCodeLine{1546     \textcolor{comment}{// (e.g. Eq(5)).}}
\DoxyCodeLine{1547     \textcolor{comment}{//}}
\DoxyCodeLine{1548     \textcolor{comment}{// If we write Matcher<T>(matcher\_).Matches(x) here, it won't}}
\DoxyCodeLine{1549     \textcolor{comment}{// compile when matcher\_ has type Matcher<const T\&>; if we write}}
\DoxyCodeLine{1550     \textcolor{comment}{// Matcher<const T\&>(matcher\_).Matches(x) here, it won't compile}}
\DoxyCodeLine{1551     \textcolor{comment}{// when matcher\_ has type Matcher<T>; if we just write}}
\DoxyCodeLine{1552     \textcolor{comment}{// matcher\_.Matches(x), it won't compile when matcher\_ is}}
\DoxyCodeLine{1553     \textcolor{comment}{// polymorphic, e.g. Eq(5).}}
\DoxyCodeLine{1554     \textcolor{comment}{//}}
\DoxyCodeLine{1555     \textcolor{comment}{// MatcherCast<const T\&>() is necessary for making the code work}}
\DoxyCodeLine{1556     \textcolor{comment}{// in all of the above situations.}}
\DoxyCodeLine{1557     \textcolor{keywordflow}{return} MatcherCast<const T\&>(matcher\_).Matches(x);}
\DoxyCodeLine{1558   \}}
\DoxyCodeLine{1559 }
\DoxyCodeLine{1560  \textcolor{keyword}{private}:}
\DoxyCodeLine{1561   M matcher\_;}
\DoxyCodeLine{1562 \};}
\DoxyCodeLine{1563 }
\DoxyCodeLine{1564 \textcolor{comment}{// For implementing ASSERT\_THAT() and EXPECT\_THAT().  The template}}
\DoxyCodeLine{1565 \textcolor{comment}{// argument M must be a type that can be converted to a matcher.}}
\DoxyCodeLine{1566 \textcolor{keyword}{template} <\textcolor{keyword}{typename} M>}
\DoxyCodeLine{1567 \textcolor{keyword}{class }PredicateFormatterFromMatcher \{}
\DoxyCodeLine{1568  \textcolor{keyword}{public}:}
\DoxyCodeLine{1569   \textcolor{keyword}{explicit} PredicateFormatterFromMatcher(M m) : matcher\_(std::move(m)) \{\}}
\DoxyCodeLine{1570 }
\DoxyCodeLine{1571   \textcolor{comment}{// This template () operator allows a PredicateFormatterFromMatcher}}
\DoxyCodeLine{1572   \textcolor{comment}{// object to act as a predicate-\/formatter suitable for using with}}
\DoxyCodeLine{1573   \textcolor{comment}{// Google Test's EXPECT\_PRED\_FORMAT1() macro.}}
\DoxyCodeLine{1574   \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{1575   AssertionResult operator()(\textcolor{keyword}{const} \textcolor{keywordtype}{char}* value\_text, \textcolor{keyword}{const} T\& x)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{1576     \textcolor{comment}{// We convert matcher\_ to a Matcher<const T\&> *now* instead of}}
\DoxyCodeLine{1577     \textcolor{comment}{// when the PredicateFormatterFromMatcher object was constructed,}}
\DoxyCodeLine{1578     \textcolor{comment}{// as matcher\_ may be polymorphic (e.g. NotNull()) and we won't}}
\DoxyCodeLine{1579     \textcolor{comment}{// know which type to instantiate it to until we actually see the}}
\DoxyCodeLine{1580     \textcolor{comment}{// type of x here.}}
\DoxyCodeLine{1581     \textcolor{comment}{//}}
\DoxyCodeLine{1582     \textcolor{comment}{// We write SafeMatcherCast<const T\&>(matcher\_) instead of}}
\DoxyCodeLine{1583     \textcolor{comment}{// Matcher<const T\&>(matcher\_), as the latter won't compile when}}
\DoxyCodeLine{1584     \textcolor{comment}{// matcher\_ has type Matcher<T> (e.g. An<int>()).}}
\DoxyCodeLine{1585     \textcolor{comment}{// We don't write MatcherCast<const T\&> either, as that allows}}
\DoxyCodeLine{1586     \textcolor{comment}{// potentially unsafe downcasting of the matcher argument.}}
\DoxyCodeLine{1587     \textcolor{keyword}{const} Matcher<const T\&> matcher = SafeMatcherCast<const T\&>(matcher\_);}
\DoxyCodeLine{1588 }
\DoxyCodeLine{1589     \textcolor{comment}{// The expected path here is that the matcher should match (i.e. that most}}
\DoxyCodeLine{1590     \textcolor{comment}{// tests pass) so optimize for this case.}}
\DoxyCodeLine{1591     \textcolor{keywordflow}{if} (matcher.Matches(x)) \{}
\DoxyCodeLine{1592       \textcolor{keywordflow}{return} AssertionSuccess();}
\DoxyCodeLine{1593     \}}
\DoxyCodeLine{1594 }
\DoxyCodeLine{1595     ::std::stringstream ss;}
\DoxyCodeLine{1596     ss << \textcolor{stringliteral}{"{}Value of: "{}} << value\_text << \textcolor{stringliteral}{"{}\(\backslash\)n"{}}}
\DoxyCodeLine{1597        << \textcolor{stringliteral}{"{}Expected: "{}};}
\DoxyCodeLine{1598     matcher.DescribeTo(\&ss);}
\DoxyCodeLine{1599 }
\DoxyCodeLine{1600     \textcolor{comment}{// Rerun the matcher to "{}PrintAndExplain"{} the failure.}}
\DoxyCodeLine{1601     StringMatchResultListener listener;}
\DoxyCodeLine{1602     \textcolor{keywordflow}{if} (MatchPrintAndExplain(x, matcher, \&listener)) \{}
\DoxyCodeLine{1603       ss << \textcolor{stringliteral}{"{}\(\backslash\)n  The matcher failed on the initial attempt; but passed when "{}}}
\DoxyCodeLine{1604             \textcolor{stringliteral}{"{}rerun to generate the explanation."{}};}
\DoxyCodeLine{1605     \}}
\DoxyCodeLine{1606     ss << \textcolor{stringliteral}{"{}\(\backslash\)n  Actual: "{}} << listener.str();}
\DoxyCodeLine{1607     \textcolor{keywordflow}{return} AssertionFailure() << ss.str();}
\DoxyCodeLine{1608   \}}
\DoxyCodeLine{1609 }
\DoxyCodeLine{1610  \textcolor{keyword}{private}:}
\DoxyCodeLine{1611   \textcolor{keyword}{const} M matcher\_;}
\DoxyCodeLine{1612 \};}
\DoxyCodeLine{1613 }
\DoxyCodeLine{1614 \textcolor{comment}{// A helper function for converting a matcher to a predicate-\/formatter}}
\DoxyCodeLine{1615 \textcolor{comment}{// without the user needing to explicitly write the type.  This is}}
\DoxyCodeLine{1616 \textcolor{comment}{// used for implementing ASSERT\_THAT() and EXPECT\_THAT().}}
\DoxyCodeLine{1617 \textcolor{comment}{// Implementation detail: 'matcher' is received by-\/value to force decaying.}}
\DoxyCodeLine{1618 \textcolor{keyword}{template} <\textcolor{keyword}{typename} M>}
\DoxyCodeLine{1619 \textcolor{keyword}{inline} PredicateFormatterFromMatcher<M> MakePredicateFormatterFromMatcher(}
\DoxyCodeLine{1620     M matcher) \{}
\DoxyCodeLine{1621   \textcolor{keywordflow}{return} PredicateFormatterFromMatcher<M>(std::move(matcher));}
\DoxyCodeLine{1622 \}}
\DoxyCodeLine{1623 }
\DoxyCodeLine{1624 \textcolor{comment}{// Implements the polymorphic IsNan() matcher, which matches any floating type}}
\DoxyCodeLine{1625 \textcolor{comment}{// value that is Nan.}}
\DoxyCodeLine{1626 \textcolor{keyword}{class }IsNanMatcher \{}
\DoxyCodeLine{1627  \textcolor{keyword}{public}:}
\DoxyCodeLine{1628   \textcolor{keyword}{template} <\textcolor{keyword}{typename} FloatType>}
\DoxyCodeLine{1629   \textcolor{keywordtype}{bool} MatchAndExplain(\textcolor{keyword}{const} FloatType\& f,}
\DoxyCodeLine{1630                        MatchResultListener* \textcolor{comment}{/* listener */})\textcolor{keyword}{ const }\{}
\DoxyCodeLine{1631     \textcolor{keywordflow}{return} (::std::isnan)(f);}
\DoxyCodeLine{1632   \}}
\DoxyCodeLine{1633 }
\DoxyCodeLine{1634   \textcolor{keywordtype}{void} DescribeTo(::std::ostream* os)\textcolor{keyword}{ const }\{ *os << \textcolor{stringliteral}{"{}is NaN"{}}; \}}
\DoxyCodeLine{1635   \textcolor{keywordtype}{void} DescribeNegationTo(::std::ostream* os)\textcolor{keyword}{ const }\{ *os << \textcolor{stringliteral}{"{}isn't NaN"{}}; \}}
\DoxyCodeLine{1636 \};}
\DoxyCodeLine{1637 }
\DoxyCodeLine{1638 \textcolor{comment}{// Implements the polymorphic floating point equality matcher, which matches}}
\DoxyCodeLine{1639 \textcolor{comment}{// two float values using ULP-\/based approximation or, optionally, a}}
\DoxyCodeLine{1640 \textcolor{comment}{// user-\/specified epsilon.  The template is meant to be instantiated with}}
\DoxyCodeLine{1641 \textcolor{comment}{// FloatType being either float or double.}}
\DoxyCodeLine{1642 \textcolor{keyword}{template} <\textcolor{keyword}{typename} FloatType>}
\DoxyCodeLine{1643 \textcolor{keyword}{class }FloatingEqMatcher \{}
\DoxyCodeLine{1644  \textcolor{keyword}{public}:}
\DoxyCodeLine{1645   \textcolor{comment}{// Constructor for FloatingEqMatcher.}}
\DoxyCodeLine{1646   \textcolor{comment}{// The matcher's input will be compared with expected.  The matcher treats two}}
\DoxyCodeLine{1647   \textcolor{comment}{// NANs as equal if nan\_eq\_nan is true.  Otherwise, under IEEE standards,}}
\DoxyCodeLine{1648   \textcolor{comment}{// equality comparisons between NANs will always return false.  We specify a}}
\DoxyCodeLine{1649   \textcolor{comment}{// negative max\_abs\_error\_ term to indicate that ULP-\/based approximation will}}
\DoxyCodeLine{1650   \textcolor{comment}{// be used for comparison.}}
\DoxyCodeLine{1651   FloatingEqMatcher(FloatType expected, \textcolor{keywordtype}{bool} nan\_eq\_nan)}
\DoxyCodeLine{1652       : expected\_(expected), nan\_eq\_nan\_(nan\_eq\_nan), max\_abs\_error\_(-\/1) \{\}}
\DoxyCodeLine{1653 }
\DoxyCodeLine{1654   \textcolor{comment}{// Constructor that supports a user-\/specified max\_abs\_error that will be used}}
\DoxyCodeLine{1655   \textcolor{comment}{// for comparison instead of ULP-\/based approximation.  The max absolute}}
\DoxyCodeLine{1656   \textcolor{comment}{// should be non-\/negative.}}
\DoxyCodeLine{1657   FloatingEqMatcher(FloatType expected, \textcolor{keywordtype}{bool} nan\_eq\_nan,}
\DoxyCodeLine{1658                     FloatType max\_abs\_error)}
\DoxyCodeLine{1659       : expected\_(expected),}
\DoxyCodeLine{1660         nan\_eq\_nan\_(nan\_eq\_nan),}
\DoxyCodeLine{1661         max\_abs\_error\_(max\_abs\_error) \{}
\DoxyCodeLine{1662     GTEST\_CHECK\_(max\_abs\_error >= 0)}
\DoxyCodeLine{1663         << \textcolor{stringliteral}{"{}, where max\_abs\_error is"{}} << max\_abs\_error;}
\DoxyCodeLine{1664   \}}
\DoxyCodeLine{1665 }
\DoxyCodeLine{1666   \textcolor{comment}{// Implements floating point equality matcher as a Matcher<T>.}}
\DoxyCodeLine{1667   \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{1668   \textcolor{keyword}{class }Impl : \textcolor{keyword}{public} MatcherInterface<T> \{}
\DoxyCodeLine{1669    \textcolor{keyword}{public}:}
\DoxyCodeLine{1670     Impl(FloatType expected, \textcolor{keywordtype}{bool} nan\_eq\_nan, FloatType max\_abs\_error)}
\DoxyCodeLine{1671         : expected\_(expected),}
\DoxyCodeLine{1672           nan\_eq\_nan\_(nan\_eq\_nan),}
\DoxyCodeLine{1673           max\_abs\_error\_(max\_abs\_error) \{\}}
\DoxyCodeLine{1674 }
\DoxyCodeLine{1675     \textcolor{keywordtype}{bool} MatchAndExplain(T value,}
\DoxyCodeLine{1676                          MatchResultListener* listener)\textcolor{keyword}{ const override }\{}
\DoxyCodeLine{1677       \textcolor{keyword}{const} FloatingPoint<FloatType> actual(value), expected(expected\_);}
\DoxyCodeLine{1678 }
\DoxyCodeLine{1679       \textcolor{comment}{// Compares NaNs first, if nan\_eq\_nan\_ is true.}}
\DoxyCodeLine{1680       \textcolor{keywordflow}{if} (actual.is\_nan() || expected.is\_nan()) \{}
\DoxyCodeLine{1681         \textcolor{keywordflow}{if} (actual.is\_nan() \&\& expected.is\_nan()) \{}
\DoxyCodeLine{1682           \textcolor{keywordflow}{return} nan\_eq\_nan\_;}
\DoxyCodeLine{1683         \}}
\DoxyCodeLine{1684         \textcolor{comment}{// One is nan; the other is not nan.}}
\DoxyCodeLine{1685         \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{1686       \}}
\DoxyCodeLine{1687       \textcolor{keywordflow}{if} (HasMaxAbsError()) \{}
\DoxyCodeLine{1688         \textcolor{comment}{// We perform an equality check so that inf will match inf, regardless}}
\DoxyCodeLine{1689         \textcolor{comment}{// of error bounds.  If the result of value -\/ expected\_ would result in}}
\DoxyCodeLine{1690         \textcolor{comment}{// overflow or if either value is inf, the default result is infinity,}}
\DoxyCodeLine{1691         \textcolor{comment}{// which should only match if max\_abs\_error\_ is also infinity.}}
\DoxyCodeLine{1692         \textcolor{keywordflow}{if} (value == expected\_) \{}
\DoxyCodeLine{1693           \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{1694         \}}
\DoxyCodeLine{1695 }
\DoxyCodeLine{1696         \textcolor{keyword}{const} FloatType diff = value -\/ expected\_;}
\DoxyCodeLine{1697         \textcolor{keywordflow}{if} (::std::fabs(diff) <= max\_abs\_error\_) \{}
\DoxyCodeLine{1698           \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{1699         \}}
\DoxyCodeLine{1700 }
\DoxyCodeLine{1701         \textcolor{keywordflow}{if} (listener-\/>IsInterested()) \{}
\DoxyCodeLine{1702           *listener << \textcolor{stringliteral}{"{}which is "{}} << diff << \textcolor{stringliteral}{"{} from "{}} << expected\_;}
\DoxyCodeLine{1703         \}}
\DoxyCodeLine{1704         \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{1705       \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{1706         \textcolor{keywordflow}{return} actual.AlmostEquals(expected);}
\DoxyCodeLine{1707       \}}
\DoxyCodeLine{1708     \}}
\DoxyCodeLine{1709 }
\DoxyCodeLine{1710     \textcolor{keywordtype}{void} DescribeTo(::std::ostream* os)\textcolor{keyword}{ const override }\{}
\DoxyCodeLine{1711       \textcolor{comment}{// os-\/>precision() returns the previously set precision, which we}}
\DoxyCodeLine{1712       \textcolor{comment}{// store to restore the ostream to its original configuration}}
\DoxyCodeLine{1713       \textcolor{comment}{// after outputting.}}
\DoxyCodeLine{1714       const ::std::streamsize old\_precision =}
\DoxyCodeLine{1715           os-\/>precision(::std::numeric\_limits<FloatType>::digits10 + 2);}
\DoxyCodeLine{1716       \textcolor{keywordflow}{if} (FloatingPoint<FloatType>(expected\_).is\_nan()) \{}
\DoxyCodeLine{1717         \textcolor{keywordflow}{if} (nan\_eq\_nan\_) \{}
\DoxyCodeLine{1718           *os << \textcolor{stringliteral}{"{}is NaN"{}};}
\DoxyCodeLine{1719         \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{1720           *os << \textcolor{stringliteral}{"{}never matches"{}};}
\DoxyCodeLine{1721         \}}
\DoxyCodeLine{1722       \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{1723         *os << \textcolor{stringliteral}{"{}is approximately "{}} << expected\_;}
\DoxyCodeLine{1724         \textcolor{keywordflow}{if} (HasMaxAbsError()) \{}
\DoxyCodeLine{1725           *os << \textcolor{stringliteral}{"{} (absolute error <= "{}} << max\_abs\_error\_ << \textcolor{stringliteral}{"{})"{}};}
\DoxyCodeLine{1726         \}}
\DoxyCodeLine{1727       \}}
\DoxyCodeLine{1728       os-\/>precision(old\_precision);}
\DoxyCodeLine{1729     \}}
\DoxyCodeLine{1730 }
\DoxyCodeLine{1731     \textcolor{keywordtype}{void} DescribeNegationTo(::std::ostream* os)\textcolor{keyword}{ const override }\{}
\DoxyCodeLine{1732       \textcolor{comment}{// As before, get original precision.}}
\DoxyCodeLine{1733       const ::std::streamsize old\_precision =}
\DoxyCodeLine{1734           os-\/>precision(::std::numeric\_limits<FloatType>::digits10 + 2);}
\DoxyCodeLine{1735       \textcolor{keywordflow}{if} (FloatingPoint<FloatType>(expected\_).is\_nan()) \{}
\DoxyCodeLine{1736         \textcolor{keywordflow}{if} (nan\_eq\_nan\_) \{}
\DoxyCodeLine{1737           *os << \textcolor{stringliteral}{"{}isn't NaN"{}};}
\DoxyCodeLine{1738         \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{1739           *os << \textcolor{stringliteral}{"{}is anything"{}};}
\DoxyCodeLine{1740         \}}
\DoxyCodeLine{1741       \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{1742         *os << \textcolor{stringliteral}{"{}isn't approximately "{}} << expected\_;}
\DoxyCodeLine{1743         \textcolor{keywordflow}{if} (HasMaxAbsError()) \{}
\DoxyCodeLine{1744           *os << \textcolor{stringliteral}{"{} (absolute error > "{}} << max\_abs\_error\_ << \textcolor{stringliteral}{"{})"{}};}
\DoxyCodeLine{1745         \}}
\DoxyCodeLine{1746       \}}
\DoxyCodeLine{1747       \textcolor{comment}{// Restore original precision.}}
\DoxyCodeLine{1748       os-\/>precision(old\_precision);}
\DoxyCodeLine{1749     \}}
\DoxyCodeLine{1750 }
\DoxyCodeLine{1751    \textcolor{keyword}{private}:}
\DoxyCodeLine{1752     \textcolor{keywordtype}{bool} HasMaxAbsError()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} max\_abs\_error\_ >= 0; \}}
\DoxyCodeLine{1753 }
\DoxyCodeLine{1754     \textcolor{keyword}{const} FloatType expected\_;}
\DoxyCodeLine{1755     \textcolor{keyword}{const} \textcolor{keywordtype}{bool} nan\_eq\_nan\_;}
\DoxyCodeLine{1756     \textcolor{comment}{// max\_abs\_error will be used for value comparison when >= 0.}}
\DoxyCodeLine{1757     \textcolor{keyword}{const} FloatType max\_abs\_error\_;}
\DoxyCodeLine{1758   \};}
\DoxyCodeLine{1759 }
\DoxyCodeLine{1760   \textcolor{comment}{// The following 3 type conversion operators allow FloatEq(expected) and}}
\DoxyCodeLine{1761   \textcolor{comment}{// NanSensitiveFloatEq(expected) to be used as a Matcher<float>, a}}
\DoxyCodeLine{1762   \textcolor{comment}{// Matcher<const float\&>, or a Matcher<float\&>, but nothing else.}}
\DoxyCodeLine{1763   \textcolor{keyword}{operator} Matcher<FloatType>()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{1764     \textcolor{keywordflow}{return} MakeMatcher(}
\DoxyCodeLine{1765         \textcolor{keyword}{new} Impl<FloatType>(expected\_, nan\_eq\_nan\_, max\_abs\_error\_));}
\DoxyCodeLine{1766   \}}
\DoxyCodeLine{1767 }
\DoxyCodeLine{1768   \textcolor{keyword}{operator} Matcher<const FloatType\&>()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{1769     \textcolor{keywordflow}{return} MakeMatcher(}
\DoxyCodeLine{1770         \textcolor{keyword}{new} Impl<const FloatType\&>(expected\_, nan\_eq\_nan\_, max\_abs\_error\_));}
\DoxyCodeLine{1771   \}}
\DoxyCodeLine{1772 }
\DoxyCodeLine{1773   \textcolor{keyword}{operator} Matcher<FloatType\&>()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{1774     \textcolor{keywordflow}{return} MakeMatcher(}
\DoxyCodeLine{1775         \textcolor{keyword}{new} Impl<FloatType\&>(expected\_, nan\_eq\_nan\_, max\_abs\_error\_));}
\DoxyCodeLine{1776   \}}
\DoxyCodeLine{1777 }
\DoxyCodeLine{1778  \textcolor{keyword}{private}:}
\DoxyCodeLine{1779   \textcolor{keyword}{const} FloatType expected\_;}
\DoxyCodeLine{1780   \textcolor{keyword}{const} \textcolor{keywordtype}{bool} nan\_eq\_nan\_;}
\DoxyCodeLine{1781   \textcolor{comment}{// max\_abs\_error will be used for value comparison when >= 0.}}
\DoxyCodeLine{1782   \textcolor{keyword}{const} FloatType max\_abs\_error\_;}
\DoxyCodeLine{1783 \};}
\DoxyCodeLine{1784 }
\DoxyCodeLine{1785 \textcolor{comment}{// A 2-\/tuple ("{}binary"{}) wrapper around FloatingEqMatcher:}}
\DoxyCodeLine{1786 \textcolor{comment}{// FloatingEq2Matcher() matches (x, y) by matching FloatingEqMatcher(x, false)}}
\DoxyCodeLine{1787 \textcolor{comment}{// against y, and FloatingEq2Matcher(e) matches FloatingEqMatcher(x, false, e)}}
\DoxyCodeLine{1788 \textcolor{comment}{// against y. The former implements "{}Eq"{}, the latter "{}Near"{}. At present, there}}
\DoxyCodeLine{1789 \textcolor{comment}{// is no version that compares NaNs as equal.}}
\DoxyCodeLine{1790 \textcolor{keyword}{template} <\textcolor{keyword}{typename} FloatType>}
\DoxyCodeLine{1791 \textcolor{keyword}{class }FloatingEq2Matcher \{}
\DoxyCodeLine{1792  \textcolor{keyword}{public}:}
\DoxyCodeLine{1793   FloatingEq2Matcher() \{ Init(-\/1, \textcolor{keyword}{false}); \}}
\DoxyCodeLine{1794 }
\DoxyCodeLine{1795   \textcolor{keyword}{explicit} FloatingEq2Matcher(\textcolor{keywordtype}{bool} nan\_eq\_nan) \{ Init(-\/1, nan\_eq\_nan); \}}
\DoxyCodeLine{1796 }
\DoxyCodeLine{1797   \textcolor{keyword}{explicit} FloatingEq2Matcher(FloatType max\_abs\_error) \{}
\DoxyCodeLine{1798     Init(max\_abs\_error, \textcolor{keyword}{false});}
\DoxyCodeLine{1799   \}}
\DoxyCodeLine{1800 }
\DoxyCodeLine{1801   FloatingEq2Matcher(FloatType max\_abs\_error, \textcolor{keywordtype}{bool} nan\_eq\_nan) \{}
\DoxyCodeLine{1802     Init(max\_abs\_error, nan\_eq\_nan);}
\DoxyCodeLine{1803   \}}
\DoxyCodeLine{1804 }
\DoxyCodeLine{1805   \textcolor{keyword}{template} <\textcolor{keyword}{typename} T1, \textcolor{keyword}{typename} T2>}
\DoxyCodeLine{1806   \textcolor{keyword}{operator} Matcher<::std::tuple<T1, T2>>() \textcolor{keyword}{const} \{}
\DoxyCodeLine{1807     \textcolor{keywordflow}{return} MakeMatcher(}
\DoxyCodeLine{1808         \textcolor{keyword}{new} Impl<::std::tuple<T1, T2>>(max\_abs\_error\_, nan\_eq\_nan\_));}
\DoxyCodeLine{1809   \}}
\DoxyCodeLine{1810   \textcolor{keyword}{template} <\textcolor{keyword}{typename} T1, \textcolor{keyword}{typename} T2>}
\DoxyCodeLine{1811   \textcolor{keyword}{operator} Matcher<const ::std::tuple<T1, T2>\&>() \textcolor{keyword}{const} \{}
\DoxyCodeLine{1812     \textcolor{keywordflow}{return} MakeMatcher(}
\DoxyCodeLine{1813         \textcolor{keyword}{new} Impl<const ::std::tuple<T1, T2>\&>(max\_abs\_error\_, nan\_eq\_nan\_));}
\DoxyCodeLine{1814   \}}
\DoxyCodeLine{1815 }
\DoxyCodeLine{1816  \textcolor{keyword}{private}:}
\DoxyCodeLine{1817   static ::std::ostream\& GetDesc(::std::ostream\& os) \{  \textcolor{comment}{// NOLINT}}
\DoxyCodeLine{1818     \textcolor{keywordflow}{return} os << \textcolor{stringliteral}{"{}an almost-\/equal pair"{}};}
\DoxyCodeLine{1819   \}}
\DoxyCodeLine{1820 }
\DoxyCodeLine{1821   \textcolor{keyword}{template} <\textcolor{keyword}{typename} Tuple>}
\DoxyCodeLine{1822   \textcolor{keyword}{class }Impl : \textcolor{keyword}{public} MatcherInterface<Tuple> \{}
\DoxyCodeLine{1823    \textcolor{keyword}{public}:}
\DoxyCodeLine{1824     Impl(FloatType max\_abs\_error, \textcolor{keywordtype}{bool} nan\_eq\_nan)}
\DoxyCodeLine{1825         : max\_abs\_error\_(max\_abs\_error), nan\_eq\_nan\_(nan\_eq\_nan) \{\}}
\DoxyCodeLine{1826 }
\DoxyCodeLine{1827     \textcolor{keywordtype}{bool} MatchAndExplain(Tuple args,}
\DoxyCodeLine{1828                          MatchResultListener* listener)\textcolor{keyword}{ const override }\{}
\DoxyCodeLine{1829       \textcolor{keywordflow}{if} (max\_abs\_error\_ == -\/1) \{}
\DoxyCodeLine{1830         FloatingEqMatcher<FloatType> fm(::std::get<0>(args), nan\_eq\_nan\_);}
\DoxyCodeLine{1831         \textcolor{keywordflow}{return} \textcolor{keyword}{static\_cast<}Matcher<FloatType>\textcolor{keyword}{>}(fm).MatchAndExplain(}
\DoxyCodeLine{1832             ::std::get<1>(args), listener);}
\DoxyCodeLine{1833       \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{1834         FloatingEqMatcher<FloatType> fm(::std::get<0>(args), nan\_eq\_nan\_,}
\DoxyCodeLine{1835                                         max\_abs\_error\_);}
\DoxyCodeLine{1836         \textcolor{keywordflow}{return} \textcolor{keyword}{static\_cast<}Matcher<FloatType>\textcolor{keyword}{>}(fm).MatchAndExplain(}
\DoxyCodeLine{1837             ::std::get<1>(args), listener);}
\DoxyCodeLine{1838       \}}
\DoxyCodeLine{1839     \}}
\DoxyCodeLine{1840     \textcolor{keywordtype}{void} DescribeTo(::std::ostream* os)\textcolor{keyword}{ const override }\{}
\DoxyCodeLine{1841       *os << \textcolor{stringliteral}{"{}are "{}} << GetDesc;}
\DoxyCodeLine{1842     \}}
\DoxyCodeLine{1843     \textcolor{keywordtype}{void} DescribeNegationTo(::std::ostream* os)\textcolor{keyword}{ const override }\{}
\DoxyCodeLine{1844       *os << \textcolor{stringliteral}{"{}aren't "{}} << GetDesc;}
\DoxyCodeLine{1845     \}}
\DoxyCodeLine{1846 }
\DoxyCodeLine{1847    \textcolor{keyword}{private}:}
\DoxyCodeLine{1848     FloatType max\_abs\_error\_;}
\DoxyCodeLine{1849     \textcolor{keyword}{const} \textcolor{keywordtype}{bool} nan\_eq\_nan\_;}
\DoxyCodeLine{1850   \};}
\DoxyCodeLine{1851 }
\DoxyCodeLine{1852   \textcolor{keywordtype}{void} Init(FloatType max\_abs\_error\_val, \textcolor{keywordtype}{bool} nan\_eq\_nan\_val) \{}
\DoxyCodeLine{1853     max\_abs\_error\_ = max\_abs\_error\_val;}
\DoxyCodeLine{1854     nan\_eq\_nan\_ = nan\_eq\_nan\_val;}
\DoxyCodeLine{1855   \}}
\DoxyCodeLine{1856   FloatType max\_abs\_error\_;}
\DoxyCodeLine{1857   \textcolor{keywordtype}{bool} nan\_eq\_nan\_;}
\DoxyCodeLine{1858 \};}
\DoxyCodeLine{1859 }
\DoxyCodeLine{1860 \textcolor{comment}{// Implements the Pointee(m) matcher for matching a pointer whose}}
\DoxyCodeLine{1861 \textcolor{comment}{// pointee matches matcher m.  The pointer can be either raw or smart.}}
\DoxyCodeLine{1862 \textcolor{keyword}{template} <\textcolor{keyword}{typename} InnerMatcher>}
\DoxyCodeLine{1863 \textcolor{keyword}{class }PointeeMatcher \{}
\DoxyCodeLine{1864  \textcolor{keyword}{public}:}
\DoxyCodeLine{1865   \textcolor{keyword}{explicit} PointeeMatcher(\textcolor{keyword}{const} InnerMatcher\& matcher) : matcher\_(matcher) \{\}}
\DoxyCodeLine{1866 }
\DoxyCodeLine{1867   \textcolor{comment}{// This type conversion operator template allows Pointee(m) to be}}
\DoxyCodeLine{1868   \textcolor{comment}{// used as a matcher for any pointer type whose pointee type is}}
\DoxyCodeLine{1869   \textcolor{comment}{// compatible with the inner matcher, where type Pointer can be}}
\DoxyCodeLine{1870   \textcolor{comment}{// either a raw pointer or a smart pointer.}}
\DoxyCodeLine{1871   \textcolor{comment}{//}}
\DoxyCodeLine{1872   \textcolor{comment}{// The reason we do this instead of relying on}}
\DoxyCodeLine{1873   \textcolor{comment}{// MakePolymorphicMatcher() is that the latter is not flexible}}
\DoxyCodeLine{1874   \textcolor{comment}{// enough for implementing the DescribeTo() method of Pointee().}}
\DoxyCodeLine{1875   \textcolor{keyword}{template} <\textcolor{keyword}{typename} Po\textcolor{keywordtype}{int}er>}
\DoxyCodeLine{1876   \textcolor{keyword}{operator} Matcher<Pointer>()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{1877     \textcolor{keywordflow}{return} Matcher<Pointer>(\textcolor{keyword}{new} Impl<const Pointer\&>(matcher\_));}
\DoxyCodeLine{1878   \}}
\DoxyCodeLine{1879 }
\DoxyCodeLine{1880  \textcolor{keyword}{private}:}
\DoxyCodeLine{1881   \textcolor{comment}{// The monomorphic implementation that works for a particular pointer type.}}
\DoxyCodeLine{1882   \textcolor{keyword}{template} <\textcolor{keyword}{typename} Po\textcolor{keywordtype}{int}er>}
\DoxyCodeLine{1883   \textcolor{keyword}{class }Impl : \textcolor{keyword}{public} MatcherInterface<Pointer> \{}
\DoxyCodeLine{1884    \textcolor{keyword}{public}:}
\DoxyCodeLine{1885     \textcolor{keyword}{using }Pointee =}
\DoxyCodeLine{1886         \textcolor{keyword}{typename} std::pointer\_traits<GTEST\_REMOVE\_REFERENCE\_AND\_CONST\_(}
\DoxyCodeLine{1887             Pointer)>::element\_type;}
\DoxyCodeLine{1888 }
\DoxyCodeLine{1889     \textcolor{keyword}{explicit} Impl(\textcolor{keyword}{const} InnerMatcher\& matcher)}
\DoxyCodeLine{1890         : matcher\_(MatcherCast<const Pointee\&>(matcher)) \{\}}
\DoxyCodeLine{1891 }
\DoxyCodeLine{1892     \textcolor{keywordtype}{void} DescribeTo(::std::ostream* os)\textcolor{keyword}{ const override }\{}
\DoxyCodeLine{1893       *os << \textcolor{stringliteral}{"{}points to a value that "{}};}
\DoxyCodeLine{1894       matcher\_.DescribeTo(os);}
\DoxyCodeLine{1895     \}}
\DoxyCodeLine{1896 }
\DoxyCodeLine{1897     \textcolor{keywordtype}{void} DescribeNegationTo(::std::ostream* os)\textcolor{keyword}{ const override }\{}
\DoxyCodeLine{1898       *os << \textcolor{stringliteral}{"{}does not point to a value that "{}};}
\DoxyCodeLine{1899       matcher\_.DescribeTo(os);}
\DoxyCodeLine{1900     \}}
\DoxyCodeLine{1901 }
\DoxyCodeLine{1902     \textcolor{keywordtype}{bool} MatchAndExplain(Pointer pointer,}
\DoxyCodeLine{1903                          MatchResultListener* listener)\textcolor{keyword}{ const override }\{}
\DoxyCodeLine{1904       \textcolor{keywordflow}{if} (GetRawPointer(pointer) == \textcolor{keyword}{nullptr}) \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{1905 }
\DoxyCodeLine{1906       *listener << \textcolor{stringliteral}{"{}which points to "{}};}
\DoxyCodeLine{1907       \textcolor{keywordflow}{return} MatchPrintAndExplain(*pointer, matcher\_, listener);}
\DoxyCodeLine{1908     \}}
\DoxyCodeLine{1909 }
\DoxyCodeLine{1910    \textcolor{keyword}{private}:}
\DoxyCodeLine{1911     \textcolor{keyword}{const} Matcher<const Pointee\&> matcher\_;}
\DoxyCodeLine{1912   \};}
\DoxyCodeLine{1913 }
\DoxyCodeLine{1914   \textcolor{keyword}{const} InnerMatcher matcher\_;}
\DoxyCodeLine{1915 \};}
\DoxyCodeLine{1916 }
\DoxyCodeLine{1917 \textcolor{comment}{// Implements the Pointer(m) matcher}}
\DoxyCodeLine{1918 \textcolor{comment}{// Implements the Pointer(m) matcher for matching a pointer that matches matcher}}
\DoxyCodeLine{1919 \textcolor{comment}{// m.  The pointer can be either raw or smart, and will match `m` against the}}
\DoxyCodeLine{1920 \textcolor{comment}{// raw pointer.}}
\DoxyCodeLine{1921 \textcolor{keyword}{template} <\textcolor{keyword}{typename} InnerMatcher>}
\DoxyCodeLine{1922 \textcolor{keyword}{class }PointerMatcher \{}
\DoxyCodeLine{1923  \textcolor{keyword}{public}:}
\DoxyCodeLine{1924   \textcolor{keyword}{explicit} PointerMatcher(\textcolor{keyword}{const} InnerMatcher\& matcher) : matcher\_(matcher) \{\}}
\DoxyCodeLine{1925 }
\DoxyCodeLine{1926   \textcolor{comment}{// This type conversion operator template allows Pointer(m) to be}}
\DoxyCodeLine{1927   \textcolor{comment}{// used as a matcher for any pointer type whose pointer type is}}
\DoxyCodeLine{1928   \textcolor{comment}{// compatible with the inner matcher, where type PointerType can be}}
\DoxyCodeLine{1929   \textcolor{comment}{// either a raw pointer or a smart pointer.}}
\DoxyCodeLine{1930   \textcolor{comment}{//}}
\DoxyCodeLine{1931   \textcolor{comment}{// The reason we do this instead of relying on}}
\DoxyCodeLine{1932   \textcolor{comment}{// MakePolymorphicMatcher() is that the latter is not flexible}}
\DoxyCodeLine{1933   \textcolor{comment}{// enough for implementing the DescribeTo() method of Pointer().}}
\DoxyCodeLine{1934   \textcolor{keyword}{template} <\textcolor{keyword}{typename} Po\textcolor{keywordtype}{int}erType>}
\DoxyCodeLine{1935   \textcolor{keyword}{operator} Matcher<PointerType>()\textcolor{keyword}{ const }\{  \textcolor{comment}{// NOLINT}}
\DoxyCodeLine{1936     \textcolor{keywordflow}{return} Matcher<PointerType>(\textcolor{keyword}{new} Impl<const PointerType\&>(matcher\_));}
\DoxyCodeLine{1937   \}}
\DoxyCodeLine{1938 }
\DoxyCodeLine{1939  \textcolor{keyword}{private}:}
\DoxyCodeLine{1940   \textcolor{comment}{// The monomorphic implementation that works for a particular pointer type.}}
\DoxyCodeLine{1941   \textcolor{keyword}{template} <\textcolor{keyword}{typename} Po\textcolor{keywordtype}{int}erType>}
\DoxyCodeLine{1942   \textcolor{keyword}{class }Impl : \textcolor{keyword}{public} MatcherInterface<PointerType> \{}
\DoxyCodeLine{1943    \textcolor{keyword}{public}:}
\DoxyCodeLine{1944     \textcolor{keyword}{using }Pointer =}
\DoxyCodeLine{1945         \textcolor{keyword}{const} \textcolor{keyword}{typename} std::pointer\_traits<GTEST\_REMOVE\_REFERENCE\_AND\_CONST\_(}
\DoxyCodeLine{1946             PointerType)>::element\_type*;}
\DoxyCodeLine{1947 }
\DoxyCodeLine{1948     \textcolor{keyword}{explicit} Impl(\textcolor{keyword}{const} InnerMatcher\& matcher)}
\DoxyCodeLine{1949         : matcher\_(MatcherCast<Pointer>(matcher)) \{\}}
\DoxyCodeLine{1950 }
\DoxyCodeLine{1951     \textcolor{keywordtype}{void} DescribeTo(::std::ostream* os)\textcolor{keyword}{ const override }\{}
\DoxyCodeLine{1952       *os << \textcolor{stringliteral}{"{}is a pointer that "{}};}
\DoxyCodeLine{1953       matcher\_.DescribeTo(os);}
\DoxyCodeLine{1954     \}}
\DoxyCodeLine{1955 }
\DoxyCodeLine{1956     \textcolor{keywordtype}{void} DescribeNegationTo(::std::ostream* os)\textcolor{keyword}{ const override }\{}
\DoxyCodeLine{1957       *os << \textcolor{stringliteral}{"{}is not a pointer that "{}};}
\DoxyCodeLine{1958       matcher\_.DescribeTo(os);}
\DoxyCodeLine{1959     \}}
\DoxyCodeLine{1960 }
\DoxyCodeLine{1961     \textcolor{keywordtype}{bool} MatchAndExplain(PointerType pointer,}
\DoxyCodeLine{1962                          MatchResultListener* listener)\textcolor{keyword}{ const override }\{}
\DoxyCodeLine{1963       *listener << \textcolor{stringliteral}{"{}which is a pointer that "{}};}
\DoxyCodeLine{1964       Pointer p = GetRawPointer(pointer);}
\DoxyCodeLine{1965       \textcolor{keywordflow}{return} MatchPrintAndExplain(p, matcher\_, listener);}
\DoxyCodeLine{1966     \}}
\DoxyCodeLine{1967 }
\DoxyCodeLine{1968    \textcolor{keyword}{private}:}
\DoxyCodeLine{1969     Matcher<Pointer> matcher\_;}
\DoxyCodeLine{1970   \};}
\DoxyCodeLine{1971 }
\DoxyCodeLine{1972   \textcolor{keyword}{const} InnerMatcher matcher\_;}
\DoxyCodeLine{1973 \};}
\DoxyCodeLine{1974 }
\DoxyCodeLine{1975 \textcolor{preprocessor}{\#if GTEST\_HAS\_RTTI}}
\DoxyCodeLine{1976 \textcolor{comment}{// Implements the WhenDynamicCastTo<T>(m) matcher that matches a pointer or}}
\DoxyCodeLine{1977 \textcolor{comment}{// reference that matches inner\_matcher when dynamic\_cast<T> is applied.}}
\DoxyCodeLine{1978 \textcolor{comment}{// The result of dynamic\_cast<To> is forwarded to the inner matcher.}}
\DoxyCodeLine{1979 \textcolor{comment}{// If To is a pointer and the cast fails, the inner matcher will receive NULL.}}
\DoxyCodeLine{1980 \textcolor{comment}{// If To is a reference and the cast fails, this matcher returns false}}
\DoxyCodeLine{1981 \textcolor{comment}{// immediately.}}
\DoxyCodeLine{1982 \textcolor{keyword}{template} <\textcolor{keyword}{typename} To>}
\DoxyCodeLine{1983 \textcolor{keyword}{class }WhenDynamicCastToMatcherBase \{}
\DoxyCodeLine{1984  \textcolor{keyword}{public}:}
\DoxyCodeLine{1985   \textcolor{keyword}{explicit} WhenDynamicCastToMatcherBase(\textcolor{keyword}{const} Matcher<To>\& matcher)}
\DoxyCodeLine{1986       : matcher\_(matcher) \{\}}
\DoxyCodeLine{1987 }
\DoxyCodeLine{1988   \textcolor{keywordtype}{void} DescribeTo(::std::ostream* os)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{1989     GetCastTypeDescription(os);}
\DoxyCodeLine{1990     matcher\_.DescribeTo(os);}
\DoxyCodeLine{1991   \}}
\DoxyCodeLine{1992 }
\DoxyCodeLine{1993   \textcolor{keywordtype}{void} DescribeNegationTo(::std::ostream* os)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{1994     GetCastTypeDescription(os);}
\DoxyCodeLine{1995     matcher\_.DescribeNegationTo(os);}
\DoxyCodeLine{1996   \}}
\DoxyCodeLine{1997 }
\DoxyCodeLine{1998  \textcolor{keyword}{protected}:}
\DoxyCodeLine{1999   \textcolor{keyword}{const} Matcher<To> matcher\_;}
\DoxyCodeLine{2000 }
\DoxyCodeLine{2001   \textcolor{keyword}{static} std::string GetToName() \{ \textcolor{keywordflow}{return} GetTypeName<To>(); \}}
\DoxyCodeLine{2002 }
\DoxyCodeLine{2003  \textcolor{keyword}{private}:}
\DoxyCodeLine{2004   \textcolor{keyword}{static} \textcolor{keywordtype}{void} GetCastTypeDescription(::std::ostream* os) \{}
\DoxyCodeLine{2005     *os << \textcolor{stringliteral}{"{}when dynamic\_cast to "{}} << GetToName() << \textcolor{stringliteral}{"{}, "{}};}
\DoxyCodeLine{2006   \}}
\DoxyCodeLine{2007 \};}
\DoxyCodeLine{2008 }
\DoxyCodeLine{2009 \textcolor{comment}{// Primary template.}}
\DoxyCodeLine{2010 \textcolor{comment}{// To is a pointer. Cast and forward the result.}}
\DoxyCodeLine{2011 \textcolor{keyword}{template} <\textcolor{keyword}{typename} To>}
\DoxyCodeLine{2012 \textcolor{keyword}{class }WhenDynamicCastToMatcher : \textcolor{keyword}{public} WhenDynamicCastToMatcherBase<To> \{}
\DoxyCodeLine{2013  \textcolor{keyword}{public}:}
\DoxyCodeLine{2014   \textcolor{keyword}{explicit} WhenDynamicCastToMatcher(\textcolor{keyword}{const} Matcher<To>\& matcher)}
\DoxyCodeLine{2015       : WhenDynamicCastToMatcherBase<To>(matcher) \{\}}
\DoxyCodeLine{2016 }
\DoxyCodeLine{2017   \textcolor{keyword}{template} <\textcolor{keyword}{typename} From>}
\DoxyCodeLine{2018   \textcolor{keywordtype}{bool} MatchAndExplain(From from, MatchResultListener* listener)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{2019     To to = \textcolor{keyword}{dynamic\_cast<}To\textcolor{keyword}{>}(from);}
\DoxyCodeLine{2020     \textcolor{keywordflow}{return} MatchPrintAndExplain(to, this-\/>matcher\_, listener);}
\DoxyCodeLine{2021   \}}
\DoxyCodeLine{2022 \};}
\DoxyCodeLine{2023 }
\DoxyCodeLine{2024 \textcolor{comment}{// Specialize for references.}}
\DoxyCodeLine{2025 \textcolor{comment}{// In this case we return false if the dynamic\_cast fails.}}
\DoxyCodeLine{2026 \textcolor{keyword}{template} <\textcolor{keyword}{typename} To>}
\DoxyCodeLine{2027 \textcolor{keyword}{class }WhenDynamicCastToMatcher<To\&> : \textcolor{keyword}{public} WhenDynamicCastToMatcherBase<To\&> \{}
\DoxyCodeLine{2028  \textcolor{keyword}{public}:}
\DoxyCodeLine{2029   \textcolor{keyword}{explicit} WhenDynamicCastToMatcher(\textcolor{keyword}{const} Matcher<To\&>\& matcher)}
\DoxyCodeLine{2030       : WhenDynamicCastToMatcherBase<To\&>(matcher) \{\}}
\DoxyCodeLine{2031 }
\DoxyCodeLine{2032   \textcolor{keyword}{template} <\textcolor{keyword}{typename} From>}
\DoxyCodeLine{2033   \textcolor{keywordtype}{bool} MatchAndExplain(From\& from, MatchResultListener* listener)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{2034     \textcolor{comment}{// We don't want an std::bad\_cast here, so do the cast with pointers.}}
\DoxyCodeLine{2035     To* to = \textcolor{keyword}{dynamic\_cast<}To*\textcolor{keyword}{>}(\&from);}
\DoxyCodeLine{2036     \textcolor{keywordflow}{if} (to == \textcolor{keyword}{nullptr}) \{}
\DoxyCodeLine{2037       *listener << \textcolor{stringliteral}{"{}which cannot be dynamic\_cast to "{}} << this-\/>GetToName();}
\DoxyCodeLine{2038       \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{2039     \}}
\DoxyCodeLine{2040     \textcolor{keywordflow}{return} MatchPrintAndExplain(*to, this-\/>matcher\_, listener);}
\DoxyCodeLine{2041   \}}
\DoxyCodeLine{2042 \};}
\DoxyCodeLine{2043 \textcolor{preprocessor}{\#endif  }\textcolor{comment}{// GTEST\_HAS\_RTTI}}
\DoxyCodeLine{2044 }
\DoxyCodeLine{2045 \textcolor{comment}{// Implements the Field() matcher for matching a field (i.e. member}}
\DoxyCodeLine{2046 \textcolor{comment}{// variable) of an object.}}
\DoxyCodeLine{2047 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Class, \textcolor{keyword}{typename} FieldType>}
\DoxyCodeLine{2048 \textcolor{keyword}{class }FieldMatcher \{}
\DoxyCodeLine{2049  \textcolor{keyword}{public}:}
\DoxyCodeLine{2050   FieldMatcher(FieldType Class::*field,}
\DoxyCodeLine{2051                \textcolor{keyword}{const} Matcher<const FieldType\&>\& matcher)}
\DoxyCodeLine{2052       : field\_(field), matcher\_(matcher), whose\_field\_(\textcolor{stringliteral}{"{}whose given field "{}}) \{\}}
\DoxyCodeLine{2053 }
\DoxyCodeLine{2054   FieldMatcher(\textcolor{keyword}{const} std::string\& field\_name, FieldType Class::*field,}
\DoxyCodeLine{2055                \textcolor{keyword}{const} Matcher<const FieldType\&>\& matcher)}
\DoxyCodeLine{2056       : field\_(field),}
\DoxyCodeLine{2057         matcher\_(matcher),}
\DoxyCodeLine{2058         whose\_field\_(\textcolor{stringliteral}{"{}whose field `"{}} + field\_name + \textcolor{stringliteral}{"{}` "{}}) \{\}}
\DoxyCodeLine{2059 }
\DoxyCodeLine{2060   \textcolor{keywordtype}{void} DescribeTo(::std::ostream* os)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{2061     *os << \textcolor{stringliteral}{"{}is an object "{}} << whose\_field\_;}
\DoxyCodeLine{2062     matcher\_.DescribeTo(os);}
\DoxyCodeLine{2063   \}}
\DoxyCodeLine{2064 }
\DoxyCodeLine{2065   \textcolor{keywordtype}{void} DescribeNegationTo(::std::ostream* os)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{2066     *os << \textcolor{stringliteral}{"{}is an object "{}} << whose\_field\_;}
\DoxyCodeLine{2067     matcher\_.DescribeNegationTo(os);}
\DoxyCodeLine{2068   \}}
\DoxyCodeLine{2069 }
\DoxyCodeLine{2070   \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{2071   \textcolor{keywordtype}{bool} MatchAndExplain(\textcolor{keyword}{const} T\& value, MatchResultListener* listener)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{2072     \textcolor{comment}{// FIXME: The dispatch on std::is\_pointer was introduced as a workaround for}}
\DoxyCodeLine{2073     \textcolor{comment}{// a compiler bug, and can now be removed.}}
\DoxyCodeLine{2074     \textcolor{keywordflow}{return} MatchAndExplainImpl(}
\DoxyCodeLine{2075         \textcolor{keyword}{typename} std::is\_pointer<\textcolor{keyword}{typename} std::remove\_const<T>::type>::type(),}
\DoxyCodeLine{2076         value, listener);}
\DoxyCodeLine{2077   \}}
\DoxyCodeLine{2078 }
\DoxyCodeLine{2079  \textcolor{keyword}{private}:}
\DoxyCodeLine{2080   \textcolor{keywordtype}{bool} MatchAndExplainImpl(std::false\_type \textcolor{comment}{/* is\_not\_pointer */},}
\DoxyCodeLine{2081                            \textcolor{keyword}{const} Class\& obj,}
\DoxyCodeLine{2082                            MatchResultListener* listener)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{2083     *listener << whose\_field\_ << \textcolor{stringliteral}{"{}is "{}};}
\DoxyCodeLine{2084     \textcolor{keywordflow}{return} MatchPrintAndExplain(obj.*field\_, matcher\_, listener);}
\DoxyCodeLine{2085   \}}
\DoxyCodeLine{2086 }
\DoxyCodeLine{2087   \textcolor{keywordtype}{bool} MatchAndExplainImpl(std::true\_type \textcolor{comment}{/* is\_pointer */}, \textcolor{keyword}{const} Class* p,}
\DoxyCodeLine{2088                            MatchResultListener* listener)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{2089     \textcolor{keywordflow}{if} (p == \textcolor{keyword}{nullptr}) \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{2090 }
\DoxyCodeLine{2091     *listener << \textcolor{stringliteral}{"{}which points to an object "{}};}
\DoxyCodeLine{2092     \textcolor{comment}{// Since *p has a field, it must be a class/struct/union type and}}
\DoxyCodeLine{2093     \textcolor{comment}{// thus cannot be a pointer.  Therefore we pass false\_type() as}}
\DoxyCodeLine{2094     \textcolor{comment}{// the first argument.}}
\DoxyCodeLine{2095     \textcolor{keywordflow}{return} MatchAndExplainImpl(std::false\_type(), *p, listener);}
\DoxyCodeLine{2096   \}}
\DoxyCodeLine{2097 }
\DoxyCodeLine{2098   \textcolor{keyword}{const} FieldType Class::*field\_;}
\DoxyCodeLine{2099   \textcolor{keyword}{const} Matcher<const FieldType\&> matcher\_;}
\DoxyCodeLine{2100 }
\DoxyCodeLine{2101   \textcolor{comment}{// Contains either "{}whose given field "{} if the name of the field is unknown}}
\DoxyCodeLine{2102   \textcolor{comment}{// or "{}whose field `name\_of\_field` "{} if the name is known.}}
\DoxyCodeLine{2103   \textcolor{keyword}{const} std::string whose\_field\_;}
\DoxyCodeLine{2104 \};}
\DoxyCodeLine{2105 }
\DoxyCodeLine{2106 \textcolor{comment}{// Implements the Property() matcher for matching a property}}
\DoxyCodeLine{2107 \textcolor{comment}{// (i.e. return value of a getter method) of an object.}}
\DoxyCodeLine{2108 \textcolor{comment}{//}}
\DoxyCodeLine{2109 \textcolor{comment}{// Property is a const-\/qualified member function of Class returning}}
\DoxyCodeLine{2110 \textcolor{comment}{// PropertyType.}}
\DoxyCodeLine{2111 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Class, \textcolor{keyword}{typename} PropertyType, \textcolor{keyword}{typename} Property>}
\DoxyCodeLine{2112 \textcolor{keyword}{class }PropertyMatcher \{}
\DoxyCodeLine{2113  \textcolor{keyword}{public}:}
\DoxyCodeLine{2114   \textcolor{keyword}{typedef} \textcolor{keyword}{const} PropertyType\& RefToConstProperty;}
\DoxyCodeLine{2115 }
\DoxyCodeLine{2116   PropertyMatcher(Property property, \textcolor{keyword}{const} Matcher<RefToConstProperty>\& matcher)}
\DoxyCodeLine{2117       : property\_(property),}
\DoxyCodeLine{2118         matcher\_(matcher),}
\DoxyCodeLine{2119         whose\_property\_(\textcolor{stringliteral}{"{}whose given property "{}}) \{\}}
\DoxyCodeLine{2120 }
\DoxyCodeLine{2121   PropertyMatcher(\textcolor{keyword}{const} std::string\& property\_name, Property property,}
\DoxyCodeLine{2122                   \textcolor{keyword}{const} Matcher<RefToConstProperty>\& matcher)}
\DoxyCodeLine{2123       : property\_(property),}
\DoxyCodeLine{2124         matcher\_(matcher),}
\DoxyCodeLine{2125         whose\_property\_(\textcolor{stringliteral}{"{}whose property `"{}} + property\_name + \textcolor{stringliteral}{"{}` "{}}) \{\}}
\DoxyCodeLine{2126 }
\DoxyCodeLine{2127   \textcolor{keywordtype}{void} DescribeTo(::std::ostream* os)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{2128     *os << \textcolor{stringliteral}{"{}is an object "{}} << whose\_property\_;}
\DoxyCodeLine{2129     matcher\_.DescribeTo(os);}
\DoxyCodeLine{2130   \}}
\DoxyCodeLine{2131 }
\DoxyCodeLine{2132   \textcolor{keywordtype}{void} DescribeNegationTo(::std::ostream* os)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{2133     *os << \textcolor{stringliteral}{"{}is an object "{}} << whose\_property\_;}
\DoxyCodeLine{2134     matcher\_.DescribeNegationTo(os);}
\DoxyCodeLine{2135   \}}
\DoxyCodeLine{2136 }
\DoxyCodeLine{2137   \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{2138   \textcolor{keywordtype}{bool} MatchAndExplain(\textcolor{keyword}{const} T\& value, MatchResultListener* listener)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{2139     \textcolor{keywordflow}{return} MatchAndExplainImpl(}
\DoxyCodeLine{2140         \textcolor{keyword}{typename} std::is\_pointer<\textcolor{keyword}{typename} std::remove\_const<T>::type>::type(),}
\DoxyCodeLine{2141         value, listener);}
\DoxyCodeLine{2142   \}}
\DoxyCodeLine{2143 }
\DoxyCodeLine{2144  \textcolor{keyword}{private}:}
\DoxyCodeLine{2145   \textcolor{keywordtype}{bool} MatchAndExplainImpl(std::false\_type \textcolor{comment}{/* is\_not\_pointer */},}
\DoxyCodeLine{2146                            \textcolor{keyword}{const} Class\& obj,}
\DoxyCodeLine{2147                            MatchResultListener* listener)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{2148     *listener << whose\_property\_ << \textcolor{stringliteral}{"{}is "{}};}
\DoxyCodeLine{2149     \textcolor{comment}{// Cannot pass the return value (for example, int) to MatchPrintAndExplain,}}
\DoxyCodeLine{2150     \textcolor{comment}{// which takes a non-\/const reference as argument.}}
\DoxyCodeLine{2151     RefToConstProperty result = (obj.*property\_)();}
\DoxyCodeLine{2152     \textcolor{keywordflow}{return} MatchPrintAndExplain(result, matcher\_, listener);}
\DoxyCodeLine{2153   \}}
\DoxyCodeLine{2154 }
\DoxyCodeLine{2155   \textcolor{keywordtype}{bool} MatchAndExplainImpl(std::true\_type \textcolor{comment}{/* is\_pointer */}, \textcolor{keyword}{const} Class* p,}
\DoxyCodeLine{2156                            MatchResultListener* listener)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{2157     \textcolor{keywordflow}{if} (p == \textcolor{keyword}{nullptr}) \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{2158 }
\DoxyCodeLine{2159     *listener << \textcolor{stringliteral}{"{}which points to an object "{}};}
\DoxyCodeLine{2160     \textcolor{comment}{// Since *p has a property method, it must be a class/struct/union}}
\DoxyCodeLine{2161     \textcolor{comment}{// type and thus cannot be a pointer.  Therefore we pass}}
\DoxyCodeLine{2162     \textcolor{comment}{// false\_type() as the first argument.}}
\DoxyCodeLine{2163     \textcolor{keywordflow}{return} MatchAndExplainImpl(std::false\_type(), *p, listener);}
\DoxyCodeLine{2164   \}}
\DoxyCodeLine{2165 }
\DoxyCodeLine{2166   Property property\_;}
\DoxyCodeLine{2167   \textcolor{keyword}{const} Matcher<RefToConstProperty> matcher\_;}
\DoxyCodeLine{2168 }
\DoxyCodeLine{2169   \textcolor{comment}{// Contains either "{}whose given property "{} if the name of the property is}}
\DoxyCodeLine{2170   \textcolor{comment}{// unknown or "{}whose property `name\_of\_property` "{} if the name is known.}}
\DoxyCodeLine{2171   \textcolor{keyword}{const} std::string whose\_property\_;}
\DoxyCodeLine{2172 \};}
\DoxyCodeLine{2173 }
\DoxyCodeLine{2174 \textcolor{comment}{// Type traits specifying various features of different functors for ResultOf.}}
\DoxyCodeLine{2175 \textcolor{comment}{// The default template specifies features for functor objects.}}
\DoxyCodeLine{2176 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Functor>}
\DoxyCodeLine{2177 \textcolor{keyword}{struct }CallableTraits \{}
\DoxyCodeLine{2178   \textcolor{keyword}{typedef} Functor StorageType;}
\DoxyCodeLine{2179 }
\DoxyCodeLine{2180   \textcolor{keyword}{static} \textcolor{keywordtype}{void} CheckIsValid(Functor \textcolor{comment}{/* functor */}) \{\}}
\DoxyCodeLine{2181 }
\DoxyCodeLine{2182   \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{2183   \textcolor{keyword}{static} \textcolor{keyword}{auto} Invoke(Functor f, \textcolor{keyword}{const} T\& arg) -\/> \textcolor{keyword}{decltype}(f(arg)) \{}
\DoxyCodeLine{2184     \textcolor{keywordflow}{return} f(arg);}
\DoxyCodeLine{2185   \}}
\DoxyCodeLine{2186 \};}
\DoxyCodeLine{2187 }
\DoxyCodeLine{2188 \textcolor{comment}{// Specialization for function pointers.}}
\DoxyCodeLine{2189 \textcolor{keyword}{template} <\textcolor{keyword}{typename} ArgType, \textcolor{keyword}{typename} ResType>}
\DoxyCodeLine{2190 \textcolor{keyword}{struct }CallableTraits<ResType (*)(ArgType)> \{}
\DoxyCodeLine{2191   \textcolor{keyword}{typedef} ResType ResultType;}
\DoxyCodeLine{2192   \textcolor{keyword}{typedef} ResType (*StorageType)(ArgType);}
\DoxyCodeLine{2193 }
\DoxyCodeLine{2194   \textcolor{keyword}{static} \textcolor{keywordtype}{void} CheckIsValid(ResType (*f)(ArgType)) \{}
\DoxyCodeLine{2195     GTEST\_CHECK\_(f != \textcolor{keyword}{nullptr})}
\DoxyCodeLine{2196         << \textcolor{stringliteral}{"{}NULL function pointer is passed into ResultOf()."{}};}
\DoxyCodeLine{2197   \}}
\DoxyCodeLine{2198   \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{2199   \textcolor{keyword}{static} ResType Invoke(ResType (*f)(ArgType), T arg) \{}
\DoxyCodeLine{2200     \textcolor{keywordflow}{return} (*f)(arg);}
\DoxyCodeLine{2201   \}}
\DoxyCodeLine{2202 \};}
\DoxyCodeLine{2203 }
\DoxyCodeLine{2204 \textcolor{comment}{// Implements the ResultOf() matcher for matching a return value of a}}
\DoxyCodeLine{2205 \textcolor{comment}{// unary function of an object.}}
\DoxyCodeLine{2206 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Callable, \textcolor{keyword}{typename} InnerMatcher>}
\DoxyCodeLine{2207 \textcolor{keyword}{class }ResultOfMatcher \{}
\DoxyCodeLine{2208  \textcolor{keyword}{public}:}
\DoxyCodeLine{2209   ResultOfMatcher(Callable callable, InnerMatcher matcher)}
\DoxyCodeLine{2210       : ResultOfMatcher(\textcolor{comment}{/*result\_description=*/}\textcolor{stringliteral}{"{}"{}}, std::move(callable),}
\DoxyCodeLine{2211                         std::move(matcher)) \{\}}
\DoxyCodeLine{2212 }
\DoxyCodeLine{2213   ResultOfMatcher(\textcolor{keyword}{const} std::string\& result\_description, Callable callable,}
\DoxyCodeLine{2214                   InnerMatcher matcher)}
\DoxyCodeLine{2215       : result\_description\_(result\_description),}
\DoxyCodeLine{2216         callable\_(std::move(callable)),}
\DoxyCodeLine{2217         matcher\_(std::move(matcher)) \{}
\DoxyCodeLine{2218     CallableTraits<Callable>::CheckIsValid(callable\_);}
\DoxyCodeLine{2219   \}}
\DoxyCodeLine{2220 }
\DoxyCodeLine{2221   \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{2222   \textcolor{keyword}{operator} Matcher<T>()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{2223     \textcolor{keywordflow}{return} Matcher<T>(}
\DoxyCodeLine{2224         \textcolor{keyword}{new} Impl<const T\&>(result\_description\_, callable\_, matcher\_));}
\DoxyCodeLine{2225   \}}
\DoxyCodeLine{2226 }
\DoxyCodeLine{2227  \textcolor{keyword}{private}:}
\DoxyCodeLine{2228   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} CallableTraits<Callable>::StorageType CallableStorageType;}
\DoxyCodeLine{2229 }
\DoxyCodeLine{2230   \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{2231   \textcolor{keyword}{class }Impl : \textcolor{keyword}{public} MatcherInterface<T> \{}
\DoxyCodeLine{2232     \textcolor{keyword}{using }ResultType = \textcolor{keyword}{decltype}(CallableTraits<Callable>::template Invoke<T>(}
\DoxyCodeLine{2233         std::declval<CallableStorageType>(), std::declval<T>()));}
\DoxyCodeLine{2234 }
\DoxyCodeLine{2235    \textcolor{keyword}{public}:}
\DoxyCodeLine{2236     \textcolor{keyword}{template} <\textcolor{keyword}{typename} M>}
\DoxyCodeLine{2237     Impl(\textcolor{keyword}{const} std::string\& result\_description,}
\DoxyCodeLine{2238          \textcolor{keyword}{const} CallableStorageType\& callable, \textcolor{keyword}{const} M\& matcher)}
\DoxyCodeLine{2239         : result\_description\_(result\_description),}
\DoxyCodeLine{2240           callable\_(callable),}
\DoxyCodeLine{2241           matcher\_(MatcherCast<ResultType>(matcher)) \{\}}
\DoxyCodeLine{2242 }
\DoxyCodeLine{2243     \textcolor{keywordtype}{void} DescribeTo(::std::ostream* os)\textcolor{keyword}{ const override }\{}
\DoxyCodeLine{2244       \textcolor{keywordflow}{if} (result\_description\_.empty()) \{}
\DoxyCodeLine{2245         *os << \textcolor{stringliteral}{"{}is mapped by the given callable to a value that "{}};}
\DoxyCodeLine{2246       \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{2247         *os << \textcolor{stringliteral}{"{}whose "{}} << result\_description\_ << \textcolor{stringliteral}{"{} "{}};}
\DoxyCodeLine{2248       \}}
\DoxyCodeLine{2249       matcher\_.DescribeTo(os);}
\DoxyCodeLine{2250     \}}
\DoxyCodeLine{2251 }
\DoxyCodeLine{2252     \textcolor{keywordtype}{void} DescribeNegationTo(::std::ostream* os)\textcolor{keyword}{ const override }\{}
\DoxyCodeLine{2253       \textcolor{keywordflow}{if} (result\_description\_.empty()) \{}
\DoxyCodeLine{2254         *os << \textcolor{stringliteral}{"{}is mapped by the given callable to a value that "{}};}
\DoxyCodeLine{2255       \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{2256         *os << \textcolor{stringliteral}{"{}whose "{}} << result\_description\_ << \textcolor{stringliteral}{"{} "{}};}
\DoxyCodeLine{2257       \}}
\DoxyCodeLine{2258       matcher\_.DescribeNegationTo(os);}
\DoxyCodeLine{2259     \}}
\DoxyCodeLine{2260 }
\DoxyCodeLine{2261     \textcolor{keywordtype}{bool} MatchAndExplain(T obj, MatchResultListener* listener)\textcolor{keyword}{ const override }\{}
\DoxyCodeLine{2262       \textcolor{keywordflow}{if} (result\_description\_.empty()) \{}
\DoxyCodeLine{2263         *listener << \textcolor{stringliteral}{"{}which is mapped by the given callable to "{}};}
\DoxyCodeLine{2264       \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{2265         *listener << \textcolor{stringliteral}{"{}whose "{}} << result\_description\_ << \textcolor{stringliteral}{"{} is "{}};}
\DoxyCodeLine{2266       \}}
\DoxyCodeLine{2267       \textcolor{comment}{// Cannot pass the return value directly to MatchPrintAndExplain, which}}
\DoxyCodeLine{2268       \textcolor{comment}{// takes a non-\/const reference as argument.}}
\DoxyCodeLine{2269       \textcolor{comment}{// Also, specifying template argument explicitly is needed because T could}}
\DoxyCodeLine{2270       \textcolor{comment}{// be a non-\/const reference (e.g. Matcher<Uncopyable\&>).}}
\DoxyCodeLine{2271       ResultType result =}
\DoxyCodeLine{2272           CallableTraits<Callable>::template Invoke<T>(callable\_, obj);}
\DoxyCodeLine{2273       \textcolor{keywordflow}{return} MatchPrintAndExplain(result, matcher\_, listener);}
\DoxyCodeLine{2274     \}}
\DoxyCodeLine{2275 }
\DoxyCodeLine{2276    \textcolor{keyword}{private}:}
\DoxyCodeLine{2277     \textcolor{keyword}{const} std::string result\_description\_;}
\DoxyCodeLine{2278     \textcolor{comment}{// Functors often define operator() as non-\/const method even though}}
\DoxyCodeLine{2279     \textcolor{comment}{// they are actually stateless. But we need to use them even when}}
\DoxyCodeLine{2280     \textcolor{comment}{// 'this' is a const pointer. It's the user's responsibility not to}}
\DoxyCodeLine{2281     \textcolor{comment}{// use stateful callables with ResultOf(), which doesn't guarantee}}
\DoxyCodeLine{2282     \textcolor{comment}{// how many times the callable will be invoked.}}
\DoxyCodeLine{2283     \textcolor{keyword}{mutable} CallableStorageType callable\_;}
\DoxyCodeLine{2284     \textcolor{keyword}{const} Matcher<ResultType> matcher\_;}
\DoxyCodeLine{2285   \};  \textcolor{comment}{// class Impl}}
\DoxyCodeLine{2286 }
\DoxyCodeLine{2287   \textcolor{keyword}{const} std::string result\_description\_;}
\DoxyCodeLine{2288   \textcolor{keyword}{const} CallableStorageType callable\_;}
\DoxyCodeLine{2289   \textcolor{keyword}{const} InnerMatcher matcher\_;}
\DoxyCodeLine{2290 \};}
\DoxyCodeLine{2291 }
\DoxyCodeLine{2292 \textcolor{comment}{// Implements a matcher that checks the size of an STL-\/style container.}}
\DoxyCodeLine{2293 \textcolor{keyword}{template} <\textcolor{keyword}{typename} SizeMatcher>}
\DoxyCodeLine{2294 \textcolor{keyword}{class }SizeIsMatcher \{}
\DoxyCodeLine{2295  \textcolor{keyword}{public}:}
\DoxyCodeLine{2296   \textcolor{keyword}{explicit} SizeIsMatcher(\textcolor{keyword}{const} SizeMatcher\& size\_matcher)}
\DoxyCodeLine{2297       : size\_matcher\_(size\_matcher) \{\}}
\DoxyCodeLine{2298 }
\DoxyCodeLine{2299   \textcolor{keyword}{template} <\textcolor{keyword}{typename} Container>}
\DoxyCodeLine{2300   \textcolor{keyword}{operator} Matcher<Container>()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{2301     \textcolor{keywordflow}{return} Matcher<Container>(\textcolor{keyword}{new} Impl<const Container\&>(size\_matcher\_));}
\DoxyCodeLine{2302   \}}
\DoxyCodeLine{2303 }
\DoxyCodeLine{2304   \textcolor{keyword}{template} <\textcolor{keyword}{typename} Container>}
\DoxyCodeLine{2305   \textcolor{keyword}{class }Impl : \textcolor{keyword}{public} MatcherInterface<Container> \{}
\DoxyCodeLine{2306    \textcolor{keyword}{public}:}
\DoxyCodeLine{2307     \textcolor{keyword}{using }SizeType = \textcolor{keyword}{decltype}(std::declval<Container>().size());}
\DoxyCodeLine{2308     \textcolor{keyword}{explicit} Impl(\textcolor{keyword}{const} SizeMatcher\& size\_matcher)}
\DoxyCodeLine{2309         : size\_matcher\_(MatcherCast<SizeType>(size\_matcher)) \{\}}
\DoxyCodeLine{2310 }
\DoxyCodeLine{2311     \textcolor{keywordtype}{void} DescribeTo(::std::ostream* os)\textcolor{keyword}{ const override }\{}
\DoxyCodeLine{2312       *os << \textcolor{stringliteral}{"{}size "{}};}
\DoxyCodeLine{2313       size\_matcher\_.DescribeTo(os);}
\DoxyCodeLine{2314     \}}
\DoxyCodeLine{2315     \textcolor{keywordtype}{void} DescribeNegationTo(::std::ostream* os)\textcolor{keyword}{ const override }\{}
\DoxyCodeLine{2316       *os << \textcolor{stringliteral}{"{}size "{}};}
\DoxyCodeLine{2317       size\_matcher\_.DescribeNegationTo(os);}
\DoxyCodeLine{2318     \}}
\DoxyCodeLine{2319 }
\DoxyCodeLine{2320     \textcolor{keywordtype}{bool} MatchAndExplain(Container container,}
\DoxyCodeLine{2321                          MatchResultListener* listener)\textcolor{keyword}{ const override }\{}
\DoxyCodeLine{2322       SizeType size = container.size();}
\DoxyCodeLine{2323       StringMatchResultListener size\_listener;}
\DoxyCodeLine{2324       \textcolor{keyword}{const} \textcolor{keywordtype}{bool} result = size\_matcher\_.MatchAndExplain(size, \&size\_listener);}
\DoxyCodeLine{2325       *listener << \textcolor{stringliteral}{"{}whose size "{}} << size}
\DoxyCodeLine{2326                 << (result ? \textcolor{stringliteral}{"{} matches"{}} : \textcolor{stringliteral}{"{} doesn't match"{}});}
\DoxyCodeLine{2327       PrintIfNotEmpty(size\_listener.str(), listener-\/>stream());}
\DoxyCodeLine{2328       \textcolor{keywordflow}{return} result;}
\DoxyCodeLine{2329     \}}
\DoxyCodeLine{2330 }
\DoxyCodeLine{2331    \textcolor{keyword}{private}:}
\DoxyCodeLine{2332     \textcolor{keyword}{const} Matcher<SizeType> size\_matcher\_;}
\DoxyCodeLine{2333   \};}
\DoxyCodeLine{2334 }
\DoxyCodeLine{2335  \textcolor{keyword}{private}:}
\DoxyCodeLine{2336   \textcolor{keyword}{const} SizeMatcher size\_matcher\_;}
\DoxyCodeLine{2337 \};}
\DoxyCodeLine{2338 }
\DoxyCodeLine{2339 \textcolor{comment}{// Implements a matcher that checks the begin()..end() distance of an STL-\/style}}
\DoxyCodeLine{2340 \textcolor{comment}{// container.}}
\DoxyCodeLine{2341 \textcolor{keyword}{template} <\textcolor{keyword}{typename} DistanceMatcher>}
\DoxyCodeLine{2342 \textcolor{keyword}{class }BeginEndDistanceIsMatcher \{}
\DoxyCodeLine{2343  \textcolor{keyword}{public}:}
\DoxyCodeLine{2344   \textcolor{keyword}{explicit} BeginEndDistanceIsMatcher(\textcolor{keyword}{const} DistanceMatcher\& distance\_matcher)}
\DoxyCodeLine{2345       : distance\_matcher\_(distance\_matcher) \{\}}
\DoxyCodeLine{2346 }
\DoxyCodeLine{2347   \textcolor{keyword}{template} <\textcolor{keyword}{typename} Container>}
\DoxyCodeLine{2348   \textcolor{keyword}{operator} Matcher<Container>()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{2349     \textcolor{keywordflow}{return} Matcher<Container>(\textcolor{keyword}{new} Impl<const Container\&>(distance\_matcher\_));}
\DoxyCodeLine{2350   \}}
\DoxyCodeLine{2351 }
\DoxyCodeLine{2352   \textcolor{keyword}{template} <\textcolor{keyword}{typename} Container>}
\DoxyCodeLine{2353   \textcolor{keyword}{class }Impl : \textcolor{keyword}{public} MatcherInterface<Container> \{}
\DoxyCodeLine{2354    \textcolor{keyword}{public}:}
\DoxyCodeLine{2355     \textcolor{keyword}{typedef} internal::StlContainerView<GTEST\_REMOVE\_REFERENCE\_AND\_CONST\_(}
\DoxyCodeLine{2356         Container)>}
\DoxyCodeLine{2357         ContainerView;}
\DoxyCodeLine{2358     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} std::iterator\_traits<}
\DoxyCodeLine{2359         \textcolor{keyword}{typename} ContainerView::type::const\_iterator>::difference\_type}
\DoxyCodeLine{2360         DistanceType;}
\DoxyCodeLine{2361     \textcolor{keyword}{explicit} Impl(\textcolor{keyword}{const} DistanceMatcher\& distance\_matcher)}
\DoxyCodeLine{2362         : distance\_matcher\_(MatcherCast<DistanceType>(distance\_matcher)) \{\}}
\DoxyCodeLine{2363 }
\DoxyCodeLine{2364     \textcolor{keywordtype}{void} DescribeTo(::std::ostream* os)\textcolor{keyword}{ const override }\{}
\DoxyCodeLine{2365       *os << \textcolor{stringliteral}{"{}distance between begin() and end() "{}};}
\DoxyCodeLine{2366       distance\_matcher\_.DescribeTo(os);}
\DoxyCodeLine{2367     \}}
\DoxyCodeLine{2368     \textcolor{keywordtype}{void} DescribeNegationTo(::std::ostream* os)\textcolor{keyword}{ const override }\{}
\DoxyCodeLine{2369       *os << \textcolor{stringliteral}{"{}distance between begin() and end() "{}};}
\DoxyCodeLine{2370       distance\_matcher\_.DescribeNegationTo(os);}
\DoxyCodeLine{2371     \}}
\DoxyCodeLine{2372 }
\DoxyCodeLine{2373     \textcolor{keywordtype}{bool} MatchAndExplain(Container container,}
\DoxyCodeLine{2374                          MatchResultListener* listener)\textcolor{keyword}{ const override }\{}
\DoxyCodeLine{2375       \textcolor{keyword}{using }std::begin;}
\DoxyCodeLine{2376       \textcolor{keyword}{using }std::end;}
\DoxyCodeLine{2377       DistanceType distance = std::distance(begin(container), end(container));}
\DoxyCodeLine{2378       StringMatchResultListener distance\_listener;}
\DoxyCodeLine{2379       \textcolor{keyword}{const} \textcolor{keywordtype}{bool} result =}
\DoxyCodeLine{2380           distance\_matcher\_.MatchAndExplain(distance, \&distance\_listener);}
\DoxyCodeLine{2381       *listener << \textcolor{stringliteral}{"{}whose distance between begin() and end() "{}} << distance}
\DoxyCodeLine{2382                 << (result ? \textcolor{stringliteral}{"{} matches"{}} : \textcolor{stringliteral}{"{} doesn't match"{}});}
\DoxyCodeLine{2383       PrintIfNotEmpty(distance\_listener.str(), listener-\/>stream());}
\DoxyCodeLine{2384       \textcolor{keywordflow}{return} result;}
\DoxyCodeLine{2385     \}}
\DoxyCodeLine{2386 }
\DoxyCodeLine{2387    \textcolor{keyword}{private}:}
\DoxyCodeLine{2388     \textcolor{keyword}{const} Matcher<DistanceType> distance\_matcher\_;}
\DoxyCodeLine{2389   \};}
\DoxyCodeLine{2390 }
\DoxyCodeLine{2391  \textcolor{keyword}{private}:}
\DoxyCodeLine{2392   \textcolor{keyword}{const} DistanceMatcher distance\_matcher\_;}
\DoxyCodeLine{2393 \};}
\DoxyCodeLine{2394 }
\DoxyCodeLine{2395 \textcolor{comment}{// Implements an equality matcher for any STL-\/style container whose elements}}
\DoxyCodeLine{2396 \textcolor{comment}{// support ==. This matcher is like Eq(), but its failure explanations provide}}
\DoxyCodeLine{2397 \textcolor{comment}{// more detailed information that is useful when the container is used as a set.}}
\DoxyCodeLine{2398 \textcolor{comment}{// The failure message reports elements that are in one of the operands but not}}
\DoxyCodeLine{2399 \textcolor{comment}{// the other. The failure messages do not report duplicate or out-\/of-\/order}}
\DoxyCodeLine{2400 \textcolor{comment}{// elements in the containers (which don't properly matter to sets, but can}}
\DoxyCodeLine{2401 \textcolor{comment}{// occur if the containers are vectors or lists, for example).}}
\DoxyCodeLine{2402 \textcolor{comment}{//}}
\DoxyCodeLine{2403 \textcolor{comment}{// Uses the container's const\_iterator, value\_type, operator ==,}}
\DoxyCodeLine{2404 \textcolor{comment}{// begin(), and end().}}
\DoxyCodeLine{2405 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Container>}
\DoxyCodeLine{2406 \textcolor{keyword}{class }ContainerEqMatcher \{}
\DoxyCodeLine{2407  \textcolor{keyword}{public}:}
\DoxyCodeLine{2408   \textcolor{keyword}{typedef} internal::StlContainerView<Container> View;}
\DoxyCodeLine{2409   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} View::type StlContainer;}
\DoxyCodeLine{2410   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} View::const\_reference StlContainerReference;}
\DoxyCodeLine{2411 }
\DoxyCodeLine{2412   \textcolor{keyword}{static\_assert}(!std::is\_const<Container>::value,}
\DoxyCodeLine{2413                 \textcolor{stringliteral}{"{}Container type must not be const"{}});}
\DoxyCodeLine{2414   \textcolor{keyword}{static\_assert}(!std::is\_reference<Container>::value,}
\DoxyCodeLine{2415                 \textcolor{stringliteral}{"{}Container type must not be a reference"{}});}
\DoxyCodeLine{2416 }
\DoxyCodeLine{2417   \textcolor{comment}{// We make a copy of expected in case the elements in it are modified}}
\DoxyCodeLine{2418   \textcolor{comment}{// after this matcher is created.}}
\DoxyCodeLine{2419   \textcolor{keyword}{explicit} ContainerEqMatcher(\textcolor{keyword}{const} Container\& expected)}
\DoxyCodeLine{2420       : expected\_(View::Copy(expected)) \{\}}
\DoxyCodeLine{2421 }
\DoxyCodeLine{2422   \textcolor{keywordtype}{void} DescribeTo(::std::ostream* os)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{2423     *os << \textcolor{stringliteral}{"{}equals "{}};}
\DoxyCodeLine{2424     UniversalPrint(expected\_, os);}
\DoxyCodeLine{2425   \}}
\DoxyCodeLine{2426   \textcolor{keywordtype}{void} DescribeNegationTo(::std::ostream* os)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{2427     *os << \textcolor{stringliteral}{"{}does not equal "{}};}
\DoxyCodeLine{2428     UniversalPrint(expected\_, os);}
\DoxyCodeLine{2429   \}}
\DoxyCodeLine{2430 }
\DoxyCodeLine{2431   \textcolor{keyword}{template} <\textcolor{keyword}{typename} LhsContainer>}
\DoxyCodeLine{2432   \textcolor{keywordtype}{bool} MatchAndExplain(\textcolor{keyword}{const} LhsContainer\& lhs,}
\DoxyCodeLine{2433                        MatchResultListener* listener)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{2434     \textcolor{keyword}{typedef} internal::StlContainerView<}
\DoxyCodeLine{2435         \textcolor{keyword}{typename} std::remove\_const<LhsContainer>::type>}
\DoxyCodeLine{2436         LhsView;}
\DoxyCodeLine{2437     StlContainerReference lhs\_stl\_container = LhsView::ConstReference(lhs);}
\DoxyCodeLine{2438     \textcolor{keywordflow}{if} (lhs\_stl\_container == expected\_) \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{2439 }
\DoxyCodeLine{2440     ::std::ostream* \textcolor{keyword}{const} os = listener-\/>stream();}
\DoxyCodeLine{2441     \textcolor{keywordflow}{if} (os != \textcolor{keyword}{nullptr}) \{}
\DoxyCodeLine{2442       \textcolor{comment}{// Something is different. Check for extra values first.}}
\DoxyCodeLine{2443       \textcolor{keywordtype}{bool} printed\_header = \textcolor{keyword}{false};}
\DoxyCodeLine{2444       \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} it = lhs\_stl\_container.begin(); it != lhs\_stl\_container.end();}
\DoxyCodeLine{2445            ++it) \{}
\DoxyCodeLine{2446         \textcolor{keywordflow}{if} (internal::ArrayAwareFind(expected\_.begin(), expected\_.end(), *it) ==}
\DoxyCodeLine{2447             expected\_.end()) \{}
\DoxyCodeLine{2448           \textcolor{keywordflow}{if} (printed\_header) \{}
\DoxyCodeLine{2449             *os << \textcolor{stringliteral}{"{}, "{}};}
\DoxyCodeLine{2450           \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{2451             *os << \textcolor{stringliteral}{"{}which has these unexpected elements: "{}};}
\DoxyCodeLine{2452             printed\_header = \textcolor{keyword}{true};}
\DoxyCodeLine{2453           \}}
\DoxyCodeLine{2454           UniversalPrint(*it, os);}
\DoxyCodeLine{2455         \}}
\DoxyCodeLine{2456       \}}
\DoxyCodeLine{2457 }
\DoxyCodeLine{2458       \textcolor{comment}{// Now check for missing values.}}
\DoxyCodeLine{2459       \textcolor{keywordtype}{bool} printed\_header2 = \textcolor{keyword}{false};}
\DoxyCodeLine{2460       \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} it = expected\_.begin(); it != expected\_.end(); ++it) \{}
\DoxyCodeLine{2461         \textcolor{keywordflow}{if} (internal::ArrayAwareFind(lhs\_stl\_container.begin(),}
\DoxyCodeLine{2462                                      lhs\_stl\_container.end(),}
\DoxyCodeLine{2463                                      *it) == lhs\_stl\_container.end()) \{}
\DoxyCodeLine{2464           \textcolor{keywordflow}{if} (printed\_header2) \{}
\DoxyCodeLine{2465             *os << \textcolor{stringliteral}{"{}, "{}};}
\DoxyCodeLine{2466           \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{2467             *os << (printed\_header ? \textcolor{stringliteral}{"{},\(\backslash\)nand"{}} : \textcolor{stringliteral}{"{}which"{}})}
\DoxyCodeLine{2468                 << \textcolor{stringliteral}{"{} doesn't have these expected elements: "{}};}
\DoxyCodeLine{2469             printed\_header2 = \textcolor{keyword}{true};}
\DoxyCodeLine{2470           \}}
\DoxyCodeLine{2471           UniversalPrint(*it, os);}
\DoxyCodeLine{2472         \}}
\DoxyCodeLine{2473       \}}
\DoxyCodeLine{2474     \}}
\DoxyCodeLine{2475 }
\DoxyCodeLine{2476     \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{2477   \}}
\DoxyCodeLine{2478 }
\DoxyCodeLine{2479  \textcolor{keyword}{private}:}
\DoxyCodeLine{2480   \textcolor{keyword}{const} StlContainer expected\_;}
\DoxyCodeLine{2481 \};}
\DoxyCodeLine{2482 }
\DoxyCodeLine{2483 \textcolor{comment}{// A comparator functor that uses the < operator to compare two values.}}
\DoxyCodeLine{2484 \textcolor{keyword}{struct }LessComparator \{}
\DoxyCodeLine{2485   \textcolor{keyword}{template} <\textcolor{keyword}{typename} T, \textcolor{keyword}{typename} U>}
\DoxyCodeLine{2486   \textcolor{keywordtype}{bool} operator()(\textcolor{keyword}{const} T\& lhs, \textcolor{keyword}{const} U\& rhs)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{2487     \textcolor{keywordflow}{return} lhs < rhs;}
\DoxyCodeLine{2488   \}}
\DoxyCodeLine{2489 \};}
\DoxyCodeLine{2490 }
\DoxyCodeLine{2491 \textcolor{comment}{// Implements WhenSortedBy(comparator, container\_matcher).}}
\DoxyCodeLine{2492 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Comparator, \textcolor{keyword}{typename} ContainerMatcher>}
\DoxyCodeLine{2493 \textcolor{keyword}{class }WhenSortedByMatcher \{}
\DoxyCodeLine{2494  \textcolor{keyword}{public}:}
\DoxyCodeLine{2495   WhenSortedByMatcher(\textcolor{keyword}{const} Comparator\& comparator,}
\DoxyCodeLine{2496                       \textcolor{keyword}{const} ContainerMatcher\& matcher)}
\DoxyCodeLine{2497       : comparator\_(comparator), matcher\_(matcher) \{\}}
\DoxyCodeLine{2498 }
\DoxyCodeLine{2499   \textcolor{keyword}{template} <\textcolor{keyword}{typename} LhsContainer>}
\DoxyCodeLine{2500   \textcolor{keyword}{operator} Matcher<LhsContainer>()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{2501     \textcolor{keywordflow}{return} MakeMatcher(\textcolor{keyword}{new} Impl<LhsContainer>(comparator\_, matcher\_));}
\DoxyCodeLine{2502   \}}
\DoxyCodeLine{2503 }
\DoxyCodeLine{2504   \textcolor{keyword}{template} <\textcolor{keyword}{typename} LhsContainer>}
\DoxyCodeLine{2505   \textcolor{keyword}{class }Impl : \textcolor{keyword}{public} MatcherInterface<LhsContainer> \{}
\DoxyCodeLine{2506    \textcolor{keyword}{public}:}
\DoxyCodeLine{2507     \textcolor{keyword}{typedef} internal::StlContainerView<GTEST\_REMOVE\_REFERENCE\_AND\_CONST\_(}
\DoxyCodeLine{2508         LhsContainer)>}
\DoxyCodeLine{2509         LhsView;}
\DoxyCodeLine{2510     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} LhsView::type LhsStlContainer;}
\DoxyCodeLine{2511     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} LhsView::const\_reference LhsStlContainerReference;}
\DoxyCodeLine{2512     \textcolor{comment}{// Transforms std::pair<const Key, Value> into std::pair<Key, Value>}}
\DoxyCodeLine{2513     \textcolor{comment}{// so that we can match associative containers.}}
\DoxyCodeLine{2514     \textcolor{keyword}{typedef}}
\DoxyCodeLine{2515         \textcolor{keyword}{typename} RemoveConstFromKey<typename LhsStlContainer::value\_type>::type}
\DoxyCodeLine{2516             LhsValue;}
\DoxyCodeLine{2517 }
\DoxyCodeLine{2518     Impl(\textcolor{keyword}{const} Comparator\& comparator, \textcolor{keyword}{const} ContainerMatcher\& matcher)}
\DoxyCodeLine{2519         : comparator\_(comparator), matcher\_(matcher) \{\}}
\DoxyCodeLine{2520 }
\DoxyCodeLine{2521     \textcolor{keywordtype}{void} DescribeTo(::std::ostream* os)\textcolor{keyword}{ const override }\{}
\DoxyCodeLine{2522       *os << \textcolor{stringliteral}{"{}(when sorted) "{}};}
\DoxyCodeLine{2523       matcher\_.DescribeTo(os);}
\DoxyCodeLine{2524     \}}
\DoxyCodeLine{2525 }
\DoxyCodeLine{2526     \textcolor{keywordtype}{void} DescribeNegationTo(::std::ostream* os)\textcolor{keyword}{ const override }\{}
\DoxyCodeLine{2527       *os << \textcolor{stringliteral}{"{}(when sorted) "{}};}
\DoxyCodeLine{2528       matcher\_.DescribeNegationTo(os);}
\DoxyCodeLine{2529     \}}
\DoxyCodeLine{2530 }
\DoxyCodeLine{2531     \textcolor{keywordtype}{bool} MatchAndExplain(LhsContainer lhs,}
\DoxyCodeLine{2532                          MatchResultListener* listener)\textcolor{keyword}{ const override }\{}
\DoxyCodeLine{2533       LhsStlContainerReference lhs\_stl\_container = LhsView::ConstReference(lhs);}
\DoxyCodeLine{2534       ::std::vector<LhsValue> sorted\_container(lhs\_stl\_container.begin(),}
\DoxyCodeLine{2535                                                lhs\_stl\_container.end());}
\DoxyCodeLine{2536       ::std::sort(sorted\_container.begin(), sorted\_container.end(),}
\DoxyCodeLine{2537                   comparator\_);}
\DoxyCodeLine{2538 }
\DoxyCodeLine{2539       \textcolor{keywordflow}{if} (!listener-\/>IsInterested()) \{}
\DoxyCodeLine{2540         \textcolor{comment}{// If the listener is not interested, we do not need to}}
\DoxyCodeLine{2541         \textcolor{comment}{// construct the inner explanation.}}
\DoxyCodeLine{2542         \textcolor{keywordflow}{return} matcher\_.Matches(sorted\_container);}
\DoxyCodeLine{2543       \}}
\DoxyCodeLine{2544 }
\DoxyCodeLine{2545       *listener << \textcolor{stringliteral}{"{}which is "{}};}
\DoxyCodeLine{2546       UniversalPrint(sorted\_container, listener-\/>stream());}
\DoxyCodeLine{2547       *listener << \textcolor{stringliteral}{"{} when sorted"{}};}
\DoxyCodeLine{2548 }
\DoxyCodeLine{2549       StringMatchResultListener inner\_listener;}
\DoxyCodeLine{2550       \textcolor{keyword}{const} \textcolor{keywordtype}{bool} match =}
\DoxyCodeLine{2551           matcher\_.MatchAndExplain(sorted\_container, \&inner\_listener);}
\DoxyCodeLine{2552       PrintIfNotEmpty(inner\_listener.str(), listener-\/>stream());}
\DoxyCodeLine{2553       \textcolor{keywordflow}{return} match;}
\DoxyCodeLine{2554     \}}
\DoxyCodeLine{2555 }
\DoxyCodeLine{2556    \textcolor{keyword}{private}:}
\DoxyCodeLine{2557     \textcolor{keyword}{const} Comparator comparator\_;}
\DoxyCodeLine{2558     \textcolor{keyword}{const} Matcher<const ::std::vector<LhsValue>\&> matcher\_;}
\DoxyCodeLine{2559 }
\DoxyCodeLine{2560     Impl(\textcolor{keyword}{const} Impl\&) = \textcolor{keyword}{delete};}
\DoxyCodeLine{2561     Impl\& operator=(\textcolor{keyword}{const} Impl\&) = \textcolor{keyword}{delete};}
\DoxyCodeLine{2562   \};}
\DoxyCodeLine{2563 }
\DoxyCodeLine{2564  \textcolor{keyword}{private}:}
\DoxyCodeLine{2565   \textcolor{keyword}{const} Comparator comparator\_;}
\DoxyCodeLine{2566   \textcolor{keyword}{const} ContainerMatcher matcher\_;}
\DoxyCodeLine{2567 \};}
\DoxyCodeLine{2568 }
\DoxyCodeLine{2569 \textcolor{comment}{// Implements Pointwise(tuple\_matcher, rhs\_container).  tuple\_matcher}}
\DoxyCodeLine{2570 \textcolor{comment}{// must be able to be safely cast to Matcher<std::tuple<const T1\&, const}}
\DoxyCodeLine{2571 \textcolor{comment}{// T2\&> >, where T1 and T2 are the types of elements in the LHS}}
\DoxyCodeLine{2572 \textcolor{comment}{// container and the RHS container respectively.}}
\DoxyCodeLine{2573 \textcolor{keyword}{template} <\textcolor{keyword}{typename} TupleMatcher, \textcolor{keyword}{typename} RhsContainer>}
\DoxyCodeLine{2574 \textcolor{keyword}{class }PointwiseMatcher \{}
\DoxyCodeLine{2575   \textcolor{keyword}{static\_assert}(}
\DoxyCodeLine{2576       !IsHashTable<GTEST\_REMOVE\_REFERENCE\_AND\_CONST\_(RhsContainer)>::value,}
\DoxyCodeLine{2577       \textcolor{stringliteral}{"{}use UnorderedPointwise with hash tables"{}});}
\DoxyCodeLine{2578 }
\DoxyCodeLine{2579  \textcolor{keyword}{public}:}
\DoxyCodeLine{2580   \textcolor{keyword}{typedef} internal::StlContainerView<RhsContainer> RhsView;}
\DoxyCodeLine{2581   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} RhsView::type RhsStlContainer;}
\DoxyCodeLine{2582   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} RhsStlContainer::value\_type RhsValue;}
\DoxyCodeLine{2583 }
\DoxyCodeLine{2584   \textcolor{keyword}{static\_assert}(!std::is\_const<RhsContainer>::value,}
\DoxyCodeLine{2585                 \textcolor{stringliteral}{"{}RhsContainer type must not be const"{}});}
\DoxyCodeLine{2586   \textcolor{keyword}{static\_assert}(!std::is\_reference<RhsContainer>::value,}
\DoxyCodeLine{2587                 \textcolor{stringliteral}{"{}RhsContainer type must not be a reference"{}});}
\DoxyCodeLine{2588 }
\DoxyCodeLine{2589   \textcolor{comment}{// Like ContainerEq, we make a copy of rhs in case the elements in}}
\DoxyCodeLine{2590   \textcolor{comment}{// it are modified after this matcher is created.}}
\DoxyCodeLine{2591   PointwiseMatcher(\textcolor{keyword}{const} TupleMatcher\& tuple\_matcher, \textcolor{keyword}{const} RhsContainer\& rhs)}
\DoxyCodeLine{2592       : tuple\_matcher\_(tuple\_matcher), rhs\_(RhsView::Copy(rhs)) \{\}}
\DoxyCodeLine{2593 }
\DoxyCodeLine{2594   \textcolor{keyword}{template} <\textcolor{keyword}{typename} LhsContainer>}
\DoxyCodeLine{2595   \textcolor{keyword}{operator} Matcher<LhsContainer>()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{2596     \textcolor{keyword}{static\_assert}(}
\DoxyCodeLine{2597         !IsHashTable<GTEST\_REMOVE\_REFERENCE\_AND\_CONST\_(LhsContainer)>::value,}
\DoxyCodeLine{2598         \textcolor{stringliteral}{"{}use UnorderedPointwise with hash tables"{}});}
\DoxyCodeLine{2599 }
\DoxyCodeLine{2600     \textcolor{keywordflow}{return} Matcher<LhsContainer>(}
\DoxyCodeLine{2601         \textcolor{keyword}{new} Impl<const LhsContainer\&>(tuple\_matcher\_, rhs\_));}
\DoxyCodeLine{2602   \}}
\DoxyCodeLine{2603 }
\DoxyCodeLine{2604   \textcolor{keyword}{template} <\textcolor{keyword}{typename} LhsContainer>}
\DoxyCodeLine{2605   \textcolor{keyword}{class }Impl : \textcolor{keyword}{public} MatcherInterface<LhsContainer> \{}
\DoxyCodeLine{2606    \textcolor{keyword}{public}:}
\DoxyCodeLine{2607     \textcolor{keyword}{typedef} internal::StlContainerView<GTEST\_REMOVE\_REFERENCE\_AND\_CONST\_(}
\DoxyCodeLine{2608         LhsContainer)>}
\DoxyCodeLine{2609         LhsView;}
\DoxyCodeLine{2610     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} LhsView::type LhsStlContainer;}
\DoxyCodeLine{2611     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} LhsView::const\_reference LhsStlContainerReference;}
\DoxyCodeLine{2612     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} LhsStlContainer::value\_type LhsValue;}
\DoxyCodeLine{2613     \textcolor{comment}{// We pass the LHS value and the RHS value to the inner matcher by}}
\DoxyCodeLine{2614     \textcolor{comment}{// reference, as they may be expensive to copy.  We must use tuple}}
\DoxyCodeLine{2615     \textcolor{comment}{// instead of pair here, as a pair cannot hold references (C++ 98,}}
\DoxyCodeLine{2616     \textcolor{comment}{// 20.2.2 [lib.pairs]).}}
\DoxyCodeLine{2617     typedef ::std::tuple<const LhsValue\&, const RhsValue\&> InnerMatcherArg;}
\DoxyCodeLine{2618 }
\DoxyCodeLine{2619     Impl(\textcolor{keyword}{const} TupleMatcher\& tuple\_matcher, \textcolor{keyword}{const} RhsStlContainer\& rhs)}
\DoxyCodeLine{2620         \textcolor{comment}{// mono\_tuple\_matcher\_ holds a monomorphic version of the tuple matcher.}}
\DoxyCodeLine{2621         : mono\_tuple\_matcher\_(SafeMatcherCast<InnerMatcherArg>(tuple\_matcher)),}
\DoxyCodeLine{2622           rhs\_(rhs) \{\}}
\DoxyCodeLine{2623 }
\DoxyCodeLine{2624     \textcolor{keywordtype}{void} DescribeTo(::std::ostream* os)\textcolor{keyword}{ const override }\{}
\DoxyCodeLine{2625       *os << \textcolor{stringliteral}{"{}contains "{}} << rhs\_.size()}
\DoxyCodeLine{2626           << \textcolor{stringliteral}{"{} values, where each value and its corresponding value in "{}};}
\DoxyCodeLine{2627       UniversalPrinter<RhsStlContainer>::Print(rhs\_, os);}
\DoxyCodeLine{2628       *os << \textcolor{stringliteral}{"{} "{}};}
\DoxyCodeLine{2629       mono\_tuple\_matcher\_.DescribeTo(os);}
\DoxyCodeLine{2630     \}}
\DoxyCodeLine{2631     \textcolor{keywordtype}{void} DescribeNegationTo(::std::ostream* os)\textcolor{keyword}{ const override }\{}
\DoxyCodeLine{2632       *os << \textcolor{stringliteral}{"{}doesn't contain exactly "{}} << rhs\_.size()}
\DoxyCodeLine{2633           << \textcolor{stringliteral}{"{} values, or contains a value x at some index i"{}}}
\DoxyCodeLine{2634           << \textcolor{stringliteral}{"{} where x and the i-\/th value of "{}};}
\DoxyCodeLine{2635       UniversalPrint(rhs\_, os);}
\DoxyCodeLine{2636       *os << \textcolor{stringliteral}{"{} "{}};}
\DoxyCodeLine{2637       mono\_tuple\_matcher\_.DescribeNegationTo(os);}
\DoxyCodeLine{2638     \}}
\DoxyCodeLine{2639 }
\DoxyCodeLine{2640     \textcolor{keywordtype}{bool} MatchAndExplain(LhsContainer lhs,}
\DoxyCodeLine{2641                          MatchResultListener* listener)\textcolor{keyword}{ const override }\{}
\DoxyCodeLine{2642       LhsStlContainerReference lhs\_stl\_container = LhsView::ConstReference(lhs);}
\DoxyCodeLine{2643       \textcolor{keyword}{const} \textcolor{keywordtype}{size\_t} actual\_size = lhs\_stl\_container.size();}
\DoxyCodeLine{2644       \textcolor{keywordflow}{if} (actual\_size != rhs\_.size()) \{}
\DoxyCodeLine{2645         *listener << \textcolor{stringliteral}{"{}which contains "{}} << actual\_size << \textcolor{stringliteral}{"{} values"{}};}
\DoxyCodeLine{2646         \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{2647       \}}
\DoxyCodeLine{2648 }
\DoxyCodeLine{2649       \textcolor{keyword}{auto} left = lhs\_stl\_container.begin();}
\DoxyCodeLine{2650       \textcolor{keyword}{auto} right = rhs\_.begin();}
\DoxyCodeLine{2651       \textcolor{keywordflow}{for} (\textcolor{keywordtype}{size\_t} i = 0; i != actual\_size; ++i, ++left, ++right) \{}
\DoxyCodeLine{2652         \textcolor{keywordflow}{if} (listener-\/>IsInterested()) \{}
\DoxyCodeLine{2653           StringMatchResultListener inner\_listener;}
\DoxyCodeLine{2654           \textcolor{comment}{// Create InnerMatcherArg as a temporarily object to avoid it outlives}}
\DoxyCodeLine{2655           \textcolor{comment}{// *left and *right. Dereference or the conversion to `const T\&` may}}
\DoxyCodeLine{2656           \textcolor{comment}{// return temp objects, e.g. for vector<bool>.}}
\DoxyCodeLine{2657           \textcolor{keywordflow}{if} (!mono\_tuple\_matcher\_.MatchAndExplain(}
\DoxyCodeLine{2658                   InnerMatcherArg(ImplicitCast\_<const LhsValue\&>(*left),}
\DoxyCodeLine{2659                                   ImplicitCast\_<const RhsValue\&>(*right)),}
\DoxyCodeLine{2660                   \&inner\_listener)) \{}
\DoxyCodeLine{2661             *listener << \textcolor{stringliteral}{"{}where the value pair ("{}};}
\DoxyCodeLine{2662             UniversalPrint(*left, listener-\/>stream());}
\DoxyCodeLine{2663             *listener << \textcolor{stringliteral}{"{}, "{}};}
\DoxyCodeLine{2664             UniversalPrint(*right, listener-\/>stream());}
\DoxyCodeLine{2665             *listener << \textcolor{stringliteral}{"{}) at index \#"{}} << i << \textcolor{stringliteral}{"{} don't match"{}};}
\DoxyCodeLine{2666             PrintIfNotEmpty(inner\_listener.str(), listener-\/>stream());}
\DoxyCodeLine{2667             \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{2668           \}}
\DoxyCodeLine{2669         \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{2670           \textcolor{keywordflow}{if} (!mono\_tuple\_matcher\_.Matches(}
\DoxyCodeLine{2671                   InnerMatcherArg(ImplicitCast\_<const LhsValue\&>(*left),}
\DoxyCodeLine{2672                                   ImplicitCast\_<const RhsValue\&>(*right))))}
\DoxyCodeLine{2673             \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{2674         \}}
\DoxyCodeLine{2675       \}}
\DoxyCodeLine{2676 }
\DoxyCodeLine{2677       \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{2678     \}}
\DoxyCodeLine{2679 }
\DoxyCodeLine{2680    \textcolor{keyword}{private}:}
\DoxyCodeLine{2681     \textcolor{keyword}{const} Matcher<InnerMatcherArg> mono\_tuple\_matcher\_;}
\DoxyCodeLine{2682     \textcolor{keyword}{const} RhsStlContainer rhs\_;}
\DoxyCodeLine{2683   \};}
\DoxyCodeLine{2684 }
\DoxyCodeLine{2685  \textcolor{keyword}{private}:}
\DoxyCodeLine{2686   \textcolor{keyword}{const} TupleMatcher tuple\_matcher\_;}
\DoxyCodeLine{2687   \textcolor{keyword}{const} RhsStlContainer rhs\_;}
\DoxyCodeLine{2688 \};}
\DoxyCodeLine{2689 }
\DoxyCodeLine{2690 \textcolor{comment}{// Holds the logic common to ContainsMatcherImpl and EachMatcherImpl.}}
\DoxyCodeLine{2691 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Container>}
\DoxyCodeLine{2692 \textcolor{keyword}{class }QuantifierMatcherImpl : \textcolor{keyword}{public} MatcherInterface<Container> \{}
\DoxyCodeLine{2693  \textcolor{keyword}{public}:}
\DoxyCodeLine{2694   \textcolor{keyword}{typedef} GTEST\_REMOVE\_REFERENCE\_AND\_CONST\_(Container) RawContainer;}
\DoxyCodeLine{2695   \textcolor{keyword}{typedef} StlContainerView<RawContainer> View;}
\DoxyCodeLine{2696   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} View::type StlContainer;}
\DoxyCodeLine{2697   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} View::const\_reference StlContainerReference;}
\DoxyCodeLine{2698   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} StlContainer::value\_type Element;}
\DoxyCodeLine{2699 }
\DoxyCodeLine{2700   \textcolor{keyword}{template} <\textcolor{keyword}{typename} InnerMatcher>}
\DoxyCodeLine{2701   \textcolor{keyword}{explicit} QuantifierMatcherImpl(InnerMatcher inner\_matcher)}
\DoxyCodeLine{2702       : inner\_matcher\_(}
\DoxyCodeLine{2703             testing::SafeMatcherCast<const Element\&>(inner\_matcher)) \{\}}
\DoxyCodeLine{2704 }
\DoxyCodeLine{2705   \textcolor{comment}{// Checks whether:}}
\DoxyCodeLine{2706   \textcolor{comment}{// * All elements in the container match, if all\_elements\_should\_match.}}
\DoxyCodeLine{2707   \textcolor{comment}{// * Any element in the container matches, if !all\_elements\_should\_match.}}
\DoxyCodeLine{2708   \textcolor{keywordtype}{bool} MatchAndExplainImpl(\textcolor{keywordtype}{bool} all\_elements\_should\_match, Container container,}
\DoxyCodeLine{2709                            MatchResultListener* listener)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{2710     StlContainerReference stl\_container = View::ConstReference(container);}
\DoxyCodeLine{2711     \textcolor{keywordtype}{size\_t} i = 0;}
\DoxyCodeLine{2712     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} it = stl\_container.begin(); it != stl\_container.end();}
\DoxyCodeLine{2713          ++it, ++i) \{}
\DoxyCodeLine{2714       StringMatchResultListener inner\_listener;}
\DoxyCodeLine{2715       \textcolor{keyword}{const} \textcolor{keywordtype}{bool} matches = inner\_matcher\_.MatchAndExplain(*it, \&inner\_listener);}
\DoxyCodeLine{2716 }
\DoxyCodeLine{2717       \textcolor{keywordflow}{if} (matches != all\_elements\_should\_match) \{}
\DoxyCodeLine{2718         *listener << \textcolor{stringliteral}{"{}whose element \#"{}} << i}
\DoxyCodeLine{2719                   << (matches ? \textcolor{stringliteral}{"{} matches"{}} : \textcolor{stringliteral}{"{} doesn't match"{}});}
\DoxyCodeLine{2720         PrintIfNotEmpty(inner\_listener.str(), listener-\/>stream());}
\DoxyCodeLine{2721         \textcolor{keywordflow}{return} !all\_elements\_should\_match;}
\DoxyCodeLine{2722       \}}
\DoxyCodeLine{2723     \}}
\DoxyCodeLine{2724     \textcolor{keywordflow}{return} all\_elements\_should\_match;}
\DoxyCodeLine{2725   \}}
\DoxyCodeLine{2726 }
\DoxyCodeLine{2727   \textcolor{keywordtype}{bool} MatchAndExplainImpl(\textcolor{keyword}{const} Matcher<size\_t>\& count\_matcher,}
\DoxyCodeLine{2728                            Container container,}
\DoxyCodeLine{2729                            MatchResultListener* listener)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{2730     StlContainerReference stl\_container = View::ConstReference(container);}
\DoxyCodeLine{2731     \textcolor{keywordtype}{size\_t} i = 0;}
\DoxyCodeLine{2732     std::vector<size\_t> match\_elements;}
\DoxyCodeLine{2733     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} it = stl\_container.begin(); it != stl\_container.end();}
\DoxyCodeLine{2734          ++it, ++i) \{}
\DoxyCodeLine{2735       StringMatchResultListener inner\_listener;}
\DoxyCodeLine{2736       \textcolor{keyword}{const} \textcolor{keywordtype}{bool} matches = inner\_matcher\_.MatchAndExplain(*it, \&inner\_listener);}
\DoxyCodeLine{2737       \textcolor{keywordflow}{if} (matches) \{}
\DoxyCodeLine{2738         match\_elements.push\_back(i);}
\DoxyCodeLine{2739       \}}
\DoxyCodeLine{2740     \}}
\DoxyCodeLine{2741     \textcolor{keywordflow}{if} (listener-\/>IsInterested()) \{}
\DoxyCodeLine{2742       \textcolor{keywordflow}{if} (match\_elements.empty()) \{}
\DoxyCodeLine{2743         *listener << \textcolor{stringliteral}{"{}has no element that matches"{}};}
\DoxyCodeLine{2744       \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (match\_elements.size() == 1) \{}
\DoxyCodeLine{2745         *listener << \textcolor{stringliteral}{"{}whose element \#"{}} << match\_elements[0] << \textcolor{stringliteral}{"{} matches"{}};}
\DoxyCodeLine{2746       \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{2747         *listener << \textcolor{stringliteral}{"{}whose elements ("{}};}
\DoxyCodeLine{2748         std::string sep = \textcolor{stringliteral}{"{}"{}};}
\DoxyCodeLine{2749         \textcolor{keywordflow}{for} (\textcolor{keywordtype}{size\_t} e : match\_elements) \{}
\DoxyCodeLine{2750           *listener << sep << e;}
\DoxyCodeLine{2751           sep = \textcolor{stringliteral}{"{}, "{}};}
\DoxyCodeLine{2752         \}}
\DoxyCodeLine{2753         *listener << \textcolor{stringliteral}{"{}) match"{}};}
\DoxyCodeLine{2754       \}}
\DoxyCodeLine{2755     \}}
\DoxyCodeLine{2756     StringMatchResultListener count\_listener;}
\DoxyCodeLine{2757     \textcolor{keywordflow}{if} (count\_matcher.MatchAndExplain(match\_elements.size(), \&count\_listener)) \{}
\DoxyCodeLine{2758       *listener << \textcolor{stringliteral}{"{} and whose match quantity of "{}} << match\_elements.size()}
\DoxyCodeLine{2759                 << \textcolor{stringliteral}{"{} matches"{}};}
\DoxyCodeLine{2760       PrintIfNotEmpty(count\_listener.str(), listener-\/>stream());}
\DoxyCodeLine{2761       \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{2762     \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{2763       \textcolor{keywordflow}{if} (match\_elements.empty()) \{}
\DoxyCodeLine{2764         *listener << \textcolor{stringliteral}{"{} and"{}};}
\DoxyCodeLine{2765       \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{2766         *listener << \textcolor{stringliteral}{"{} but"{}};}
\DoxyCodeLine{2767       \}}
\DoxyCodeLine{2768       *listener << \textcolor{stringliteral}{"{} whose match quantity of "{}} << match\_elements.size()}
\DoxyCodeLine{2769                 << \textcolor{stringliteral}{"{} does not match"{}};}
\DoxyCodeLine{2770       PrintIfNotEmpty(count\_listener.str(), listener-\/>stream());}
\DoxyCodeLine{2771       \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{2772     \}}
\DoxyCodeLine{2773   \}}
\DoxyCodeLine{2774 }
\DoxyCodeLine{2775  \textcolor{keyword}{protected}:}
\DoxyCodeLine{2776   \textcolor{keyword}{const} Matcher<const Element\&> inner\_matcher\_;}
\DoxyCodeLine{2777 \};}
\DoxyCodeLine{2778 }
\DoxyCodeLine{2779 \textcolor{comment}{// Implements Contains(element\_matcher) for the given argument type Container.}}
\DoxyCodeLine{2780 \textcolor{comment}{// Symmetric to EachMatcherImpl.}}
\DoxyCodeLine{2781 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Container>}
\DoxyCodeLine{2782 \textcolor{keyword}{class }ContainsMatcherImpl : \textcolor{keyword}{public} QuantifierMatcherImpl<Container> \{}
\DoxyCodeLine{2783  \textcolor{keyword}{public}:}
\DoxyCodeLine{2784   \textcolor{keyword}{template} <\textcolor{keyword}{typename} InnerMatcher>}
\DoxyCodeLine{2785   \textcolor{keyword}{explicit} ContainsMatcherImpl(InnerMatcher inner\_matcher)}
\DoxyCodeLine{2786       : QuantifierMatcherImpl<Container>(inner\_matcher) \{\}}
\DoxyCodeLine{2787 }
\DoxyCodeLine{2788   \textcolor{comment}{// Describes what this matcher does.}}
\DoxyCodeLine{2789   \textcolor{keywordtype}{void} DescribeTo(::std::ostream* os)\textcolor{keyword}{ const override }\{}
\DoxyCodeLine{2790     *os << \textcolor{stringliteral}{"{}contains at least one element that "{}};}
\DoxyCodeLine{2791     this-\/>inner\_matcher\_.DescribeTo(os);}
\DoxyCodeLine{2792   \}}
\DoxyCodeLine{2793 }
\DoxyCodeLine{2794   \textcolor{keywordtype}{void} DescribeNegationTo(::std::ostream* os)\textcolor{keyword}{ const override }\{}
\DoxyCodeLine{2795     *os << \textcolor{stringliteral}{"{}doesn't contain any element that "{}};}
\DoxyCodeLine{2796     this-\/>inner\_matcher\_.DescribeTo(os);}
\DoxyCodeLine{2797   \}}
\DoxyCodeLine{2798 }
\DoxyCodeLine{2799   \textcolor{keywordtype}{bool} MatchAndExplain(Container container,}
\DoxyCodeLine{2800                        MatchResultListener* listener)\textcolor{keyword}{ const override }\{}
\DoxyCodeLine{2801     \textcolor{keywordflow}{return} this-\/>MatchAndExplainImpl(\textcolor{keyword}{false}, container, listener);}
\DoxyCodeLine{2802   \}}
\DoxyCodeLine{2803 \};}
\DoxyCodeLine{2804 }
\DoxyCodeLine{2805 \textcolor{comment}{// Implements Each(element\_matcher) for the given argument type Container.}}
\DoxyCodeLine{2806 \textcolor{comment}{// Symmetric to ContainsMatcherImpl.}}
\DoxyCodeLine{2807 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Container>}
\DoxyCodeLine{2808 \textcolor{keyword}{class }EachMatcherImpl : \textcolor{keyword}{public} QuantifierMatcherImpl<Container> \{}
\DoxyCodeLine{2809  \textcolor{keyword}{public}:}
\DoxyCodeLine{2810   \textcolor{keyword}{template} <\textcolor{keyword}{typename} InnerMatcher>}
\DoxyCodeLine{2811   \textcolor{keyword}{explicit} EachMatcherImpl(InnerMatcher inner\_matcher)}
\DoxyCodeLine{2812       : QuantifierMatcherImpl<Container>(inner\_matcher) \{\}}
\DoxyCodeLine{2813 }
\DoxyCodeLine{2814   \textcolor{comment}{// Describes what this matcher does.}}
\DoxyCodeLine{2815   \textcolor{keywordtype}{void} DescribeTo(::std::ostream* os)\textcolor{keyword}{ const override }\{}
\DoxyCodeLine{2816     *os << \textcolor{stringliteral}{"{}only contains elements that "{}};}
\DoxyCodeLine{2817     this-\/>inner\_matcher\_.DescribeTo(os);}
\DoxyCodeLine{2818   \}}
\DoxyCodeLine{2819 }
\DoxyCodeLine{2820   \textcolor{keywordtype}{void} DescribeNegationTo(::std::ostream* os)\textcolor{keyword}{ const override }\{}
\DoxyCodeLine{2821     *os << \textcolor{stringliteral}{"{}contains some element that "{}};}
\DoxyCodeLine{2822     this-\/>inner\_matcher\_.DescribeNegationTo(os);}
\DoxyCodeLine{2823   \}}
\DoxyCodeLine{2824 }
\DoxyCodeLine{2825   \textcolor{keywordtype}{bool} MatchAndExplain(Container container,}
\DoxyCodeLine{2826                        MatchResultListener* listener)\textcolor{keyword}{ const override }\{}
\DoxyCodeLine{2827     \textcolor{keywordflow}{return} this-\/>MatchAndExplainImpl(\textcolor{keyword}{true}, container, listener);}
\DoxyCodeLine{2828   \}}
\DoxyCodeLine{2829 \};}
\DoxyCodeLine{2830 }
\DoxyCodeLine{2831 \textcolor{comment}{// Implements Contains(element\_matcher).Times(n) for the given argument type}}
\DoxyCodeLine{2832 \textcolor{comment}{// Container.}}
\DoxyCodeLine{2833 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Container>}
\DoxyCodeLine{2834 \textcolor{keyword}{class }ContainsTimesMatcherImpl : \textcolor{keyword}{public} QuantifierMatcherImpl<Container> \{}
\DoxyCodeLine{2835  \textcolor{keyword}{public}:}
\DoxyCodeLine{2836   \textcolor{keyword}{template} <\textcolor{keyword}{typename} InnerMatcher>}
\DoxyCodeLine{2837   \textcolor{keyword}{explicit} ContainsTimesMatcherImpl(InnerMatcher inner\_matcher,}
\DoxyCodeLine{2838                                     Matcher<size\_t> count\_matcher)}
\DoxyCodeLine{2839       : QuantifierMatcherImpl<Container>(inner\_matcher),}
\DoxyCodeLine{2840         count\_matcher\_(std::move(count\_matcher)) \{\}}
\DoxyCodeLine{2841 }
\DoxyCodeLine{2842   \textcolor{keywordtype}{void} DescribeTo(::std::ostream* os)\textcolor{keyword}{ const override }\{}
\DoxyCodeLine{2843     *os << \textcolor{stringliteral}{"{}quantity of elements that match "{}};}
\DoxyCodeLine{2844     this-\/>inner\_matcher\_.DescribeTo(os);}
\DoxyCodeLine{2845     *os << \textcolor{stringliteral}{"{} "{}};}
\DoxyCodeLine{2846     count\_matcher\_.DescribeTo(os);}
\DoxyCodeLine{2847   \}}
\DoxyCodeLine{2848 }
\DoxyCodeLine{2849   \textcolor{keywordtype}{void} DescribeNegationTo(::std::ostream* os)\textcolor{keyword}{ const override }\{}
\DoxyCodeLine{2850     *os << \textcolor{stringliteral}{"{}quantity of elements that match "{}};}
\DoxyCodeLine{2851     this-\/>inner\_matcher\_.DescribeTo(os);}
\DoxyCodeLine{2852     *os << \textcolor{stringliteral}{"{} "{}};}
\DoxyCodeLine{2853     count\_matcher\_.DescribeNegationTo(os);}
\DoxyCodeLine{2854   \}}
\DoxyCodeLine{2855 }
\DoxyCodeLine{2856   \textcolor{keywordtype}{bool} MatchAndExplain(Container container,}
\DoxyCodeLine{2857                        MatchResultListener* listener)\textcolor{keyword}{ const override }\{}
\DoxyCodeLine{2858     \textcolor{keywordflow}{return} this-\/>MatchAndExplainImpl(count\_matcher\_, container, listener);}
\DoxyCodeLine{2859   \}}
\DoxyCodeLine{2860 }
\DoxyCodeLine{2861  \textcolor{keyword}{private}:}
\DoxyCodeLine{2862   \textcolor{keyword}{const} Matcher<size\_t> count\_matcher\_;}
\DoxyCodeLine{2863 \};}
\DoxyCodeLine{2864 }
\DoxyCodeLine{2865 \textcolor{comment}{// Implements polymorphic Contains(element\_matcher).Times(n).}}
\DoxyCodeLine{2866 \textcolor{keyword}{template} <\textcolor{keyword}{typename} M>}
\DoxyCodeLine{2867 \textcolor{keyword}{class }ContainsTimesMatcher \{}
\DoxyCodeLine{2868  \textcolor{keyword}{public}:}
\DoxyCodeLine{2869   \textcolor{keyword}{explicit} ContainsTimesMatcher(M m, Matcher<size\_t> count\_matcher)}
\DoxyCodeLine{2870       : inner\_matcher\_(m), count\_matcher\_(std::move(count\_matcher)) \{\}}
\DoxyCodeLine{2871 }
\DoxyCodeLine{2872   \textcolor{keyword}{template} <\textcolor{keyword}{typename} Container>}
\DoxyCodeLine{2873   \textcolor{keyword}{operator} Matcher<Container>()\textcolor{keyword}{ const }\{  \textcolor{comment}{// NOLINT}}
\DoxyCodeLine{2874     \textcolor{keywordflow}{return} Matcher<Container>(\textcolor{keyword}{new} ContainsTimesMatcherImpl<const Container\&>(}
\DoxyCodeLine{2875         inner\_matcher\_, count\_matcher\_));}
\DoxyCodeLine{2876   \}}
\DoxyCodeLine{2877 }
\DoxyCodeLine{2878  \textcolor{keyword}{private}:}
\DoxyCodeLine{2879   \textcolor{keyword}{const} M inner\_matcher\_;}
\DoxyCodeLine{2880   \textcolor{keyword}{const} Matcher<size\_t> count\_matcher\_;}
\DoxyCodeLine{2881 \};}
\DoxyCodeLine{2882 }
\DoxyCodeLine{2883 \textcolor{comment}{// Implements polymorphic Contains(element\_matcher).}}
\DoxyCodeLine{2884 \textcolor{keyword}{template} <\textcolor{keyword}{typename} M>}
\DoxyCodeLine{2885 \textcolor{keyword}{class }ContainsMatcher \{}
\DoxyCodeLine{2886  \textcolor{keyword}{public}:}
\DoxyCodeLine{2887   \textcolor{keyword}{explicit} ContainsMatcher(M m) : inner\_matcher\_(m) \{\}}
\DoxyCodeLine{2888 }
\DoxyCodeLine{2889   \textcolor{keyword}{template} <\textcolor{keyword}{typename} Container>}
\DoxyCodeLine{2890   \textcolor{keyword}{operator} Matcher<Container>()\textcolor{keyword}{ const }\{  \textcolor{comment}{// NOLINT}}
\DoxyCodeLine{2891     \textcolor{keywordflow}{return} Matcher<Container>(}
\DoxyCodeLine{2892         \textcolor{keyword}{new} ContainsMatcherImpl<const Container\&>(inner\_matcher\_));}
\DoxyCodeLine{2893   \}}
\DoxyCodeLine{2894 }
\DoxyCodeLine{2895   ContainsTimesMatcher<M> Times(Matcher<size\_t> count\_matcher)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{2896     \textcolor{keywordflow}{return} ContainsTimesMatcher<M>(inner\_matcher\_, std::move(count\_matcher));}
\DoxyCodeLine{2897   \}}
\DoxyCodeLine{2898 }
\DoxyCodeLine{2899  \textcolor{keyword}{private}:}
\DoxyCodeLine{2900   \textcolor{keyword}{const} M inner\_matcher\_;}
\DoxyCodeLine{2901 \};}
\DoxyCodeLine{2902 }
\DoxyCodeLine{2903 \textcolor{comment}{// Implements polymorphic Each(element\_matcher).}}
\DoxyCodeLine{2904 \textcolor{keyword}{template} <\textcolor{keyword}{typename} M>}
\DoxyCodeLine{2905 \textcolor{keyword}{class }EachMatcher \{}
\DoxyCodeLine{2906  \textcolor{keyword}{public}:}
\DoxyCodeLine{2907   \textcolor{keyword}{explicit} EachMatcher(M m) : inner\_matcher\_(m) \{\}}
\DoxyCodeLine{2908 }
\DoxyCodeLine{2909   \textcolor{keyword}{template} <\textcolor{keyword}{typename} Container>}
\DoxyCodeLine{2910   \textcolor{keyword}{operator} Matcher<Container>()\textcolor{keyword}{ const }\{  \textcolor{comment}{// NOLINT}}
\DoxyCodeLine{2911     \textcolor{keywordflow}{return} Matcher<Container>(}
\DoxyCodeLine{2912         \textcolor{keyword}{new} EachMatcherImpl<const Container\&>(inner\_matcher\_));}
\DoxyCodeLine{2913   \}}
\DoxyCodeLine{2914 }
\DoxyCodeLine{2915  \textcolor{keyword}{private}:}
\DoxyCodeLine{2916   \textcolor{keyword}{const} M inner\_matcher\_;}
\DoxyCodeLine{2917 \};}
\DoxyCodeLine{2918 }
\DoxyCodeLine{2919 \textcolor{keyword}{struct }Rank1 \{\};}
\DoxyCodeLine{2920 \textcolor{keyword}{struct }Rank0 : Rank1 \{\};}
\DoxyCodeLine{2921 }
\DoxyCodeLine{2922 \textcolor{keyword}{namespace }pair\_getters \{}
\DoxyCodeLine{2923 \textcolor{keyword}{using }std::get;}
\DoxyCodeLine{2924 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{2925 \textcolor{keyword}{auto} First(T\& x, Rank1) -\/> \textcolor{keyword}{decltype}(get<0>(x)) \{  \textcolor{comment}{// NOLINT}}
\DoxyCodeLine{2926   \textcolor{keywordflow}{return} get<0>(x);}
\DoxyCodeLine{2927 \}}
\DoxyCodeLine{2928 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{2929 \textcolor{keyword}{auto} First(T\& x, Rank0) -\/> \textcolor{keyword}{decltype}((x.first)) \{  \textcolor{comment}{// NOLINT}}
\DoxyCodeLine{2930   \textcolor{keywordflow}{return} x.first;}
\DoxyCodeLine{2931 \}}
\DoxyCodeLine{2932 }
\DoxyCodeLine{2933 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{2934 \textcolor{keyword}{auto} Second(T\& x, Rank1) -\/> \textcolor{keyword}{decltype}(get<1>(x)) \{  \textcolor{comment}{// NOLINT}}
\DoxyCodeLine{2935   \textcolor{keywordflow}{return} get<1>(x);}
\DoxyCodeLine{2936 \}}
\DoxyCodeLine{2937 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{2938 \textcolor{keyword}{auto} Second(T\& x, Rank0) -\/> \textcolor{keyword}{decltype}((x.second)) \{  \textcolor{comment}{// NOLINT}}
\DoxyCodeLine{2939   \textcolor{keywordflow}{return} x.second;}
\DoxyCodeLine{2940 \}}
\DoxyCodeLine{2941 \}  \textcolor{comment}{// namespace pair\_getters}}
\DoxyCodeLine{2942 }
\DoxyCodeLine{2943 \textcolor{comment}{// Implements Key(inner\_matcher) for the given argument pair type.}}
\DoxyCodeLine{2944 \textcolor{comment}{// Key(inner\_matcher) matches an std::pair whose 'first' field matches}}
\DoxyCodeLine{2945 \textcolor{comment}{// inner\_matcher.  For example, Contains(Key(Ge(5))) can be used to match an}}
\DoxyCodeLine{2946 \textcolor{comment}{// std::map that contains at least one element whose key is >= 5.}}
\DoxyCodeLine{2947 \textcolor{keyword}{template} <\textcolor{keyword}{typename} PairType>}
\DoxyCodeLine{2948 \textcolor{keyword}{class }KeyMatcherImpl : \textcolor{keyword}{public} MatcherInterface<PairType> \{}
\DoxyCodeLine{2949  \textcolor{keyword}{public}:}
\DoxyCodeLine{2950   \textcolor{keyword}{typedef} GTEST\_REMOVE\_REFERENCE\_AND\_CONST\_(PairType) RawPairType;}
\DoxyCodeLine{2951   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} RawPairType::first\_type KeyType;}
\DoxyCodeLine{2952 }
\DoxyCodeLine{2953   \textcolor{keyword}{template} <\textcolor{keyword}{typename} InnerMatcher>}
\DoxyCodeLine{2954   \textcolor{keyword}{explicit} KeyMatcherImpl(InnerMatcher inner\_matcher)}
\DoxyCodeLine{2955       : inner\_matcher\_(}
\DoxyCodeLine{2956             testing::SafeMatcherCast<const KeyType\&>(inner\_matcher)) \{\}}
\DoxyCodeLine{2957 }
\DoxyCodeLine{2958   \textcolor{comment}{// Returns true if and only if 'key\_value.first' (the key) matches the inner}}
\DoxyCodeLine{2959   \textcolor{comment}{// matcher.}}
\DoxyCodeLine{2960   \textcolor{keywordtype}{bool} MatchAndExplain(PairType key\_value,}
\DoxyCodeLine{2961                        MatchResultListener* listener)\textcolor{keyword}{ const override }\{}
\DoxyCodeLine{2962     StringMatchResultListener inner\_listener;}
\DoxyCodeLine{2963     \textcolor{keyword}{const} \textcolor{keywordtype}{bool} match = inner\_matcher\_.MatchAndExplain(}
\DoxyCodeLine{2964         pair\_getters::First(key\_value, Rank0()), \&inner\_listener);}
\DoxyCodeLine{2965     \textcolor{keyword}{const} std::string explanation = inner\_listener.str();}
\DoxyCodeLine{2966     \textcolor{keywordflow}{if} (explanation != \textcolor{stringliteral}{"{}"{}}) \{}
\DoxyCodeLine{2967       *listener << \textcolor{stringliteral}{"{}whose first field is a value "{}} << explanation;}
\DoxyCodeLine{2968     \}}
\DoxyCodeLine{2969     \textcolor{keywordflow}{return} match;}
\DoxyCodeLine{2970   \}}
\DoxyCodeLine{2971 }
\DoxyCodeLine{2972   \textcolor{comment}{// Describes what this matcher does.}}
\DoxyCodeLine{2973   \textcolor{keywordtype}{void} DescribeTo(::std::ostream* os)\textcolor{keyword}{ const override }\{}
\DoxyCodeLine{2974     *os << \textcolor{stringliteral}{"{}has a key that "{}};}
\DoxyCodeLine{2975     inner\_matcher\_.DescribeTo(os);}
\DoxyCodeLine{2976   \}}
\DoxyCodeLine{2977 }
\DoxyCodeLine{2978   \textcolor{comment}{// Describes what the negation of this matcher does.}}
\DoxyCodeLine{2979   \textcolor{keywordtype}{void} DescribeNegationTo(::std::ostream* os)\textcolor{keyword}{ const override }\{}
\DoxyCodeLine{2980     *os << \textcolor{stringliteral}{"{}doesn't have a key that "{}};}
\DoxyCodeLine{2981     inner\_matcher\_.DescribeTo(os);}
\DoxyCodeLine{2982   \}}
\DoxyCodeLine{2983 }
\DoxyCodeLine{2984  \textcolor{keyword}{private}:}
\DoxyCodeLine{2985   \textcolor{keyword}{const} Matcher<const KeyType\&> inner\_matcher\_;}
\DoxyCodeLine{2986 \};}
\DoxyCodeLine{2987 }
\DoxyCodeLine{2988 \textcolor{comment}{// Implements polymorphic Key(matcher\_for\_key).}}
\DoxyCodeLine{2989 \textcolor{keyword}{template} <\textcolor{keyword}{typename} M>}
\DoxyCodeLine{2990 \textcolor{keyword}{class }KeyMatcher \{}
\DoxyCodeLine{2991  \textcolor{keyword}{public}:}
\DoxyCodeLine{2992   \textcolor{keyword}{explicit} KeyMatcher(M m) : matcher\_for\_key\_(m) \{\}}
\DoxyCodeLine{2993 }
\DoxyCodeLine{2994   \textcolor{keyword}{template} <\textcolor{keyword}{typename} PairType>}
\DoxyCodeLine{2995   \textcolor{keyword}{operator} Matcher<PairType>()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{2996     \textcolor{keywordflow}{return} Matcher<PairType>(}
\DoxyCodeLine{2997         \textcolor{keyword}{new} KeyMatcherImpl<const PairType\&>(matcher\_for\_key\_));}
\DoxyCodeLine{2998   \}}
\DoxyCodeLine{2999 }
\DoxyCodeLine{3000  \textcolor{keyword}{private}:}
\DoxyCodeLine{3001   \textcolor{keyword}{const} M matcher\_for\_key\_;}
\DoxyCodeLine{3002 \};}
\DoxyCodeLine{3003 }
\DoxyCodeLine{3004 \textcolor{comment}{// Implements polymorphic Address(matcher\_for\_address).}}
\DoxyCodeLine{3005 \textcolor{keyword}{template} <\textcolor{keyword}{typename} InnerMatcher>}
\DoxyCodeLine{3006 \textcolor{keyword}{class }AddressMatcher \{}
\DoxyCodeLine{3007  \textcolor{keyword}{public}:}
\DoxyCodeLine{3008   \textcolor{keyword}{explicit} AddressMatcher(InnerMatcher m) : matcher\_(m) \{\}}
\DoxyCodeLine{3009 }
\DoxyCodeLine{3010   \textcolor{keyword}{template} <\textcolor{keyword}{typename} Type>}
\DoxyCodeLine{3011   \textcolor{keyword}{operator} Matcher<Type>()\textcolor{keyword}{ const }\{  \textcolor{comment}{// NOLINT}}
\DoxyCodeLine{3012     \textcolor{keywordflow}{return} Matcher<Type>(\textcolor{keyword}{new} Impl<const Type\&>(matcher\_));}
\DoxyCodeLine{3013   \}}
\DoxyCodeLine{3014 }
\DoxyCodeLine{3015  \textcolor{keyword}{private}:}
\DoxyCodeLine{3016   \textcolor{comment}{// The monomorphic implementation that works for a particular object type.}}
\DoxyCodeLine{3017   \textcolor{keyword}{template} <\textcolor{keyword}{typename} Type>}
\DoxyCodeLine{3018   \textcolor{keyword}{class }Impl : \textcolor{keyword}{public} MatcherInterface<Type> \{}
\DoxyCodeLine{3019    \textcolor{keyword}{public}:}
\DoxyCodeLine{3020     \textcolor{keyword}{using }Address = \textcolor{keyword}{const} GTEST\_REMOVE\_REFERENCE\_AND\_CONST\_(Type) *;}
\DoxyCodeLine{3021     \textcolor{keyword}{explicit} Impl(\textcolor{keyword}{const} InnerMatcher\& matcher)}
\DoxyCodeLine{3022         : matcher\_(MatcherCast<Address>(matcher)) \{\}}
\DoxyCodeLine{3023 }
\DoxyCodeLine{3024     \textcolor{keywordtype}{void} DescribeTo(::std::ostream* os)\textcolor{keyword}{ const override }\{}
\DoxyCodeLine{3025       *os << \textcolor{stringliteral}{"{}has address that "{}};}
\DoxyCodeLine{3026       matcher\_.DescribeTo(os);}
\DoxyCodeLine{3027     \}}
\DoxyCodeLine{3028 }
\DoxyCodeLine{3029     \textcolor{keywordtype}{void} DescribeNegationTo(::std::ostream* os)\textcolor{keyword}{ const override }\{}
\DoxyCodeLine{3030       *os << \textcolor{stringliteral}{"{}does not have address that "{}};}
\DoxyCodeLine{3031       matcher\_.DescribeTo(os);}
\DoxyCodeLine{3032     \}}
\DoxyCodeLine{3033 }
\DoxyCodeLine{3034     \textcolor{keywordtype}{bool} MatchAndExplain(Type \textcolor{keywordtype}{object},}
\DoxyCodeLine{3035                          MatchResultListener* listener)\textcolor{keyword}{ const override }\{}
\DoxyCodeLine{3036       *listener << \textcolor{stringliteral}{"{}which has address "{}};}
\DoxyCodeLine{3037       Address address = std::addressof(\textcolor{keywordtype}{object});}
\DoxyCodeLine{3038       \textcolor{keywordflow}{return} MatchPrintAndExplain(address, matcher\_, listener);}
\DoxyCodeLine{3039     \}}
\DoxyCodeLine{3040 }
\DoxyCodeLine{3041    \textcolor{keyword}{private}:}
\DoxyCodeLine{3042     \textcolor{keyword}{const} Matcher<Address> matcher\_;}
\DoxyCodeLine{3043   \};}
\DoxyCodeLine{3044   \textcolor{keyword}{const} InnerMatcher matcher\_;}
\DoxyCodeLine{3045 \};}
\DoxyCodeLine{3046 }
\DoxyCodeLine{3047 \textcolor{comment}{// Implements Pair(first\_matcher, second\_matcher) for the given argument pair}}
\DoxyCodeLine{3048 \textcolor{comment}{// type with its two matchers. See Pair() function below.}}
\DoxyCodeLine{3049 \textcolor{keyword}{template} <\textcolor{keyword}{typename} PairType>}
\DoxyCodeLine{3050 \textcolor{keyword}{class }PairMatcherImpl : \textcolor{keyword}{public} MatcherInterface<PairType> \{}
\DoxyCodeLine{3051  \textcolor{keyword}{public}:}
\DoxyCodeLine{3052   \textcolor{keyword}{typedef} GTEST\_REMOVE\_REFERENCE\_AND\_CONST\_(PairType) RawPairType;}
\DoxyCodeLine{3053   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} RawPairType::first\_type FirstType;}
\DoxyCodeLine{3054   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} RawPairType::second\_type SecondType;}
\DoxyCodeLine{3055 }
\DoxyCodeLine{3056   \textcolor{keyword}{template} <\textcolor{keyword}{typename} FirstMatcher, \textcolor{keyword}{typename} SecondMatcher>}
\DoxyCodeLine{3057   PairMatcherImpl(FirstMatcher first\_matcher, SecondMatcher second\_matcher)}
\DoxyCodeLine{3058       : first\_matcher\_(}
\DoxyCodeLine{3059             testing::SafeMatcherCast<const FirstType\&>(first\_matcher)),}
\DoxyCodeLine{3060         second\_matcher\_(}
\DoxyCodeLine{3061             testing::SafeMatcherCast<const SecondType\&>(second\_matcher)) \{\}}
\DoxyCodeLine{3062 }
\DoxyCodeLine{3063   \textcolor{comment}{// Describes what this matcher does.}}
\DoxyCodeLine{3064   \textcolor{keywordtype}{void} DescribeTo(::std::ostream* os)\textcolor{keyword}{ const override }\{}
\DoxyCodeLine{3065     *os << \textcolor{stringliteral}{"{}has a first field that "{}};}
\DoxyCodeLine{3066     first\_matcher\_.DescribeTo(os);}
\DoxyCodeLine{3067     *os << \textcolor{stringliteral}{"{}, and has a second field that "{}};}
\DoxyCodeLine{3068     second\_matcher\_.DescribeTo(os);}
\DoxyCodeLine{3069   \}}
\DoxyCodeLine{3070 }
\DoxyCodeLine{3071   \textcolor{comment}{// Describes what the negation of this matcher does.}}
\DoxyCodeLine{3072   \textcolor{keywordtype}{void} DescribeNegationTo(::std::ostream* os)\textcolor{keyword}{ const override }\{}
\DoxyCodeLine{3073     *os << \textcolor{stringliteral}{"{}has a first field that "{}};}
\DoxyCodeLine{3074     first\_matcher\_.DescribeNegationTo(os);}
\DoxyCodeLine{3075     *os << \textcolor{stringliteral}{"{}, or has a second field that "{}};}
\DoxyCodeLine{3076     second\_matcher\_.DescribeNegationTo(os);}
\DoxyCodeLine{3077   \}}
\DoxyCodeLine{3078 }
\DoxyCodeLine{3079   \textcolor{comment}{// Returns true if and only if 'a\_pair.first' matches first\_matcher and}}
\DoxyCodeLine{3080   \textcolor{comment}{// 'a\_pair.second' matches second\_matcher.}}
\DoxyCodeLine{3081   \textcolor{keywordtype}{bool} MatchAndExplain(PairType a\_pair,}
\DoxyCodeLine{3082                        MatchResultListener* listener)\textcolor{keyword}{ const override }\{}
\DoxyCodeLine{3083     \textcolor{keywordflow}{if} (!listener-\/>IsInterested()) \{}
\DoxyCodeLine{3084       \textcolor{comment}{// If the listener is not interested, we don't need to construct the}}
\DoxyCodeLine{3085       \textcolor{comment}{// explanation.}}
\DoxyCodeLine{3086       \textcolor{keywordflow}{return} first\_matcher\_.Matches(pair\_getters::First(a\_pair, Rank0())) \&\&}
\DoxyCodeLine{3087              second\_matcher\_.Matches(pair\_getters::Second(a\_pair, Rank0()));}
\DoxyCodeLine{3088     \}}
\DoxyCodeLine{3089     StringMatchResultListener first\_inner\_listener;}
\DoxyCodeLine{3090     \textcolor{keywordflow}{if} (!first\_matcher\_.MatchAndExplain(pair\_getters::First(a\_pair, Rank0()),}
\DoxyCodeLine{3091                                         \&first\_inner\_listener)) \{}
\DoxyCodeLine{3092       *listener << \textcolor{stringliteral}{"{}whose first field does not match"{}};}
\DoxyCodeLine{3093       PrintIfNotEmpty(first\_inner\_listener.str(), listener-\/>stream());}
\DoxyCodeLine{3094       \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{3095     \}}
\DoxyCodeLine{3096     StringMatchResultListener second\_inner\_listener;}
\DoxyCodeLine{3097     \textcolor{keywordflow}{if} (!second\_matcher\_.MatchAndExplain(pair\_getters::Second(a\_pair, Rank0()),}
\DoxyCodeLine{3098                                          \&second\_inner\_listener)) \{}
\DoxyCodeLine{3099       *listener << \textcolor{stringliteral}{"{}whose second field does not match"{}};}
\DoxyCodeLine{3100       PrintIfNotEmpty(second\_inner\_listener.str(), listener-\/>stream());}
\DoxyCodeLine{3101       \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{3102     \}}
\DoxyCodeLine{3103     ExplainSuccess(first\_inner\_listener.str(), second\_inner\_listener.str(),}
\DoxyCodeLine{3104                    listener);}
\DoxyCodeLine{3105     \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{3106   \}}
\DoxyCodeLine{3107 }
\DoxyCodeLine{3108  \textcolor{keyword}{private}:}
\DoxyCodeLine{3109   \textcolor{keywordtype}{void} ExplainSuccess(\textcolor{keyword}{const} std::string\& first\_explanation,}
\DoxyCodeLine{3110                       \textcolor{keyword}{const} std::string\& second\_explanation,}
\DoxyCodeLine{3111                       MatchResultListener* listener)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{3112     *listener << \textcolor{stringliteral}{"{}whose both fields match"{}};}
\DoxyCodeLine{3113     \textcolor{keywordflow}{if} (first\_explanation != \textcolor{stringliteral}{"{}"{}}) \{}
\DoxyCodeLine{3114       *listener << \textcolor{stringliteral}{"{}, where the first field is a value "{}} << first\_explanation;}
\DoxyCodeLine{3115     \}}
\DoxyCodeLine{3116     \textcolor{keywordflow}{if} (second\_explanation != \textcolor{stringliteral}{"{}"{}}) \{}
\DoxyCodeLine{3117       *listener << \textcolor{stringliteral}{"{}, "{}};}
\DoxyCodeLine{3118       \textcolor{keywordflow}{if} (first\_explanation != \textcolor{stringliteral}{"{}"{}}) \{}
\DoxyCodeLine{3119         *listener << \textcolor{stringliteral}{"{}and "{}};}
\DoxyCodeLine{3120       \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{3121         *listener << \textcolor{stringliteral}{"{}where "{}};}
\DoxyCodeLine{3122       \}}
\DoxyCodeLine{3123       *listener << \textcolor{stringliteral}{"{}the second field is a value "{}} << second\_explanation;}
\DoxyCodeLine{3124     \}}
\DoxyCodeLine{3125   \}}
\DoxyCodeLine{3126 }
\DoxyCodeLine{3127   \textcolor{keyword}{const} Matcher<const FirstType\&> first\_matcher\_;}
\DoxyCodeLine{3128   \textcolor{keyword}{const} Matcher<const SecondType\&> second\_matcher\_;}
\DoxyCodeLine{3129 \};}
\DoxyCodeLine{3130 }
\DoxyCodeLine{3131 \textcolor{comment}{// Implements polymorphic Pair(first\_matcher, second\_matcher).}}
\DoxyCodeLine{3132 \textcolor{keyword}{template} <\textcolor{keyword}{typename} FirstMatcher, \textcolor{keyword}{typename} SecondMatcher>}
\DoxyCodeLine{3133 \textcolor{keyword}{class }PairMatcher \{}
\DoxyCodeLine{3134  \textcolor{keyword}{public}:}
\DoxyCodeLine{3135   PairMatcher(FirstMatcher first\_matcher, SecondMatcher second\_matcher)}
\DoxyCodeLine{3136       : first\_matcher\_(first\_matcher), second\_matcher\_(second\_matcher) \{\}}
\DoxyCodeLine{3137 }
\DoxyCodeLine{3138   \textcolor{keyword}{template} <\textcolor{keyword}{typename} PairType>}
\DoxyCodeLine{3139   \textcolor{keyword}{operator} Matcher<PairType>()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{3140     \textcolor{keywordflow}{return} Matcher<PairType>(}
\DoxyCodeLine{3141         \textcolor{keyword}{new} PairMatcherImpl<const PairType\&>(first\_matcher\_, second\_matcher\_));}
\DoxyCodeLine{3142   \}}
\DoxyCodeLine{3143 }
\DoxyCodeLine{3144  \textcolor{keyword}{private}:}
\DoxyCodeLine{3145   \textcolor{keyword}{const} FirstMatcher first\_matcher\_;}
\DoxyCodeLine{3146   \textcolor{keyword}{const} SecondMatcher second\_matcher\_;}
\DoxyCodeLine{3147 \};}
\DoxyCodeLine{3148 }
\DoxyCodeLine{3149 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T, \textcolor{keywordtype}{size\_t}... I>}
\DoxyCodeLine{3150 \textcolor{keyword}{auto} UnpackStructImpl(\textcolor{keyword}{const} T\& t, IndexSequence<I...>, \textcolor{keywordtype}{int})}
\DoxyCodeLine{3151     -\/> \textcolor{keyword}{decltype}(std::tie(get<I>(t)...)) \{}
\DoxyCodeLine{3152   \textcolor{keyword}{static\_assert}(std::tuple\_size<T>::value == \textcolor{keyword}{sizeof}...(I),}
\DoxyCodeLine{3153                 \textcolor{stringliteral}{"{}Number of arguments doesn't match the number of fields."{}});}
\DoxyCodeLine{3154   \textcolor{keywordflow}{return} std::tie(get<I>(t)...);}
\DoxyCodeLine{3155 \}}
\DoxyCodeLine{3156 }
\DoxyCodeLine{3157 \textcolor{preprocessor}{\#if defined(\_\_cpp\_structured\_bindings) \&\& \_\_cpp\_structured\_bindings >= 201606}}
\DoxyCodeLine{3158 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{3159 \textcolor{keyword}{auto} UnpackStructImpl(\textcolor{keyword}{const} T\& t, MakeIndexSequence<1>, \textcolor{keywordtype}{char}) \{}
\DoxyCodeLine{3160   \textcolor{keyword}{const} \textcolor{keyword}{auto}\& [a] = t;}
\DoxyCodeLine{3161   \textcolor{keywordflow}{return} std::tie(a);}
\DoxyCodeLine{3162 \}}
\DoxyCodeLine{3163 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{3164 \textcolor{keyword}{auto} UnpackStructImpl(\textcolor{keyword}{const} T\& t, MakeIndexSequence<2>, \textcolor{keywordtype}{char}) \{}
\DoxyCodeLine{3165   \textcolor{keyword}{const} \textcolor{keyword}{auto}\& [a, b] = t;}
\DoxyCodeLine{3166   \textcolor{keywordflow}{return} std::tie(a, b);}
\DoxyCodeLine{3167 \}}
\DoxyCodeLine{3168 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{3169 \textcolor{keyword}{auto} UnpackStructImpl(\textcolor{keyword}{const} T\& t, MakeIndexSequence<3>, \textcolor{keywordtype}{char}) \{}
\DoxyCodeLine{3170   \textcolor{keyword}{const} \textcolor{keyword}{auto}\& [a, b, c] = t;}
\DoxyCodeLine{3171   \textcolor{keywordflow}{return} std::tie(a, b, c);}
\DoxyCodeLine{3172 \}}
\DoxyCodeLine{3173 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{3174 \textcolor{keyword}{auto} UnpackStructImpl(\textcolor{keyword}{const} T\& t, MakeIndexSequence<4>, \textcolor{keywordtype}{char}) \{}
\DoxyCodeLine{3175   \textcolor{keyword}{const} \textcolor{keyword}{auto}\& [a, b, c, d] = t;}
\DoxyCodeLine{3176   \textcolor{keywordflow}{return} std::tie(a, b, c, d);}
\DoxyCodeLine{3177 \}}
\DoxyCodeLine{3178 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{3179 \textcolor{keyword}{auto} UnpackStructImpl(\textcolor{keyword}{const} T\& t, MakeIndexSequence<5>, \textcolor{keywordtype}{char}) \{}
\DoxyCodeLine{3180   \textcolor{keyword}{const} \textcolor{keyword}{auto}\& [a, b, c, d, e] = t;}
\DoxyCodeLine{3181   \textcolor{keywordflow}{return} std::tie(a, b, c, d, e);}
\DoxyCodeLine{3182 \}}
\DoxyCodeLine{3183 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{3184 \textcolor{keyword}{auto} UnpackStructImpl(\textcolor{keyword}{const} T\& t, MakeIndexSequence<6>, \textcolor{keywordtype}{char}) \{}
\DoxyCodeLine{3185   \textcolor{keyword}{const} \textcolor{keyword}{auto}\& [a, b, c, d, e, f] = t;}
\DoxyCodeLine{3186   \textcolor{keywordflow}{return} std::tie(a, b, c, d, e, f);}
\DoxyCodeLine{3187 \}}
\DoxyCodeLine{3188 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{3189 \textcolor{keyword}{auto} UnpackStructImpl(\textcolor{keyword}{const} T\& t, MakeIndexSequence<7>, \textcolor{keywordtype}{char}) \{}
\DoxyCodeLine{3190   \textcolor{keyword}{const} \textcolor{keyword}{auto}\& [a, b, c, d, e, f, g] = t;}
\DoxyCodeLine{3191   \textcolor{keywordflow}{return} std::tie(a, b, c, d, e, f, g);}
\DoxyCodeLine{3192 \}}
\DoxyCodeLine{3193 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{3194 \textcolor{keyword}{auto} UnpackStructImpl(\textcolor{keyword}{const} T\& t, MakeIndexSequence<8>, \textcolor{keywordtype}{char}) \{}
\DoxyCodeLine{3195   \textcolor{keyword}{const} \textcolor{keyword}{auto}\& [a, b, c, d, e, f, g, h] = t;}
\DoxyCodeLine{3196   \textcolor{keywordflow}{return} std::tie(a, b, c, d, e, f, g, h);}
\DoxyCodeLine{3197 \}}
\DoxyCodeLine{3198 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{3199 \textcolor{keyword}{auto} UnpackStructImpl(\textcolor{keyword}{const} T\& t, MakeIndexSequence<9>, \textcolor{keywordtype}{char}) \{}
\DoxyCodeLine{3200   \textcolor{keyword}{const} \textcolor{keyword}{auto}\& [a, b, c, d, e, f, g, h, i] = t;}
\DoxyCodeLine{3201   \textcolor{keywordflow}{return} std::tie(a, b, c, d, e, f, g, h, i);}
\DoxyCodeLine{3202 \}}
\DoxyCodeLine{3203 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{3204 \textcolor{keyword}{auto} UnpackStructImpl(\textcolor{keyword}{const} T\& t, MakeIndexSequence<10>, \textcolor{keywordtype}{char}) \{}
\DoxyCodeLine{3205   \textcolor{keyword}{const} \textcolor{keyword}{auto}\& [a, b, c, d, e, f, g, h, i, j] = t;}
\DoxyCodeLine{3206   \textcolor{keywordflow}{return} std::tie(a, b, c, d, e, f, g, h, i, j);}
\DoxyCodeLine{3207 \}}
\DoxyCodeLine{3208 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{3209 \textcolor{keyword}{auto} UnpackStructImpl(\textcolor{keyword}{const} T\& t, MakeIndexSequence<11>, \textcolor{keywordtype}{char}) \{}
\DoxyCodeLine{3210   \textcolor{keyword}{const} \textcolor{keyword}{auto}\& [a, b, c, d, e, f, g, h, i, j, k] = t;}
\DoxyCodeLine{3211   \textcolor{keywordflow}{return} std::tie(a, b, c, d, e, f, g, h, i, j, k);}
\DoxyCodeLine{3212 \}}
\DoxyCodeLine{3213 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{3214 \textcolor{keyword}{auto} UnpackStructImpl(\textcolor{keyword}{const} T\& t, MakeIndexSequence<12>, \textcolor{keywordtype}{char}) \{}
\DoxyCodeLine{3215   \textcolor{keyword}{const} \textcolor{keyword}{auto}\& [a, b, c, d, e, f, g, h, i, j, k, l] = t;}
\DoxyCodeLine{3216   \textcolor{keywordflow}{return} std::tie(a, b, c, d, e, f, g, h, i, j, k, l);}
\DoxyCodeLine{3217 \}}
\DoxyCodeLine{3218 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{3219 \textcolor{keyword}{auto} UnpackStructImpl(\textcolor{keyword}{const} T\& t, MakeIndexSequence<13>, \textcolor{keywordtype}{char}) \{}
\DoxyCodeLine{3220   \textcolor{keyword}{const} \textcolor{keyword}{auto}\& [a, b, c, d, e, f, g, h, i, j, k, l, m] = t;}
\DoxyCodeLine{3221   \textcolor{keywordflow}{return} std::tie(a, b, c, d, e, f, g, h, i, j, k, l, m);}
\DoxyCodeLine{3222 \}}
\DoxyCodeLine{3223 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{3224 \textcolor{keyword}{auto} UnpackStructImpl(\textcolor{keyword}{const} T\& t, MakeIndexSequence<14>, \textcolor{keywordtype}{char}) \{}
\DoxyCodeLine{3225   \textcolor{keyword}{const} \textcolor{keyword}{auto}\& [a, b, c, d, e, f, g, h, i, j, k, l, m, n] = t;}
\DoxyCodeLine{3226   \textcolor{keywordflow}{return} std::tie(a, b, c, d, e, f, g, h, i, j, k, l, m, n);}
\DoxyCodeLine{3227 \}}
\DoxyCodeLine{3228 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{3229 \textcolor{keyword}{auto} UnpackStructImpl(\textcolor{keyword}{const} T\& t, MakeIndexSequence<15>, \textcolor{keywordtype}{char}) \{}
\DoxyCodeLine{3230   \textcolor{keyword}{const} \textcolor{keyword}{auto}\& [a, b, c, d, e, f, g, h, i, j, k, l, m, n, o] = t;}
\DoxyCodeLine{3231   \textcolor{keywordflow}{return} std::tie(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o);}
\DoxyCodeLine{3232 \}}
\DoxyCodeLine{3233 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{3234 \textcolor{keyword}{auto} UnpackStructImpl(\textcolor{keyword}{const} T\& t, MakeIndexSequence<16>, \textcolor{keywordtype}{char}) \{}
\DoxyCodeLine{3235   \textcolor{keyword}{const} \textcolor{keyword}{auto}\& [a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p] = t;}
\DoxyCodeLine{3236   \textcolor{keywordflow}{return} std::tie(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p);}
\DoxyCodeLine{3237 \}}
\DoxyCodeLine{3238 \textcolor{preprocessor}{\#endif  }\textcolor{comment}{// defined(\_\_cpp\_structured\_bindings)}}
\DoxyCodeLine{3239 }
\DoxyCodeLine{3240 \textcolor{keyword}{template} <\textcolor{keywordtype}{size\_t} I, \textcolor{keyword}{typename} T>}
\DoxyCodeLine{3241 \textcolor{keyword}{auto} UnpackStruct(\textcolor{keyword}{const} T\& t)}
\DoxyCodeLine{3242     -\/> \textcolor{keyword}{decltype}((UnpackStructImpl)(t, MakeIndexSequence<I>\{\}, 0)) \{}
\DoxyCodeLine{3243   \textcolor{keywordflow}{return} (UnpackStructImpl)(t, MakeIndexSequence<I>\{\}, 0);}
\DoxyCodeLine{3244 \}}
\DoxyCodeLine{3245 }
\DoxyCodeLine{3246 \textcolor{comment}{// Helper function to do comma folding in C++11.}}
\DoxyCodeLine{3247 \textcolor{comment}{// The array ensures left-\/to-\/right order of evaluation.}}
\DoxyCodeLine{3248 \textcolor{comment}{// Usage: VariadicExpand(\{expr...\});}}
\DoxyCodeLine{3249 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T, \textcolor{keywordtype}{size\_t} N>}
\DoxyCodeLine{3250 \textcolor{keywordtype}{void} VariadicExpand(\textcolor{keyword}{const} T (\&)[N]) \{\}}
\DoxyCodeLine{3251 }
\DoxyCodeLine{3252 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Struct, \textcolor{keyword}{typename} StructSize>}
\DoxyCodeLine{3253 \textcolor{keyword}{class }FieldsAreMatcherImpl;}
\DoxyCodeLine{3254 }
\DoxyCodeLine{3255 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Struct, \textcolor{keywordtype}{size\_t}... I>}
\DoxyCodeLine{3256 \textcolor{keyword}{class }FieldsAreMatcherImpl<Struct, IndexSequence<I...>>}
\DoxyCodeLine{3257     : \textcolor{keyword}{public} MatcherInterface<Struct> \{}
\DoxyCodeLine{3258   \textcolor{keyword}{using }UnpackedType =}
\DoxyCodeLine{3259       \textcolor{keyword}{decltype}(UnpackStruct<\textcolor{keyword}{sizeof}...(I)>(std::declval<const Struct\&>()));}
\DoxyCodeLine{3260   \textcolor{keyword}{using }MatchersType = std::tuple<}
\DoxyCodeLine{3261       Matcher<const typename std::tuple\_element<I, UnpackedType>::type\&>...>;}
\DoxyCodeLine{3262 }
\DoxyCodeLine{3263  \textcolor{keyword}{public}:}
\DoxyCodeLine{3264   \textcolor{keyword}{template} <\textcolor{keyword}{typename} Inner>}
\DoxyCodeLine{3265   \textcolor{keyword}{explicit} FieldsAreMatcherImpl(\textcolor{keyword}{const} Inner\& matchers)}
\DoxyCodeLine{3266       : matchers\_(testing::SafeMatcherCast<}
\DoxyCodeLine{3267                   const typename std::tuple\_element<I, UnpackedType>::type\&>(}
\DoxyCodeLine{3268             std::get<I>(matchers))...) \{\}}
\DoxyCodeLine{3269 }
\DoxyCodeLine{3270   \textcolor{keywordtype}{void} DescribeTo(::std::ostream* os)\textcolor{keyword}{ const override }\{}
\DoxyCodeLine{3271     \textcolor{keyword}{const} \textcolor{keywordtype}{char}* separator = \textcolor{stringliteral}{"{}"{}};}
\DoxyCodeLine{3272     VariadicExpand(}
\DoxyCodeLine{3273         \{(*os << separator << \textcolor{stringliteral}{"{}has field \#"{}} << I << \textcolor{stringliteral}{"{} that "{}},}
\DoxyCodeLine{3274           std::get<I>(matchers\_).DescribeTo(os), separator = \textcolor{stringliteral}{"{}, and "{}})...\});}
\DoxyCodeLine{3275   \}}
\DoxyCodeLine{3276 }
\DoxyCodeLine{3277   \textcolor{keywordtype}{void} DescribeNegationTo(::std::ostream* os)\textcolor{keyword}{ const override }\{}
\DoxyCodeLine{3278     \textcolor{keyword}{const} \textcolor{keywordtype}{char}* separator = \textcolor{stringliteral}{"{}"{}};}
\DoxyCodeLine{3279     VariadicExpand(\{(*os << separator << \textcolor{stringliteral}{"{}has field \#"{}} << I << \textcolor{stringliteral}{"{} that "{}},}
\DoxyCodeLine{3280                      std::get<I>(matchers\_).DescribeNegationTo(os),}
\DoxyCodeLine{3281                      separator = \textcolor{stringliteral}{"{}, or "{}})...\});}
\DoxyCodeLine{3282   \}}
\DoxyCodeLine{3283 }
\DoxyCodeLine{3284   \textcolor{keywordtype}{bool} MatchAndExplain(Struct t, MatchResultListener* listener)\textcolor{keyword}{ const override }\{}
\DoxyCodeLine{3285     \textcolor{keywordflow}{return} MatchInternal((UnpackStruct<\textcolor{keyword}{sizeof}...(I)>)(t), listener);}
\DoxyCodeLine{3286   \}}
\DoxyCodeLine{3287 }
\DoxyCodeLine{3288  \textcolor{keyword}{private}:}
\DoxyCodeLine{3289   \textcolor{keywordtype}{bool} MatchInternal(UnpackedType tuple, MatchResultListener* listener)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{3290     \textcolor{keywordflow}{if} (!listener-\/>IsInterested()) \{}
\DoxyCodeLine{3291       \textcolor{comment}{// If the listener is not interested, we don't need to construct the}}
\DoxyCodeLine{3292       \textcolor{comment}{// explanation.}}
\DoxyCodeLine{3293       \textcolor{keywordtype}{bool} good = \textcolor{keyword}{true};}
\DoxyCodeLine{3294       VariadicExpand(\{good = good \&\& std::get<I>(matchers\_).Matches(}
\DoxyCodeLine{3295                                          std::get<I>(tuple))...\});}
\DoxyCodeLine{3296       \textcolor{keywordflow}{return} good;}
\DoxyCodeLine{3297     \}}
\DoxyCodeLine{3298 }
\DoxyCodeLine{3299     \textcolor{keywordtype}{size\_t} failed\_pos = \string~size\_t\{\};}
\DoxyCodeLine{3300 }
\DoxyCodeLine{3301     std::vector<StringMatchResultListener> inner\_listener(\textcolor{keyword}{sizeof}...(I));}
\DoxyCodeLine{3302 }
\DoxyCodeLine{3303     VariadicExpand(}
\DoxyCodeLine{3304         \{failed\_pos == \string~size\_t\{\} \&\& !std::get<I>(matchers\_).MatchAndExplain(}
\DoxyCodeLine{3305                                         std::get<I>(tuple), \&inner\_listener[I])}
\DoxyCodeLine{3306              ? failed\_pos = I}
\DoxyCodeLine{3307              : 0 ...\});}
\DoxyCodeLine{3308     \textcolor{keywordflow}{if} (failed\_pos != \string~\textcolor{keywordtype}{size\_t}\{\}) \{}
\DoxyCodeLine{3309       *listener << \textcolor{stringliteral}{"{}whose field \#"{}} << failed\_pos << \textcolor{stringliteral}{"{} does not match"{}};}
\DoxyCodeLine{3310       PrintIfNotEmpty(inner\_listener[failed\_pos].str(), listener-\/>stream());}
\DoxyCodeLine{3311       \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{3312     \}}
\DoxyCodeLine{3313 }
\DoxyCodeLine{3314     *listener << \textcolor{stringliteral}{"{}whose all elements match"{}};}
\DoxyCodeLine{3315     \textcolor{keyword}{const} \textcolor{keywordtype}{char}* separator = \textcolor{stringliteral}{"{}, where"{}};}
\DoxyCodeLine{3316     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{size\_t} index = 0; index < \textcolor{keyword}{sizeof}...(I); ++index) \{}
\DoxyCodeLine{3317       \textcolor{keyword}{const} std::string str = inner\_listener[index].str();}
\DoxyCodeLine{3318       \textcolor{keywordflow}{if} (!str.empty()) \{}
\DoxyCodeLine{3319         *listener << separator << \textcolor{stringliteral}{"{} field \#"{}} << index << \textcolor{stringliteral}{"{} is a value "{}} << str;}
\DoxyCodeLine{3320         separator = \textcolor{stringliteral}{"{}, and"{}};}
\DoxyCodeLine{3321       \}}
\DoxyCodeLine{3322     \}}
\DoxyCodeLine{3323 }
\DoxyCodeLine{3324     \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{3325   \}}
\DoxyCodeLine{3326 }
\DoxyCodeLine{3327   MatchersType matchers\_;}
\DoxyCodeLine{3328 \};}
\DoxyCodeLine{3329 }
\DoxyCodeLine{3330 \textcolor{keyword}{template} <\textcolor{keyword}{typename}... Inner>}
\DoxyCodeLine{3331 \textcolor{keyword}{class }FieldsAreMatcher \{}
\DoxyCodeLine{3332  \textcolor{keyword}{public}:}
\DoxyCodeLine{3333   \textcolor{keyword}{explicit} FieldsAreMatcher(Inner... inner) : matchers\_(std::move(inner)...) \{\}}
\DoxyCodeLine{3334 }
\DoxyCodeLine{3335   \textcolor{keyword}{template} <\textcolor{keyword}{typename} Struct>}
\DoxyCodeLine{3336   \textcolor{keyword}{operator} Matcher<Struct>()\textcolor{keyword}{ const }\{  \textcolor{comment}{// NOLINT}}
\DoxyCodeLine{3337     \textcolor{keywordflow}{return} Matcher<Struct>(}
\DoxyCodeLine{3338         \textcolor{keyword}{new} FieldsAreMatcherImpl<\textcolor{keyword}{const} Struct\&, IndexSequenceFor<Inner...>>(}
\DoxyCodeLine{3339             matchers\_));}
\DoxyCodeLine{3340   \}}
\DoxyCodeLine{3341 }
\DoxyCodeLine{3342  \textcolor{keyword}{private}:}
\DoxyCodeLine{3343   std::tuple<Inner...> matchers\_;}
\DoxyCodeLine{3344 \};}
\DoxyCodeLine{3345 }
\DoxyCodeLine{3346 \textcolor{comment}{// Implements ElementsAre() and ElementsAreArray().}}
\DoxyCodeLine{3347 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Container>}
\DoxyCodeLine{3348 \textcolor{keyword}{class }ElementsAreMatcherImpl : \textcolor{keyword}{public} MatcherInterface<Container> \{}
\DoxyCodeLine{3349  \textcolor{keyword}{public}:}
\DoxyCodeLine{3350   \textcolor{keyword}{typedef} GTEST\_REMOVE\_REFERENCE\_AND\_CONST\_(Container) RawContainer;}
\DoxyCodeLine{3351   \textcolor{keyword}{typedef} internal::StlContainerView<RawContainer> View;}
\DoxyCodeLine{3352   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} View::type StlContainer;}
\DoxyCodeLine{3353   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} View::const\_reference StlContainerReference;}
\DoxyCodeLine{3354   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} StlContainer::value\_type Element;}
\DoxyCodeLine{3355 }
\DoxyCodeLine{3356   \textcolor{comment}{// Constructs the matcher from a sequence of element values or}}
\DoxyCodeLine{3357   \textcolor{comment}{// element matchers.}}
\DoxyCodeLine{3358   \textcolor{keyword}{template} <\textcolor{keyword}{typename} InputIter>}
\DoxyCodeLine{3359   ElementsAreMatcherImpl(InputIter first, InputIter last) \{}
\DoxyCodeLine{3360     \textcolor{keywordflow}{while} (first != last) \{}
\DoxyCodeLine{3361       matchers\_.push\_back(MatcherCast<const Element\&>(*first++));}
\DoxyCodeLine{3362     \}}
\DoxyCodeLine{3363   \}}
\DoxyCodeLine{3364 }
\DoxyCodeLine{3365   \textcolor{comment}{// Describes what this matcher does.}}
\DoxyCodeLine{3366   \textcolor{keywordtype}{void} DescribeTo(::std::ostream* os)\textcolor{keyword}{ const override }\{}
\DoxyCodeLine{3367     \textcolor{keywordflow}{if} (count() == 0) \{}
\DoxyCodeLine{3368       *os << \textcolor{stringliteral}{"{}is empty"{}};}
\DoxyCodeLine{3369     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (count() == 1) \{}
\DoxyCodeLine{3370       *os << \textcolor{stringliteral}{"{}has 1 element that "{}};}
\DoxyCodeLine{3371       matchers\_[0].DescribeTo(os);}
\DoxyCodeLine{3372     \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{3373       *os << \textcolor{stringliteral}{"{}has "{}} << Elements(count()) << \textcolor{stringliteral}{"{} where\(\backslash\)n"{}};}
\DoxyCodeLine{3374       \textcolor{keywordflow}{for} (\textcolor{keywordtype}{size\_t} i = 0; i != count(); ++i) \{}
\DoxyCodeLine{3375         *os << \textcolor{stringliteral}{"{}element \#"{}} << i << \textcolor{stringliteral}{"{} "{}};}
\DoxyCodeLine{3376         matchers\_[i].DescribeTo(os);}
\DoxyCodeLine{3377         \textcolor{keywordflow}{if} (i + 1 < count()) \{}
\DoxyCodeLine{3378           *os << \textcolor{stringliteral}{"{},\(\backslash\)n"{}};}
\DoxyCodeLine{3379         \}}
\DoxyCodeLine{3380       \}}
\DoxyCodeLine{3381     \}}
\DoxyCodeLine{3382   \}}
\DoxyCodeLine{3383 }
\DoxyCodeLine{3384   \textcolor{comment}{// Describes what the negation of this matcher does.}}
\DoxyCodeLine{3385   \textcolor{keywordtype}{void} DescribeNegationTo(::std::ostream* os)\textcolor{keyword}{ const override }\{}
\DoxyCodeLine{3386     \textcolor{keywordflow}{if} (count() == 0) \{}
\DoxyCodeLine{3387       *os << \textcolor{stringliteral}{"{}isn't empty"{}};}
\DoxyCodeLine{3388       \textcolor{keywordflow}{return};}
\DoxyCodeLine{3389     \}}
\DoxyCodeLine{3390 }
\DoxyCodeLine{3391     *os << \textcolor{stringliteral}{"{}doesn't have "{}} << Elements(count()) << \textcolor{stringliteral}{"{}, or\(\backslash\)n"{}};}
\DoxyCodeLine{3392     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{size\_t} i = 0; i != count(); ++i) \{}
\DoxyCodeLine{3393       *os << \textcolor{stringliteral}{"{}element \#"{}} << i << \textcolor{stringliteral}{"{} "{}};}
\DoxyCodeLine{3394       matchers\_[i].DescribeNegationTo(os);}
\DoxyCodeLine{3395       \textcolor{keywordflow}{if} (i + 1 < count()) \{}
\DoxyCodeLine{3396         *os << \textcolor{stringliteral}{"{}, or\(\backslash\)n"{}};}
\DoxyCodeLine{3397       \}}
\DoxyCodeLine{3398     \}}
\DoxyCodeLine{3399   \}}
\DoxyCodeLine{3400 }
\DoxyCodeLine{3401   \textcolor{keywordtype}{bool} MatchAndExplain(Container container,}
\DoxyCodeLine{3402                        MatchResultListener* listener)\textcolor{keyword}{ const override }\{}
\DoxyCodeLine{3403     \textcolor{comment}{// To work with stream-\/like "{}containers"{}, we must only walk}}
\DoxyCodeLine{3404     \textcolor{comment}{// through the elements in one pass.}}
\DoxyCodeLine{3405 }
\DoxyCodeLine{3406     \textcolor{keyword}{const} \textcolor{keywordtype}{bool} listener\_interested = listener-\/>IsInterested();}
\DoxyCodeLine{3407 }
\DoxyCodeLine{3408     \textcolor{comment}{// explanations[i] is the explanation of the element at index i.}}
\DoxyCodeLine{3409     ::std::vector<std::string> explanations(count());}
\DoxyCodeLine{3410     StlContainerReference stl\_container = View::ConstReference(container);}
\DoxyCodeLine{3411     \textcolor{keyword}{auto} it = stl\_container.begin();}
\DoxyCodeLine{3412     \textcolor{keywordtype}{size\_t} exam\_pos = 0;}
\DoxyCodeLine{3413     \textcolor{keywordtype}{bool} mismatch\_found = \textcolor{keyword}{false};  \textcolor{comment}{// Have we found a mismatched element yet?}}
\DoxyCodeLine{3414 }
\DoxyCodeLine{3415     \textcolor{comment}{// Go through the elements and matchers in pairs, until we reach}}
\DoxyCodeLine{3416     \textcolor{comment}{// the end of either the elements or the matchers, or until we find a}}
\DoxyCodeLine{3417     \textcolor{comment}{// mismatch.}}
\DoxyCodeLine{3418     \textcolor{keywordflow}{for} (; it != stl\_container.end() \&\& exam\_pos != count(); ++it, ++exam\_pos) \{}
\DoxyCodeLine{3419       \textcolor{keywordtype}{bool} match;  \textcolor{comment}{// Does the current element match the current matcher?}}
\DoxyCodeLine{3420       \textcolor{keywordflow}{if} (listener\_interested) \{}
\DoxyCodeLine{3421         StringMatchResultListener s;}
\DoxyCodeLine{3422         match = matchers\_[exam\_pos].MatchAndExplain(*it, \&s);}
\DoxyCodeLine{3423         explanations[exam\_pos] = s.str();}
\DoxyCodeLine{3424       \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{3425         match = matchers\_[exam\_pos].Matches(*it);}
\DoxyCodeLine{3426       \}}
\DoxyCodeLine{3427 }
\DoxyCodeLine{3428       \textcolor{keywordflow}{if} (!match) \{}
\DoxyCodeLine{3429         mismatch\_found = \textcolor{keyword}{true};}
\DoxyCodeLine{3430         \textcolor{keywordflow}{break};}
\DoxyCodeLine{3431       \}}
\DoxyCodeLine{3432     \}}
\DoxyCodeLine{3433     \textcolor{comment}{// If mismatch\_found is true, 'exam\_pos' is the index of the mismatch.}}
\DoxyCodeLine{3434 }
\DoxyCodeLine{3435     \textcolor{comment}{// Find how many elements the actual container has.  We avoid}}
\DoxyCodeLine{3436     \textcolor{comment}{// calling size() s.t. this code works for stream-\/like "{}containers"{}}}
\DoxyCodeLine{3437     \textcolor{comment}{// that don't define size().}}
\DoxyCodeLine{3438     \textcolor{keywordtype}{size\_t} actual\_count = exam\_pos;}
\DoxyCodeLine{3439     \textcolor{keywordflow}{for} (; it != stl\_container.end(); ++it) \{}
\DoxyCodeLine{3440       ++actual\_count;}
\DoxyCodeLine{3441     \}}
\DoxyCodeLine{3442 }
\DoxyCodeLine{3443     \textcolor{keywordflow}{if} (actual\_count != count()) \{}
\DoxyCodeLine{3444       \textcolor{comment}{// The element count doesn't match.  If the container is empty,}}
\DoxyCodeLine{3445       \textcolor{comment}{// there's no need to explain anything as Google Mock already}}
\DoxyCodeLine{3446       \textcolor{comment}{// prints the empty container.  Otherwise we just need to show}}
\DoxyCodeLine{3447       \textcolor{comment}{// how many elements there actually are.}}
\DoxyCodeLine{3448       \textcolor{keywordflow}{if} (listener\_interested \&\& (actual\_count != 0)) \{}
\DoxyCodeLine{3449         *listener << \textcolor{stringliteral}{"{}which has "{}} << Elements(actual\_count);}
\DoxyCodeLine{3450       \}}
\DoxyCodeLine{3451       \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{3452     \}}
\DoxyCodeLine{3453 }
\DoxyCodeLine{3454     \textcolor{keywordflow}{if} (mismatch\_found) \{}
\DoxyCodeLine{3455       \textcolor{comment}{// The element count matches, but the exam\_pos-\/th element doesn't match.}}
\DoxyCodeLine{3456       \textcolor{keywordflow}{if} (listener\_interested) \{}
\DoxyCodeLine{3457         *listener << \textcolor{stringliteral}{"{}whose element \#"{}} << exam\_pos << \textcolor{stringliteral}{"{} doesn't match"{}};}
\DoxyCodeLine{3458         PrintIfNotEmpty(explanations[exam\_pos], listener-\/>stream());}
\DoxyCodeLine{3459       \}}
\DoxyCodeLine{3460       \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{3461     \}}
\DoxyCodeLine{3462 }
\DoxyCodeLine{3463     \textcolor{comment}{// Every element matches its expectation.  We need to explain why}}
\DoxyCodeLine{3464     \textcolor{comment}{// (the obvious ones can be skipped).}}
\DoxyCodeLine{3465     \textcolor{keywordflow}{if} (listener\_interested) \{}
\DoxyCodeLine{3466       \textcolor{keywordtype}{bool} reason\_printed = \textcolor{keyword}{false};}
\DoxyCodeLine{3467       \textcolor{keywordflow}{for} (\textcolor{keywordtype}{size\_t} i = 0; i != count(); ++i) \{}
\DoxyCodeLine{3468         \textcolor{keyword}{const} std::string\& s = explanations[i];}
\DoxyCodeLine{3469         \textcolor{keywordflow}{if} (!s.empty()) \{}
\DoxyCodeLine{3470           \textcolor{keywordflow}{if} (reason\_printed) \{}
\DoxyCodeLine{3471             *listener << \textcolor{stringliteral}{"{},\(\backslash\)nand "{}};}
\DoxyCodeLine{3472           \}}
\DoxyCodeLine{3473           *listener << \textcolor{stringliteral}{"{}whose element \#"{}} << i << \textcolor{stringliteral}{"{} matches, "{}} << s;}
\DoxyCodeLine{3474           reason\_printed = \textcolor{keyword}{true};}
\DoxyCodeLine{3475         \}}
\DoxyCodeLine{3476       \}}
\DoxyCodeLine{3477     \}}
\DoxyCodeLine{3478     \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{3479   \}}
\DoxyCodeLine{3480 }
\DoxyCodeLine{3481  \textcolor{keyword}{private}:}
\DoxyCodeLine{3482   \textcolor{keyword}{static} Message Elements(\textcolor{keywordtype}{size\_t} count) \{}
\DoxyCodeLine{3483     \textcolor{keywordflow}{return} Message() << count << (count == 1 ? \textcolor{stringliteral}{"{} element"{}} : \textcolor{stringliteral}{"{} elements"{}});}
\DoxyCodeLine{3484   \}}
\DoxyCodeLine{3485 }
\DoxyCodeLine{3486   \textcolor{keywordtype}{size\_t} count()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} matchers\_.size(); \}}
\DoxyCodeLine{3487 }
\DoxyCodeLine{3488   ::std::vector<Matcher<const Element\&>> matchers\_;}
\DoxyCodeLine{3489 \};}
\DoxyCodeLine{3490 }
\DoxyCodeLine{3491 \textcolor{comment}{// Connectivity matrix of (elements X matchers), in element-\/major order.}}
\DoxyCodeLine{3492 \textcolor{comment}{// Initially, there are no edges.}}
\DoxyCodeLine{3493 \textcolor{comment}{// Use NextGraph() to iterate over all possible edge configurations.}}
\DoxyCodeLine{3494 \textcolor{comment}{// Use Randomize() to generate a random edge configuration.}}
\DoxyCodeLine{3495 \textcolor{keyword}{class }GTEST\_API\_ MatchMatrix \{}
\DoxyCodeLine{3496  \textcolor{keyword}{public}:}
\DoxyCodeLine{3497   MatchMatrix(\textcolor{keywordtype}{size\_t} num\_elements, \textcolor{keywordtype}{size\_t} num\_matchers)}
\DoxyCodeLine{3498       : num\_elements\_(num\_elements),}
\DoxyCodeLine{3499         num\_matchers\_(num\_matchers),}
\DoxyCodeLine{3500         matched\_(num\_elements\_ * num\_matchers\_, 0) \{\}}
\DoxyCodeLine{3501 }
\DoxyCodeLine{3502   \textcolor{keywordtype}{size\_t} LhsSize()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} num\_elements\_; \}}
\DoxyCodeLine{3503   \textcolor{keywordtype}{size\_t} RhsSize()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} num\_matchers\_; \}}
\DoxyCodeLine{3504   \textcolor{keywordtype}{bool} HasEdge(\textcolor{keywordtype}{size\_t} ilhs, \textcolor{keywordtype}{size\_t} irhs)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{3505     \textcolor{keywordflow}{return} matched\_[SpaceIndex(ilhs, irhs)] == 1;}
\DoxyCodeLine{3506   \}}
\DoxyCodeLine{3507   \textcolor{keywordtype}{void} SetEdge(\textcolor{keywordtype}{size\_t} ilhs, \textcolor{keywordtype}{size\_t} irhs, \textcolor{keywordtype}{bool} b) \{}
\DoxyCodeLine{3508     matched\_[SpaceIndex(ilhs, irhs)] = b ? 1 : 0;}
\DoxyCodeLine{3509   \}}
\DoxyCodeLine{3510 }
\DoxyCodeLine{3511   \textcolor{comment}{// Treating the connectivity matrix as a (LhsSize()*RhsSize())-\/bit number,}}
\DoxyCodeLine{3512   \textcolor{comment}{// adds 1 to that number; returns false if incrementing the graph left it}}
\DoxyCodeLine{3513   \textcolor{comment}{// empty.}}
\DoxyCodeLine{3514   \textcolor{keywordtype}{bool} NextGraph();}
\DoxyCodeLine{3515 }
\DoxyCodeLine{3516   \textcolor{keywordtype}{void} Randomize();}
\DoxyCodeLine{3517 }
\DoxyCodeLine{3518   std::string DebugString() \textcolor{keyword}{const};}
\DoxyCodeLine{3519 }
\DoxyCodeLine{3520  \textcolor{keyword}{private}:}
\DoxyCodeLine{3521   \textcolor{keywordtype}{size\_t} SpaceIndex(\textcolor{keywordtype}{size\_t} ilhs, \textcolor{keywordtype}{size\_t} irhs)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{3522     \textcolor{keywordflow}{return} ilhs * num\_matchers\_ + irhs;}
\DoxyCodeLine{3523   \}}
\DoxyCodeLine{3524 }
\DoxyCodeLine{3525   \textcolor{keywordtype}{size\_t} num\_elements\_;}
\DoxyCodeLine{3526   \textcolor{keywordtype}{size\_t} num\_matchers\_;}
\DoxyCodeLine{3527 }
\DoxyCodeLine{3528   \textcolor{comment}{// Each element is a char interpreted as bool. They are stored as a}}
\DoxyCodeLine{3529   \textcolor{comment}{// flattened array in lhs-\/major order, use 'SpaceIndex()' to translate}}
\DoxyCodeLine{3530   \textcolor{comment}{// a (ilhs, irhs) matrix coordinate into an offset.}}
\DoxyCodeLine{3531   ::std::vector<char> matched\_;}
\DoxyCodeLine{3532 \};}
\DoxyCodeLine{3533 }
\DoxyCodeLine{3534 typedef ::std::pair<size\_t, size\_t> ElementMatcherPair;}
\DoxyCodeLine{3535 typedef ::std::vector<ElementMatcherPair> ElementMatcherPairs;}
\DoxyCodeLine{3536 }
\DoxyCodeLine{3537 \textcolor{comment}{// Returns a maximum bipartite matching for the specified graph 'g'.}}
\DoxyCodeLine{3538 \textcolor{comment}{// The matching is represented as a vector of \{element, matcher\} pairs.}}
\DoxyCodeLine{3539 GTEST\_API\_ ElementMatcherPairs FindMaxBipartiteMatching(\textcolor{keyword}{const} MatchMatrix\& g);}
\DoxyCodeLine{3540 }
\DoxyCodeLine{3541 \textcolor{keyword}{struct }UnorderedMatcherRequire \{}
\DoxyCodeLine{3542   \textcolor{keyword}{enum} Flags \{}
\DoxyCodeLine{3543     Superset = 1 << 0,}
\DoxyCodeLine{3544     Subset = 1 << 1,}
\DoxyCodeLine{3545     ExactMatch = Superset | Subset,}
\DoxyCodeLine{3546   \};}
\DoxyCodeLine{3547 \};}
\DoxyCodeLine{3548 }
\DoxyCodeLine{3549 \textcolor{comment}{// Untyped base class for implementing UnorderedElementsAre.  By}}
\DoxyCodeLine{3550 \textcolor{comment}{// putting logic that's not specific to the element type here, we}}
\DoxyCodeLine{3551 \textcolor{comment}{// reduce binary bloat and increase compilation speed.}}
\DoxyCodeLine{3552 \textcolor{keyword}{class }GTEST\_API\_ UnorderedElementsAreMatcherImplBase \{}
\DoxyCodeLine{3553  \textcolor{keyword}{protected}:}
\DoxyCodeLine{3554   \textcolor{keyword}{explicit} UnorderedElementsAreMatcherImplBase(}
\DoxyCodeLine{3555       UnorderedMatcherRequire::Flags matcher\_flags)}
\DoxyCodeLine{3556       : match\_flags\_(matcher\_flags) \{\}}
\DoxyCodeLine{3557 }
\DoxyCodeLine{3558   \textcolor{comment}{// A vector of matcher describers, one for each element matcher.}}
\DoxyCodeLine{3559   \textcolor{comment}{// Does not own the describers (and thus can be used only when the}}
\DoxyCodeLine{3560   \textcolor{comment}{// element matchers are alive).}}
\DoxyCodeLine{3561   typedef ::std::vector<const MatcherDescriberInterface*> MatcherDescriberVec;}
\DoxyCodeLine{3562 }
\DoxyCodeLine{3563   \textcolor{comment}{// Describes this UnorderedElementsAre matcher.}}
\DoxyCodeLine{3564   \textcolor{keywordtype}{void} DescribeToImpl(::std::ostream* os) \textcolor{keyword}{const};}
\DoxyCodeLine{3565 }
\DoxyCodeLine{3566   \textcolor{comment}{// Describes the negation of this UnorderedElementsAre matcher.}}
\DoxyCodeLine{3567   \textcolor{keywordtype}{void} DescribeNegationToImpl(::std::ostream* os) \textcolor{keyword}{const};}
\DoxyCodeLine{3568 }
\DoxyCodeLine{3569   \textcolor{keywordtype}{bool} VerifyMatchMatrix(const ::std::vector<std::string>\& element\_printouts,}
\DoxyCodeLine{3570                          \textcolor{keyword}{const} MatchMatrix\& matrix,}
\DoxyCodeLine{3571                          MatchResultListener* listener) \textcolor{keyword}{const};}
\DoxyCodeLine{3572 }
\DoxyCodeLine{3573   \textcolor{keywordtype}{bool} FindPairing(\textcolor{keyword}{const} MatchMatrix\& matrix,}
\DoxyCodeLine{3574                    MatchResultListener* listener) \textcolor{keyword}{const};}
\DoxyCodeLine{3575 }
\DoxyCodeLine{3576   MatcherDescriberVec\& matcher\_describers() \{ \textcolor{keywordflow}{return} matcher\_describers\_; \}}
\DoxyCodeLine{3577 }
\DoxyCodeLine{3578   \textcolor{keyword}{static} Message Elements(\textcolor{keywordtype}{size\_t} n) \{}
\DoxyCodeLine{3579     \textcolor{keywordflow}{return} Message() << n << \textcolor{stringliteral}{"{} element"{}} << (n == 1 ? \textcolor{stringliteral}{"{}"{}} : \textcolor{stringliteral}{"{}s"{}});}
\DoxyCodeLine{3580   \}}
\DoxyCodeLine{3581 }
\DoxyCodeLine{3582   UnorderedMatcherRequire::Flags match\_flags()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} match\_flags\_; \}}
\DoxyCodeLine{3583 }
\DoxyCodeLine{3584  \textcolor{keyword}{private}:}
\DoxyCodeLine{3585   UnorderedMatcherRequire::Flags match\_flags\_;}
\DoxyCodeLine{3586   MatcherDescriberVec matcher\_describers\_;}
\DoxyCodeLine{3587 \};}
\DoxyCodeLine{3588 }
\DoxyCodeLine{3589 \textcolor{comment}{// Implements UnorderedElementsAre, UnorderedElementsAreArray, IsSubsetOf, and}}
\DoxyCodeLine{3590 \textcolor{comment}{// IsSupersetOf.}}
\DoxyCodeLine{3591 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Container>}
\DoxyCodeLine{3592 \textcolor{keyword}{class }UnorderedElementsAreMatcherImpl}
\DoxyCodeLine{3593     : \textcolor{keyword}{public} MatcherInterface<Container>,}
\DoxyCodeLine{3594       \textcolor{keyword}{public} UnorderedElementsAreMatcherImplBase \{}
\DoxyCodeLine{3595  \textcolor{keyword}{public}:}
\DoxyCodeLine{3596   \textcolor{keyword}{typedef} GTEST\_REMOVE\_REFERENCE\_AND\_CONST\_(Container) RawContainer;}
\DoxyCodeLine{3597   \textcolor{keyword}{typedef} internal::StlContainerView<RawContainer> View;}
\DoxyCodeLine{3598   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} View::type StlContainer;}
\DoxyCodeLine{3599   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} View::const\_reference StlContainerReference;}
\DoxyCodeLine{3600   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} StlContainer::value\_type Element;}
\DoxyCodeLine{3601 }
\DoxyCodeLine{3602   \textcolor{keyword}{template} <\textcolor{keyword}{typename} InputIter>}
\DoxyCodeLine{3603   UnorderedElementsAreMatcherImpl(UnorderedMatcherRequire::Flags matcher\_flags,}
\DoxyCodeLine{3604                                   InputIter first, InputIter last)}
\DoxyCodeLine{3605       : UnorderedElementsAreMatcherImplBase(matcher\_flags) \{}
\DoxyCodeLine{3606     \textcolor{keywordflow}{for} (; first != last; ++first) \{}
\DoxyCodeLine{3607       matchers\_.push\_back(MatcherCast<const Element\&>(*first));}
\DoxyCodeLine{3608     \}}
\DoxyCodeLine{3609     \textcolor{keywordflow}{for} (\textcolor{keyword}{const} \textcolor{keyword}{auto}\& m : matchers\_) \{}
\DoxyCodeLine{3610       matcher\_describers().push\_back(m.GetDescriber());}
\DoxyCodeLine{3611     \}}
\DoxyCodeLine{3612   \}}
\DoxyCodeLine{3613 }
\DoxyCodeLine{3614   \textcolor{comment}{// Describes what this matcher does.}}
\DoxyCodeLine{3615   \textcolor{keywordtype}{void} DescribeTo(::std::ostream* os)\textcolor{keyword}{ const override }\{}
\DoxyCodeLine{3616     \textcolor{keywordflow}{return} UnorderedElementsAreMatcherImplBase::DescribeToImpl(os);}
\DoxyCodeLine{3617   \}}
\DoxyCodeLine{3618 }
\DoxyCodeLine{3619   \textcolor{comment}{// Describes what the negation of this matcher does.}}
\DoxyCodeLine{3620   \textcolor{keywordtype}{void} DescribeNegationTo(::std::ostream* os)\textcolor{keyword}{ const override }\{}
\DoxyCodeLine{3621     \textcolor{keywordflow}{return} UnorderedElementsAreMatcherImplBase::DescribeNegationToImpl(os);}
\DoxyCodeLine{3622   \}}
\DoxyCodeLine{3623 }
\DoxyCodeLine{3624   \textcolor{keywordtype}{bool} MatchAndExplain(Container container,}
\DoxyCodeLine{3625                        MatchResultListener* listener)\textcolor{keyword}{ const override }\{}
\DoxyCodeLine{3626     StlContainerReference stl\_container = View::ConstReference(container);}
\DoxyCodeLine{3627     ::std::vector<std::string> element\_printouts;}
\DoxyCodeLine{3628     MatchMatrix matrix =}
\DoxyCodeLine{3629         AnalyzeElements(stl\_container.begin(), stl\_container.end(),}
\DoxyCodeLine{3630                         \&element\_printouts, listener);}
\DoxyCodeLine{3631 }
\DoxyCodeLine{3632     \textcolor{keywordflow}{if} (matrix.LhsSize() == 0 \&\& matrix.RhsSize() == 0) \{}
\DoxyCodeLine{3633       \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{3634     \}}
\DoxyCodeLine{3635 }
\DoxyCodeLine{3636     \textcolor{keywordflow}{if} (match\_flags() == UnorderedMatcherRequire::ExactMatch) \{}
\DoxyCodeLine{3637       \textcolor{keywordflow}{if} (matrix.LhsSize() != matrix.RhsSize()) \{}
\DoxyCodeLine{3638         \textcolor{comment}{// The element count doesn't match.  If the container is empty,}}
\DoxyCodeLine{3639         \textcolor{comment}{// there's no need to explain anything as Google Mock already}}
\DoxyCodeLine{3640         \textcolor{comment}{// prints the empty container. Otherwise we just need to show}}
\DoxyCodeLine{3641         \textcolor{comment}{// how many elements there actually are.}}
\DoxyCodeLine{3642         \textcolor{keywordflow}{if} (matrix.LhsSize() != 0 \&\& listener-\/>IsInterested()) \{}
\DoxyCodeLine{3643           *listener << \textcolor{stringliteral}{"{}which has "{}} << Elements(matrix.LhsSize());}
\DoxyCodeLine{3644         \}}
\DoxyCodeLine{3645         \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{3646       \}}
\DoxyCodeLine{3647     \}}
\DoxyCodeLine{3648 }
\DoxyCodeLine{3649     \textcolor{keywordflow}{return} VerifyMatchMatrix(element\_printouts, matrix, listener) \&\&}
\DoxyCodeLine{3650            FindPairing(matrix, listener);}
\DoxyCodeLine{3651   \}}
\DoxyCodeLine{3652 }
\DoxyCodeLine{3653  \textcolor{keyword}{private}:}
\DoxyCodeLine{3654   \textcolor{keyword}{template} <\textcolor{keyword}{typename} ElementIter>}
\DoxyCodeLine{3655   MatchMatrix AnalyzeElements(ElementIter elem\_first, ElementIter elem\_last,}
\DoxyCodeLine{3656                               ::std::vector<std::string>* element\_printouts,}
\DoxyCodeLine{3657                               MatchResultListener* listener)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{3658     element\_printouts-\/>clear();}
\DoxyCodeLine{3659     ::std::vector<char> did\_match;}
\DoxyCodeLine{3660     \textcolor{keywordtype}{size\_t} num\_elements = 0;}
\DoxyCodeLine{3661     DummyMatchResultListener dummy;}
\DoxyCodeLine{3662     \textcolor{keywordflow}{for} (; elem\_first != elem\_last; ++num\_elements, ++elem\_first) \{}
\DoxyCodeLine{3663       \textcolor{keywordflow}{if} (listener-\/>IsInterested()) \{}
\DoxyCodeLine{3664         element\_printouts-\/>push\_back(PrintToString(*elem\_first));}
\DoxyCodeLine{3665       \}}
\DoxyCodeLine{3666       \textcolor{keywordflow}{for} (\textcolor{keywordtype}{size\_t} irhs = 0; irhs != matchers\_.size(); ++irhs) \{}
\DoxyCodeLine{3667         did\_match.push\_back(}
\DoxyCodeLine{3668             matchers\_[irhs].MatchAndExplain(*elem\_first, \&dummy));}
\DoxyCodeLine{3669       \}}
\DoxyCodeLine{3670     \}}
\DoxyCodeLine{3671 }
\DoxyCodeLine{3672     MatchMatrix matrix(num\_elements, matchers\_.size());}
\DoxyCodeLine{3673     ::std::vector<char>::const\_iterator did\_match\_iter = did\_match.begin();}
\DoxyCodeLine{3674     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{size\_t} ilhs = 0; ilhs != num\_elements; ++ilhs) \{}
\DoxyCodeLine{3675       \textcolor{keywordflow}{for} (\textcolor{keywordtype}{size\_t} irhs = 0; irhs != matchers\_.size(); ++irhs) \{}
\DoxyCodeLine{3676         matrix.SetEdge(ilhs, irhs, *did\_match\_iter++ != 0);}
\DoxyCodeLine{3677       \}}
\DoxyCodeLine{3678     \}}
\DoxyCodeLine{3679     \textcolor{keywordflow}{return} matrix;}
\DoxyCodeLine{3680   \}}
\DoxyCodeLine{3681 }
\DoxyCodeLine{3682   ::std::vector<Matcher<const Element\&>> matchers\_;}
\DoxyCodeLine{3683 \};}
\DoxyCodeLine{3684 }
\DoxyCodeLine{3685 \textcolor{comment}{// Functor for use in TransformTuple.}}
\DoxyCodeLine{3686 \textcolor{comment}{// Performs MatcherCast<Target> on an input argument of any type.}}
\DoxyCodeLine{3687 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Target>}
\DoxyCodeLine{3688 \textcolor{keyword}{struct }CastAndAppendTransform \{}
\DoxyCodeLine{3689   \textcolor{keyword}{template} <\textcolor{keyword}{typename} Arg>}
\DoxyCodeLine{3690   Matcher<Target> operator()(\textcolor{keyword}{const} Arg\& a)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{3691     \textcolor{keywordflow}{return} MatcherCast<Target>(a);}
\DoxyCodeLine{3692   \}}
\DoxyCodeLine{3693 \};}
\DoxyCodeLine{3694 }
\DoxyCodeLine{3695 \textcolor{comment}{// Implements UnorderedElementsAre.}}
\DoxyCodeLine{3696 \textcolor{keyword}{template} <\textcolor{keyword}{typename} MatcherTuple>}
\DoxyCodeLine{3697 \textcolor{keyword}{class }UnorderedElementsAreMatcher \{}
\DoxyCodeLine{3698  \textcolor{keyword}{public}:}
\DoxyCodeLine{3699   \textcolor{keyword}{explicit} UnorderedElementsAreMatcher(\textcolor{keyword}{const} MatcherTuple\& args)}
\DoxyCodeLine{3700       : matchers\_(args) \{\}}
\DoxyCodeLine{3701 }
\DoxyCodeLine{3702   \textcolor{keyword}{template} <\textcolor{keyword}{typename} Container>}
\DoxyCodeLine{3703   \textcolor{keyword}{operator} Matcher<Container>()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{3704     \textcolor{keyword}{typedef} GTEST\_REMOVE\_REFERENCE\_AND\_CONST\_(Container) RawContainer;}
\DoxyCodeLine{3705     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} internal::StlContainerView<RawContainer>::type View;}
\DoxyCodeLine{3706     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} View::value\_type Element;}
\DoxyCodeLine{3707     typedef ::std::vector<Matcher<const Element\&>> MatcherVec;}
\DoxyCodeLine{3708     MatcherVec matchers;}
\DoxyCodeLine{3709     matchers.reserve(::std::tuple\_size<MatcherTuple>::value);}
\DoxyCodeLine{3710     TransformTupleValues(CastAndAppendTransform<const Element\&>(), matchers\_,}
\DoxyCodeLine{3711                          ::std::back\_inserter(matchers));}
\DoxyCodeLine{3712     \textcolor{keywordflow}{return} Matcher<Container>(}
\DoxyCodeLine{3713         \textcolor{keyword}{new} UnorderedElementsAreMatcherImpl<const Container\&>(}
\DoxyCodeLine{3714             UnorderedMatcherRequire::ExactMatch, matchers.begin(),}
\DoxyCodeLine{3715             matchers.end()));}
\DoxyCodeLine{3716   \}}
\DoxyCodeLine{3717 }
\DoxyCodeLine{3718  \textcolor{keyword}{private}:}
\DoxyCodeLine{3719   \textcolor{keyword}{const} MatcherTuple matchers\_;}
\DoxyCodeLine{3720 \};}
\DoxyCodeLine{3721 }
\DoxyCodeLine{3722 \textcolor{comment}{// Implements ElementsAre.}}
\DoxyCodeLine{3723 \textcolor{keyword}{template} <\textcolor{keyword}{typename} MatcherTuple>}
\DoxyCodeLine{3724 \textcolor{keyword}{class }ElementsAreMatcher \{}
\DoxyCodeLine{3725  \textcolor{keyword}{public}:}
\DoxyCodeLine{3726   \textcolor{keyword}{explicit} ElementsAreMatcher(\textcolor{keyword}{const} MatcherTuple\& args) : matchers\_(args) \{\}}
\DoxyCodeLine{3727 }
\DoxyCodeLine{3728   \textcolor{keyword}{template} <\textcolor{keyword}{typename} Container>}
\DoxyCodeLine{3729   \textcolor{keyword}{operator} Matcher<Container>()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{3730     \textcolor{keyword}{static\_assert}(}
\DoxyCodeLine{3731         !IsHashTable<GTEST\_REMOVE\_REFERENCE\_AND\_CONST\_(Container)>::value ||}
\DoxyCodeLine{3732             ::std::tuple\_size<MatcherTuple>::value < 2,}
\DoxyCodeLine{3733         \textcolor{stringliteral}{"{}use UnorderedElementsAre with hash tables"{}});}
\DoxyCodeLine{3734 }
\DoxyCodeLine{3735     \textcolor{keyword}{typedef} GTEST\_REMOVE\_REFERENCE\_AND\_CONST\_(Container) RawContainer;}
\DoxyCodeLine{3736     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} internal::StlContainerView<RawContainer>::type View;}
\DoxyCodeLine{3737     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} View::value\_type Element;}
\DoxyCodeLine{3738     typedef ::std::vector<Matcher<const Element\&>> MatcherVec;}
\DoxyCodeLine{3739     MatcherVec matchers;}
\DoxyCodeLine{3740     matchers.reserve(::std::tuple\_size<MatcherTuple>::value);}
\DoxyCodeLine{3741     TransformTupleValues(CastAndAppendTransform<const Element\&>(), matchers\_,}
\DoxyCodeLine{3742                          ::std::back\_inserter(matchers));}
\DoxyCodeLine{3743     \textcolor{keywordflow}{return} Matcher<Container>(\textcolor{keyword}{new} ElementsAreMatcherImpl<const Container\&>(}
\DoxyCodeLine{3744         matchers.begin(), matchers.end()));}
\DoxyCodeLine{3745   \}}
\DoxyCodeLine{3746 }
\DoxyCodeLine{3747  \textcolor{keyword}{private}:}
\DoxyCodeLine{3748   \textcolor{keyword}{const} MatcherTuple matchers\_;}
\DoxyCodeLine{3749 \};}
\DoxyCodeLine{3750 }
\DoxyCodeLine{3751 \textcolor{comment}{// Implements UnorderedElementsAreArray(), IsSubsetOf(), and IsSupersetOf().}}
\DoxyCodeLine{3752 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{3753 \textcolor{keyword}{class }UnorderedElementsAreArrayMatcher \{}
\DoxyCodeLine{3754  \textcolor{keyword}{public}:}
\DoxyCodeLine{3755   \textcolor{keyword}{template} <\textcolor{keyword}{typename} Iter>}
\DoxyCodeLine{3756   UnorderedElementsAreArrayMatcher(UnorderedMatcherRequire::Flags match\_flags,}
\DoxyCodeLine{3757                                    Iter first, Iter last)}
\DoxyCodeLine{3758       : match\_flags\_(match\_flags), matchers\_(first, last) \{\}}
\DoxyCodeLine{3759 }
\DoxyCodeLine{3760   \textcolor{keyword}{template} <\textcolor{keyword}{typename} Container>}
\DoxyCodeLine{3761   \textcolor{keyword}{operator} Matcher<Container>()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{3762     \textcolor{keywordflow}{return} Matcher<Container>(}
\DoxyCodeLine{3763         \textcolor{keyword}{new} UnorderedElementsAreMatcherImpl<const Container\&>(}
\DoxyCodeLine{3764             match\_flags\_, matchers\_.begin(), matchers\_.end()));}
\DoxyCodeLine{3765   \}}
\DoxyCodeLine{3766 }
\DoxyCodeLine{3767  \textcolor{keyword}{private}:}
\DoxyCodeLine{3768   UnorderedMatcherRequire::Flags match\_flags\_;}
\DoxyCodeLine{3769   ::std::vector<T> matchers\_;}
\DoxyCodeLine{3770 \};}
\DoxyCodeLine{3771 }
\DoxyCodeLine{3772 \textcolor{comment}{// Implements ElementsAreArray().}}
\DoxyCodeLine{3773 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{3774 \textcolor{keyword}{class }ElementsAreArrayMatcher \{}
\DoxyCodeLine{3775  \textcolor{keyword}{public}:}
\DoxyCodeLine{3776   \textcolor{keyword}{template} <\textcolor{keyword}{typename} Iter>}
\DoxyCodeLine{3777   ElementsAreArrayMatcher(Iter first, Iter last) : matchers\_(first, last) \{\}}
\DoxyCodeLine{3778 }
\DoxyCodeLine{3779   \textcolor{keyword}{template} <\textcolor{keyword}{typename} Container>}
\DoxyCodeLine{3780   \textcolor{keyword}{operator} Matcher<Container>()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{3781     \textcolor{keyword}{static\_assert}(}
\DoxyCodeLine{3782         !IsHashTable<GTEST\_REMOVE\_REFERENCE\_AND\_CONST\_(Container)>::value,}
\DoxyCodeLine{3783         \textcolor{stringliteral}{"{}use UnorderedElementsAreArray with hash tables"{}});}
\DoxyCodeLine{3784 }
\DoxyCodeLine{3785     \textcolor{keywordflow}{return} Matcher<Container>(\textcolor{keyword}{new} ElementsAreMatcherImpl<const Container\&>(}
\DoxyCodeLine{3786         matchers\_.begin(), matchers\_.end()));}
\DoxyCodeLine{3787   \}}
\DoxyCodeLine{3788 }
\DoxyCodeLine{3789  \textcolor{keyword}{private}:}
\DoxyCodeLine{3790   const ::std::vector<T> matchers\_;}
\DoxyCodeLine{3791 \};}
\DoxyCodeLine{3792 }
\DoxyCodeLine{3793 \textcolor{comment}{// Given a 2-\/tuple matcher tm of type Tuple2Matcher and a value second}}
\DoxyCodeLine{3794 \textcolor{comment}{// of type Second, BoundSecondMatcher<Tuple2Matcher, Second>(tm,}}
\DoxyCodeLine{3795 \textcolor{comment}{// second) is a polymorphic matcher that matches a value x if and only if}}
\DoxyCodeLine{3796 \textcolor{comment}{// tm matches tuple (x, second).  Useful for implementing}}
\DoxyCodeLine{3797 \textcolor{comment}{// UnorderedPointwise() in terms of UnorderedElementsAreArray().}}
\DoxyCodeLine{3798 \textcolor{comment}{//}}
\DoxyCodeLine{3799 \textcolor{comment}{// BoundSecondMatcher is copyable and assignable, as we need to put}}
\DoxyCodeLine{3800 \textcolor{comment}{// instances of this class in a vector when implementing}}
\DoxyCodeLine{3801 \textcolor{comment}{// UnorderedPointwise().}}
\DoxyCodeLine{3802 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Tuple2Matcher, \textcolor{keyword}{typename} Second>}
\DoxyCodeLine{3803 \textcolor{keyword}{class }BoundSecondMatcher \{}
\DoxyCodeLine{3804  \textcolor{keyword}{public}:}
\DoxyCodeLine{3805   BoundSecondMatcher(\textcolor{keyword}{const} Tuple2Matcher\& tm, \textcolor{keyword}{const} Second\& second)}
\DoxyCodeLine{3806       : tuple2\_matcher\_(tm), second\_value\_(second) \{\}}
\DoxyCodeLine{3807 }
\DoxyCodeLine{3808   BoundSecondMatcher(\textcolor{keyword}{const} BoundSecondMatcher\& other) = \textcolor{keywordflow}{default};}
\DoxyCodeLine{3809 }
\DoxyCodeLine{3810   \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{3811   \textcolor{keyword}{operator} Matcher<T>()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{3812     \textcolor{keywordflow}{return} MakeMatcher(\textcolor{keyword}{new} Impl<T>(tuple2\_matcher\_, second\_value\_));}
\DoxyCodeLine{3813   \}}
\DoxyCodeLine{3814 }
\DoxyCodeLine{3815   \textcolor{comment}{// We have to define this for UnorderedPointwise() to compile in}}
\DoxyCodeLine{3816   \textcolor{comment}{// C++98 mode, as it puts BoundSecondMatcher instances in a vector,}}
\DoxyCodeLine{3817   \textcolor{comment}{// which requires the elements to be assignable in C++98.  The}}
\DoxyCodeLine{3818   \textcolor{comment}{// compiler cannot generate the operator= for us, as Tuple2Matcher}}
\DoxyCodeLine{3819   \textcolor{comment}{// and Second may not be assignable.}}
\DoxyCodeLine{3820   \textcolor{comment}{//}}
\DoxyCodeLine{3821   \textcolor{comment}{// However, this should never be called, so the implementation just}}
\DoxyCodeLine{3822   \textcolor{comment}{// need to assert.}}
\DoxyCodeLine{3823   \textcolor{keywordtype}{void} operator=(\textcolor{keyword}{const} BoundSecondMatcher\& \textcolor{comment}{/*rhs*/}) \{}
\DoxyCodeLine{3824     GTEST\_LOG\_(FATAL) << \textcolor{stringliteral}{"{}BoundSecondMatcher should never be assigned."{}};}
\DoxyCodeLine{3825   \}}
\DoxyCodeLine{3826 }
\DoxyCodeLine{3827  \textcolor{keyword}{private}:}
\DoxyCodeLine{3828   \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{3829   \textcolor{keyword}{class }Impl : \textcolor{keyword}{public} MatcherInterface<T> \{}
\DoxyCodeLine{3830    \textcolor{keyword}{public}:}
\DoxyCodeLine{3831     typedef ::std::tuple<T, Second> ArgTuple;}
\DoxyCodeLine{3832 }
\DoxyCodeLine{3833     Impl(\textcolor{keyword}{const} Tuple2Matcher\& tm, \textcolor{keyword}{const} Second\& second)}
\DoxyCodeLine{3834         : mono\_tuple2\_matcher\_(SafeMatcherCast<const ArgTuple\&>(tm)),}
\DoxyCodeLine{3835           second\_value\_(second) \{\}}
\DoxyCodeLine{3836 }
\DoxyCodeLine{3837     \textcolor{keywordtype}{void} DescribeTo(::std::ostream* os)\textcolor{keyword}{ const override }\{}
\DoxyCodeLine{3838       *os << \textcolor{stringliteral}{"{}and "{}};}
\DoxyCodeLine{3839       UniversalPrint(second\_value\_, os);}
\DoxyCodeLine{3840       *os << \textcolor{stringliteral}{"{} "{}};}
\DoxyCodeLine{3841       mono\_tuple2\_matcher\_.DescribeTo(os);}
\DoxyCodeLine{3842     \}}
\DoxyCodeLine{3843 }
\DoxyCodeLine{3844     \textcolor{keywordtype}{bool} MatchAndExplain(T x, MatchResultListener* listener)\textcolor{keyword}{ const override }\{}
\DoxyCodeLine{3845       \textcolor{keywordflow}{return} mono\_tuple2\_matcher\_.MatchAndExplain(ArgTuple(x, second\_value\_),}
\DoxyCodeLine{3846                                                   listener);}
\DoxyCodeLine{3847     \}}
\DoxyCodeLine{3848 }
\DoxyCodeLine{3849    \textcolor{keyword}{private}:}
\DoxyCodeLine{3850     \textcolor{keyword}{const} Matcher<const ArgTuple\&> mono\_tuple2\_matcher\_;}
\DoxyCodeLine{3851     \textcolor{keyword}{const} Second second\_value\_;}
\DoxyCodeLine{3852   \};}
\DoxyCodeLine{3853 }
\DoxyCodeLine{3854   \textcolor{keyword}{const} Tuple2Matcher tuple2\_matcher\_;}
\DoxyCodeLine{3855   \textcolor{keyword}{const} Second second\_value\_;}
\DoxyCodeLine{3856 \};}
\DoxyCodeLine{3857 }
\DoxyCodeLine{3858 \textcolor{comment}{// Given a 2-\/tuple matcher tm and a value second,}}
\DoxyCodeLine{3859 \textcolor{comment}{// MatcherBindSecond(tm, second) returns a matcher that matches a}}
\DoxyCodeLine{3860 \textcolor{comment}{// value x if and only if tm matches tuple (x, second).  Useful for}}
\DoxyCodeLine{3861 \textcolor{comment}{// implementing UnorderedPointwise() in terms of UnorderedElementsAreArray().}}
\DoxyCodeLine{3862 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Tuple2Matcher, \textcolor{keyword}{typename} Second>}
\DoxyCodeLine{3863 BoundSecondMatcher<Tuple2Matcher, Second> MatcherBindSecond(}
\DoxyCodeLine{3864     \textcolor{keyword}{const} Tuple2Matcher\& tm, \textcolor{keyword}{const} Second\& second) \{}
\DoxyCodeLine{3865   \textcolor{keywordflow}{return} BoundSecondMatcher<Tuple2Matcher, Second>(tm, second);}
\DoxyCodeLine{3866 \}}
\DoxyCodeLine{3867 }
\DoxyCodeLine{3868 \textcolor{comment}{// Returns the description for a matcher defined using the MATCHER*()}}
\DoxyCodeLine{3869 \textcolor{comment}{// macro where the user-\/supplied description string is "{}"{}, if}}
\DoxyCodeLine{3870 \textcolor{comment}{// 'negation' is false; otherwise returns the description of the}}
\DoxyCodeLine{3871 \textcolor{comment}{// negation of the matcher.  'param\_values' contains a list of strings}}
\DoxyCodeLine{3872 \textcolor{comment}{// that are the print-\/out of the matcher's parameters.}}
\DoxyCodeLine{3873 GTEST\_API\_ std::string FormatMatcherDescription(}
\DoxyCodeLine{3874     \textcolor{keywordtype}{bool} negation, \textcolor{keyword}{const} \textcolor{keywordtype}{char}* matcher\_name,}
\DoxyCodeLine{3875     \textcolor{keyword}{const} std::vector<const char*>\& param\_names, \textcolor{keyword}{const} Strings\& param\_values);}
\DoxyCodeLine{3876 }
\DoxyCodeLine{3877 \textcolor{comment}{// Implements a matcher that checks the value of a optional<> type variable.}}
\DoxyCodeLine{3878 \textcolor{keyword}{template} <\textcolor{keyword}{typename} ValueMatcher>}
\DoxyCodeLine{3879 \textcolor{keyword}{class }OptionalMatcher \{}
\DoxyCodeLine{3880  \textcolor{keyword}{public}:}
\DoxyCodeLine{3881   \textcolor{keyword}{explicit} OptionalMatcher(\textcolor{keyword}{const} ValueMatcher\& value\_matcher)}
\DoxyCodeLine{3882       : value\_matcher\_(value\_matcher) \{\}}
\DoxyCodeLine{3883 }
\DoxyCodeLine{3884   \textcolor{keyword}{template} <\textcolor{keyword}{typename} Optional>}
\DoxyCodeLine{3885   \textcolor{keyword}{operator} Matcher<Optional>()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{3886     \textcolor{keywordflow}{return} Matcher<Optional>(\textcolor{keyword}{new} Impl<const Optional\&>(value\_matcher\_));}
\DoxyCodeLine{3887   \}}
\DoxyCodeLine{3888 }
\DoxyCodeLine{3889   \textcolor{keyword}{template} <\textcolor{keyword}{typename} Optional>}
\DoxyCodeLine{3890   \textcolor{keyword}{class }Impl : \textcolor{keyword}{public} MatcherInterface<Optional> \{}
\DoxyCodeLine{3891    \textcolor{keyword}{public}:}
\DoxyCodeLine{3892     \textcolor{keyword}{typedef} GTEST\_REMOVE\_REFERENCE\_AND\_CONST\_(Optional) OptionalView;}
\DoxyCodeLine{3893     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} OptionalView::value\_type ValueType;}
\DoxyCodeLine{3894     \textcolor{keyword}{explicit} Impl(\textcolor{keyword}{const} ValueMatcher\& value\_matcher)}
\DoxyCodeLine{3895         : value\_matcher\_(MatcherCast<ValueType>(value\_matcher)) \{\}}
\DoxyCodeLine{3896 }
\DoxyCodeLine{3897     \textcolor{keywordtype}{void} DescribeTo(::std::ostream* os)\textcolor{keyword}{ const override }\{}
\DoxyCodeLine{3898       *os << \textcolor{stringliteral}{"{}value "{}};}
\DoxyCodeLine{3899       value\_matcher\_.DescribeTo(os);}
\DoxyCodeLine{3900     \}}
\DoxyCodeLine{3901 }
\DoxyCodeLine{3902     \textcolor{keywordtype}{void} DescribeNegationTo(::std::ostream* os)\textcolor{keyword}{ const override }\{}
\DoxyCodeLine{3903       *os << \textcolor{stringliteral}{"{}value "{}};}
\DoxyCodeLine{3904       value\_matcher\_.DescribeNegationTo(os);}
\DoxyCodeLine{3905     \}}
\DoxyCodeLine{3906 }
\DoxyCodeLine{3907     \textcolor{keywordtype}{bool} MatchAndExplain(Optional optional,}
\DoxyCodeLine{3908                          MatchResultListener* listener)\textcolor{keyword}{ const override }\{}
\DoxyCodeLine{3909       \textcolor{keywordflow}{if} (!optional) \{}
\DoxyCodeLine{3910         *listener << \textcolor{stringliteral}{"{}which is not engaged"{}};}
\DoxyCodeLine{3911         \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{3912       \}}
\DoxyCodeLine{3913       \textcolor{keyword}{const} ValueType\& value = *optional;}
\DoxyCodeLine{3914       StringMatchResultListener value\_listener;}
\DoxyCodeLine{3915       \textcolor{keyword}{const} \textcolor{keywordtype}{bool} match = value\_matcher\_.MatchAndExplain(value, \&value\_listener);}
\DoxyCodeLine{3916       *listener << \textcolor{stringliteral}{"{}whose value "{}} << PrintToString(value)}
\DoxyCodeLine{3917                 << (match ? \textcolor{stringliteral}{"{} matches"{}} : \textcolor{stringliteral}{"{} doesn't match"{}});}
\DoxyCodeLine{3918       PrintIfNotEmpty(value\_listener.str(), listener-\/>stream());}
\DoxyCodeLine{3919       \textcolor{keywordflow}{return} match;}
\DoxyCodeLine{3920     \}}
\DoxyCodeLine{3921 }
\DoxyCodeLine{3922    \textcolor{keyword}{private}:}
\DoxyCodeLine{3923     \textcolor{keyword}{const} Matcher<ValueType> value\_matcher\_;}
\DoxyCodeLine{3924   \};}
\DoxyCodeLine{3925 }
\DoxyCodeLine{3926  \textcolor{keyword}{private}:}
\DoxyCodeLine{3927   \textcolor{keyword}{const} ValueMatcher value\_matcher\_;}
\DoxyCodeLine{3928 \};}
\DoxyCodeLine{3929 }
\DoxyCodeLine{3930 \textcolor{keyword}{namespace }variant\_matcher \{}
\DoxyCodeLine{3931 \textcolor{comment}{// Overloads to allow VariantMatcher to do proper ADL lookup.}}
\DoxyCodeLine{3932 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{3933 \textcolor{keywordtype}{void} holds\_alternative() \{\}}
\DoxyCodeLine{3934 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{3935 \textcolor{keywordtype}{void} get() \{\}}
\DoxyCodeLine{3936 }
\DoxyCodeLine{3937 \textcolor{comment}{// Implements a matcher that checks the value of a variant<> type variable.}}
\DoxyCodeLine{3938 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{3939 \textcolor{keyword}{class }VariantMatcher \{}
\DoxyCodeLine{3940  \textcolor{keyword}{public}:}
\DoxyCodeLine{3941   \textcolor{keyword}{explicit} VariantMatcher(\mbox{\hyperlink{classtesting_1_1Matcher}{::testing::Matcher<const T\&>}} matcher)}
\DoxyCodeLine{3942       : matcher\_(std::move(matcher)) \{\}}
\DoxyCodeLine{3943 }
\DoxyCodeLine{3944   \textcolor{keyword}{template} <\textcolor{keyword}{typename} Variant>}
\DoxyCodeLine{3945   \textcolor{keywordtype}{bool} MatchAndExplain(\textcolor{keyword}{const} Variant\& value,}
\DoxyCodeLine{3946                        ::testing::MatchResultListener* listener)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{3947     \textcolor{keyword}{using }std::get;}
\DoxyCodeLine{3948     \textcolor{keywordflow}{if} (!listener-\/>IsInterested()) \{}
\DoxyCodeLine{3949       \textcolor{keywordflow}{return} holds\_alternative<T>(value) \&\& matcher\_.Matches(get<T>(value));}
\DoxyCodeLine{3950     \}}
\DoxyCodeLine{3951 }
\DoxyCodeLine{3952     \textcolor{keywordflow}{if} (!holds\_alternative<T>(value)) \{}
\DoxyCodeLine{3953       *listener << \textcolor{stringliteral}{"{}whose value is not of type '"{}} << GetTypeName() << \textcolor{stringliteral}{"{}'"{}};}
\DoxyCodeLine{3954       \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{3955     \}}
\DoxyCodeLine{3956 }
\DoxyCodeLine{3957     \textcolor{keyword}{const} T\& elem = get<T>(value);}
\DoxyCodeLine{3958     StringMatchResultListener elem\_listener;}
\DoxyCodeLine{3959     \textcolor{keyword}{const} \textcolor{keywordtype}{bool} match = matcher\_.MatchAndExplain(elem, \&elem\_listener);}
\DoxyCodeLine{3960     *listener << \textcolor{stringliteral}{"{}whose value "{}} << PrintToString(elem)}
\DoxyCodeLine{3961               << (match ? \textcolor{stringliteral}{"{} matches"{}} : \textcolor{stringliteral}{"{} doesn't match"{}});}
\DoxyCodeLine{3962     PrintIfNotEmpty(elem\_listener.str(), listener-\/>stream());}
\DoxyCodeLine{3963     \textcolor{keywordflow}{return} match;}
\DoxyCodeLine{3964   \}}
\DoxyCodeLine{3965 }
\DoxyCodeLine{3966   \textcolor{keywordtype}{void} DescribeTo(std::ostream* os)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{3967     *os << \textcolor{stringliteral}{"{}is a variant<> with value of type '"{}} << GetTypeName()}
\DoxyCodeLine{3968         << \textcolor{stringliteral}{"{}' and the value "{}};}
\DoxyCodeLine{3969     matcher\_.DescribeTo(os);}
\DoxyCodeLine{3970   \}}
\DoxyCodeLine{3971 }
\DoxyCodeLine{3972   \textcolor{keywordtype}{void} DescribeNegationTo(std::ostream* os)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{3973     *os << \textcolor{stringliteral}{"{}is a variant<> with value of type other than '"{}} << GetTypeName()}
\DoxyCodeLine{3974         << \textcolor{stringliteral}{"{}' or the value "{}};}
\DoxyCodeLine{3975     matcher\_.DescribeNegationTo(os);}
\DoxyCodeLine{3976   \}}
\DoxyCodeLine{3977 }
\DoxyCodeLine{3978  \textcolor{keyword}{private}:}
\DoxyCodeLine{3979   \textcolor{keyword}{static} std::string GetTypeName() \{}
\DoxyCodeLine{3980 \textcolor{preprocessor}{\#if GTEST\_HAS\_RTTI}}
\DoxyCodeLine{3981     GTEST\_SUPPRESS\_UNREACHABLE\_CODE\_WARNING\_BELOW\_(}
\DoxyCodeLine{3982         \textcolor{keywordflow}{return} internal::GetTypeName<T>());}
\DoxyCodeLine{3983 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{3984     \textcolor{keywordflow}{return} \textcolor{stringliteral}{"{}the element type"{}};}
\DoxyCodeLine{3985   \}}
\DoxyCodeLine{3986 }
\DoxyCodeLine{3987   const ::testing::Matcher<const T\&> matcher\_;}
\DoxyCodeLine{3988 \};}
\DoxyCodeLine{3989 }
\DoxyCodeLine{3990 \}  \textcolor{comment}{// namespace variant\_matcher}}
\DoxyCodeLine{3991 }
\DoxyCodeLine{3992 \textcolor{keyword}{namespace }any\_cast\_matcher \{}
\DoxyCodeLine{3993 }
\DoxyCodeLine{3994 \textcolor{comment}{// Overloads to allow AnyCastMatcher to do proper ADL lookup.}}
\DoxyCodeLine{3995 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{3996 \textcolor{keywordtype}{void} any\_cast() \{\}}
\DoxyCodeLine{3997 }
\DoxyCodeLine{3998 \textcolor{comment}{// Implements a matcher that any\_casts the value.}}
\DoxyCodeLine{3999 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{4000 \textcolor{keyword}{class }AnyCastMatcher \{}
\DoxyCodeLine{4001  \textcolor{keyword}{public}:}
\DoxyCodeLine{4002   \textcolor{keyword}{explicit} AnyCastMatcher(const ::testing::Matcher<const T\&>\& matcher)}
\DoxyCodeLine{4003       : matcher\_(matcher) \{\}}
\DoxyCodeLine{4004 }
\DoxyCodeLine{4005   \textcolor{keyword}{template} <\textcolor{keyword}{typename} AnyType>}
\DoxyCodeLine{4006   \textcolor{keywordtype}{bool} MatchAndExplain(\textcolor{keyword}{const} AnyType\& value,}
\DoxyCodeLine{4007                        ::testing::MatchResultListener* listener)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{4008     \textcolor{keywordflow}{if} (!listener-\/>IsInterested()) \{}
\DoxyCodeLine{4009       \textcolor{keyword}{const} T* ptr = any\_cast<T>(\&value);}
\DoxyCodeLine{4010       \textcolor{keywordflow}{return} ptr != \textcolor{keyword}{nullptr} \&\& matcher\_.Matches(*ptr);}
\DoxyCodeLine{4011     \}}
\DoxyCodeLine{4012 }
\DoxyCodeLine{4013     \textcolor{keyword}{const} T* elem = any\_cast<T>(\&value);}
\DoxyCodeLine{4014     \textcolor{keywordflow}{if} (elem == \textcolor{keyword}{nullptr}) \{}
\DoxyCodeLine{4015       *listener << \textcolor{stringliteral}{"{}whose value is not of type '"{}} << GetTypeName() << \textcolor{stringliteral}{"{}'"{}};}
\DoxyCodeLine{4016       \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{4017     \}}
\DoxyCodeLine{4018 }
\DoxyCodeLine{4019     StringMatchResultListener elem\_listener;}
\DoxyCodeLine{4020     \textcolor{keyword}{const} \textcolor{keywordtype}{bool} match = matcher\_.MatchAndExplain(*elem, \&elem\_listener);}
\DoxyCodeLine{4021     *listener << \textcolor{stringliteral}{"{}whose value "{}} << PrintToString(*elem)}
\DoxyCodeLine{4022               << (match ? \textcolor{stringliteral}{"{} matches"{}} : \textcolor{stringliteral}{"{} doesn't match"{}});}
\DoxyCodeLine{4023     PrintIfNotEmpty(elem\_listener.str(), listener-\/>stream());}
\DoxyCodeLine{4024     \textcolor{keywordflow}{return} match;}
\DoxyCodeLine{4025   \}}
\DoxyCodeLine{4026 }
\DoxyCodeLine{4027   \textcolor{keywordtype}{void} DescribeTo(std::ostream* os)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{4028     *os << \textcolor{stringliteral}{"{}is an 'any' type with value of type '"{}} << GetTypeName()}
\DoxyCodeLine{4029         << \textcolor{stringliteral}{"{}' and the value "{}};}
\DoxyCodeLine{4030     matcher\_.DescribeTo(os);}
\DoxyCodeLine{4031   \}}
\DoxyCodeLine{4032 }
\DoxyCodeLine{4033   \textcolor{keywordtype}{void} DescribeNegationTo(std::ostream* os)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{4034     *os << \textcolor{stringliteral}{"{}is an 'any' type with value of type other than '"{}} << GetTypeName()}
\DoxyCodeLine{4035         << \textcolor{stringliteral}{"{}' or the value "{}};}
\DoxyCodeLine{4036     matcher\_.DescribeNegationTo(os);}
\DoxyCodeLine{4037   \}}
\DoxyCodeLine{4038 }
\DoxyCodeLine{4039  \textcolor{keyword}{private}:}
\DoxyCodeLine{4040   \textcolor{keyword}{static} std::string GetTypeName() \{}
\DoxyCodeLine{4041 \textcolor{preprocessor}{\#if GTEST\_HAS\_RTTI}}
\DoxyCodeLine{4042     GTEST\_SUPPRESS\_UNREACHABLE\_CODE\_WARNING\_BELOW\_(}
\DoxyCodeLine{4043         \textcolor{keywordflow}{return} internal::GetTypeName<T>());}
\DoxyCodeLine{4044 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{4045     \textcolor{keywordflow}{return} \textcolor{stringliteral}{"{}the element type"{}};}
\DoxyCodeLine{4046   \}}
\DoxyCodeLine{4047 }
\DoxyCodeLine{4048   const ::testing::Matcher<const T\&> matcher\_;}
\DoxyCodeLine{4049 \};}
\DoxyCodeLine{4050 }
\DoxyCodeLine{4051 \}  \textcolor{comment}{// namespace any\_cast\_matcher}}
\DoxyCodeLine{4052 }
\DoxyCodeLine{4053 \textcolor{comment}{// Implements the Args() matcher.}}
\DoxyCodeLine{4054 \textcolor{keyword}{template} <\textcolor{keyword}{class }ArgsTuple, \textcolor{keywordtype}{size\_t}... k>}
\DoxyCodeLine{4055 \textcolor{keyword}{class }ArgsMatcherImpl : \textcolor{keyword}{public} MatcherInterface<ArgsTuple> \{}
\DoxyCodeLine{4056  \textcolor{keyword}{public}:}
\DoxyCodeLine{4057   \textcolor{keyword}{using }RawArgsTuple = \textcolor{keyword}{typename} std::decay<ArgsTuple>::type;}
\DoxyCodeLine{4058   \textcolor{keyword}{using }SelectedArgs =}
\DoxyCodeLine{4059       std::tuple<typename std::tuple\_element<k, RawArgsTuple>::type...>;}
\DoxyCodeLine{4060   \textcolor{keyword}{using }MonomorphicInnerMatcher = Matcher<const SelectedArgs\&>;}
\DoxyCodeLine{4061 }
\DoxyCodeLine{4062   \textcolor{keyword}{template} <\textcolor{keyword}{typename} InnerMatcher>}
\DoxyCodeLine{4063   \textcolor{keyword}{explicit} ArgsMatcherImpl(\textcolor{keyword}{const} InnerMatcher\& inner\_matcher)}
\DoxyCodeLine{4064       : inner\_matcher\_(SafeMatcherCast<const SelectedArgs\&>(inner\_matcher)) \{\}}
\DoxyCodeLine{4065 }
\DoxyCodeLine{4066   \textcolor{keywordtype}{bool} MatchAndExplain(ArgsTuple args,}
\DoxyCodeLine{4067                        MatchResultListener* listener)\textcolor{keyword}{ const override }\{}
\DoxyCodeLine{4068     \textcolor{comment}{// Workaround spurious C4100 on MSVC<=15.7 when k is empty.}}
\DoxyCodeLine{4069     (void)args;}
\DoxyCodeLine{4070     \textcolor{keyword}{const} SelectedArgs\& selected\_args =}
\DoxyCodeLine{4071         std::forward\_as\_tuple(std::get<k>(args)...);}
\DoxyCodeLine{4072     \textcolor{keywordflow}{if} (!listener-\/>IsInterested()) \textcolor{keywordflow}{return} inner\_matcher\_.Matches(selected\_args);}
\DoxyCodeLine{4073 }
\DoxyCodeLine{4074     PrintIndices(listener-\/>stream());}
\DoxyCodeLine{4075     *listener << \textcolor{stringliteral}{"{}are "{}} << PrintToString(selected\_args);}
\DoxyCodeLine{4076 }
\DoxyCodeLine{4077     StringMatchResultListener inner\_listener;}
\DoxyCodeLine{4078     \textcolor{keyword}{const} \textcolor{keywordtype}{bool} match =}
\DoxyCodeLine{4079         inner\_matcher\_.MatchAndExplain(selected\_args, \&inner\_listener);}
\DoxyCodeLine{4080     PrintIfNotEmpty(inner\_listener.str(), listener-\/>stream());}
\DoxyCodeLine{4081     \textcolor{keywordflow}{return} match;}
\DoxyCodeLine{4082   \}}
\DoxyCodeLine{4083 }
\DoxyCodeLine{4084   \textcolor{keywordtype}{void} DescribeTo(::std::ostream* os)\textcolor{keyword}{ const override }\{}
\DoxyCodeLine{4085     *os << \textcolor{stringliteral}{"{}are a tuple "{}};}
\DoxyCodeLine{4086     PrintIndices(os);}
\DoxyCodeLine{4087     inner\_matcher\_.DescribeTo(os);}
\DoxyCodeLine{4088   \}}
\DoxyCodeLine{4089 }
\DoxyCodeLine{4090   \textcolor{keywordtype}{void} DescribeNegationTo(::std::ostream* os)\textcolor{keyword}{ const override }\{}
\DoxyCodeLine{4091     *os << \textcolor{stringliteral}{"{}are a tuple "{}};}
\DoxyCodeLine{4092     PrintIndices(os);}
\DoxyCodeLine{4093     inner\_matcher\_.DescribeNegationTo(os);}
\DoxyCodeLine{4094   \}}
\DoxyCodeLine{4095 }
\DoxyCodeLine{4096  \textcolor{keyword}{private}:}
\DoxyCodeLine{4097   \textcolor{comment}{// Prints the indices of the selected fields.}}
\DoxyCodeLine{4098   \textcolor{keyword}{static} \textcolor{keywordtype}{void} PrintIndices(::std::ostream* os) \{}
\DoxyCodeLine{4099     *os << \textcolor{stringliteral}{"{}whose fields ("{}};}
\DoxyCodeLine{4100     \textcolor{keyword}{const} \textcolor{keywordtype}{char}* sep = \textcolor{stringliteral}{"{}"{}};}
\DoxyCodeLine{4101     \textcolor{comment}{// Workaround spurious C4189 on MSVC<=15.7 when k is empty.}}
\DoxyCodeLine{4102     (void)sep;}
\DoxyCodeLine{4103     \textcolor{keyword}{const} \textcolor{keywordtype}{char}* dummy[] = \{\textcolor{stringliteral}{"{}"{}}, (*os << sep << \textcolor{stringliteral}{"{}\#"{}} << k, sep = \textcolor{stringliteral}{"{}, "{}})...\};}
\DoxyCodeLine{4104     (void)dummy;}
\DoxyCodeLine{4105     *os << \textcolor{stringliteral}{"{}) "{}};}
\DoxyCodeLine{4106   \}}
\DoxyCodeLine{4107 }
\DoxyCodeLine{4108   MonomorphicInnerMatcher inner\_matcher\_;}
\DoxyCodeLine{4109 \};}
\DoxyCodeLine{4110 }
\DoxyCodeLine{4111 \textcolor{keyword}{template} <\textcolor{keyword}{class }InnerMatcher, \textcolor{keywordtype}{size\_t}... k>}
\DoxyCodeLine{4112 \textcolor{keyword}{class }ArgsMatcher \{}
\DoxyCodeLine{4113  \textcolor{keyword}{public}:}
\DoxyCodeLine{4114   \textcolor{keyword}{explicit} ArgsMatcher(InnerMatcher inner\_matcher)}
\DoxyCodeLine{4115       : inner\_matcher\_(std::move(inner\_matcher)) \{\}}
\DoxyCodeLine{4116 }
\DoxyCodeLine{4117   \textcolor{keyword}{template} <\textcolor{keyword}{typename} ArgsTuple>}
\DoxyCodeLine{4118   \textcolor{keyword}{operator} Matcher<ArgsTuple>()\textcolor{keyword}{ const }\{  \textcolor{comment}{// NOLINT}}
\DoxyCodeLine{4119     \textcolor{keywordflow}{return} MakeMatcher(\textcolor{keyword}{new} ArgsMatcherImpl<ArgsTuple, k...>(inner\_matcher\_));}
\DoxyCodeLine{4120   \}}
\DoxyCodeLine{4121 }
\DoxyCodeLine{4122  \textcolor{keyword}{private}:}
\DoxyCodeLine{4123   InnerMatcher inner\_matcher\_;}
\DoxyCodeLine{4124 \};}
\DoxyCodeLine{4125 }
\DoxyCodeLine{4126 \}  \textcolor{comment}{// namespace internal}}
\DoxyCodeLine{4127 }
\DoxyCodeLine{4128 \textcolor{comment}{// ElementsAreArray(iterator\_first, iterator\_last)}}
\DoxyCodeLine{4129 \textcolor{comment}{// ElementsAreArray(pointer, count)}}
\DoxyCodeLine{4130 \textcolor{comment}{// ElementsAreArray(array)}}
\DoxyCodeLine{4131 \textcolor{comment}{// ElementsAreArray(container)}}
\DoxyCodeLine{4132 \textcolor{comment}{// ElementsAreArray(\{ e1, e2, ..., en \})}}
\DoxyCodeLine{4133 \textcolor{comment}{//}}
\DoxyCodeLine{4134 \textcolor{comment}{// The ElementsAreArray() functions are like ElementsAre(...), except}}
\DoxyCodeLine{4135 \textcolor{comment}{// that they are given a homogeneous sequence rather than taking each}}
\DoxyCodeLine{4136 \textcolor{comment}{// element as a function argument. The sequence can be specified as an}}
\DoxyCodeLine{4137 \textcolor{comment}{// array, a pointer and count, a vector, an initializer list, or an}}
\DoxyCodeLine{4138 \textcolor{comment}{// STL iterator range. In each of these cases, the underlying sequence}}
\DoxyCodeLine{4139 \textcolor{comment}{// can be either a sequence of values or a sequence of matchers.}}
\DoxyCodeLine{4140 \textcolor{comment}{//}}
\DoxyCodeLine{4141 \textcolor{comment}{// All forms of ElementsAreArray() make a copy of the input matcher sequence.}}
\DoxyCodeLine{4142 }
\DoxyCodeLine{4143 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Iter>}
\DoxyCodeLine{4144 \textcolor{keyword}{inline} internal::ElementsAreArrayMatcher<}
\DoxyCodeLine{4145     typename ::std::iterator\_traits<Iter>::value\_type>}
\DoxyCodeLine{4146 ElementsAreArray(Iter first, Iter last) \{}
\DoxyCodeLine{4147   \textcolor{keyword}{typedef} typename ::std::iterator\_traits<Iter>::value\_type T;}
\DoxyCodeLine{4148   \textcolor{keywordflow}{return} internal::ElementsAreArrayMatcher<T>(first, last);}
\DoxyCodeLine{4149 \}}
\DoxyCodeLine{4150 }
\DoxyCodeLine{4151 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{4152 \textcolor{keyword}{inline} \textcolor{keyword}{auto} ElementsAreArray(\textcolor{keyword}{const} T* pointer, \textcolor{keywordtype}{size\_t} count)}
\DoxyCodeLine{4153     -\/> \textcolor{keyword}{decltype}(ElementsAreArray(pointer, pointer + count)) \{}
\DoxyCodeLine{4154   \textcolor{keywordflow}{return} ElementsAreArray(pointer, pointer + count);}
\DoxyCodeLine{4155 \}}
\DoxyCodeLine{4156 }
\DoxyCodeLine{4157 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T, \textcolor{keywordtype}{size\_t} N>}
\DoxyCodeLine{4158 \textcolor{keyword}{inline} \textcolor{keyword}{auto} ElementsAreArray(\textcolor{keyword}{const} T (\&array)[N])}
\DoxyCodeLine{4159     -\/> \textcolor{keyword}{decltype}(ElementsAreArray(array, N)) \{}
\DoxyCodeLine{4160   \textcolor{keywordflow}{return} ElementsAreArray(array, N);}
\DoxyCodeLine{4161 \}}
\DoxyCodeLine{4162 }
\DoxyCodeLine{4163 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Container>}
\DoxyCodeLine{4164 \textcolor{keyword}{inline} \textcolor{keyword}{auto} ElementsAreArray(\textcolor{keyword}{const} Container\& container)}
\DoxyCodeLine{4165     -\/> \textcolor{keyword}{decltype}(ElementsAreArray(container.begin(), container.end())) \{}
\DoxyCodeLine{4166   \textcolor{keywordflow}{return} ElementsAreArray(container.begin(), container.end());}
\DoxyCodeLine{4167 \}}
\DoxyCodeLine{4168 }
\DoxyCodeLine{4169 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{4170 \textcolor{keyword}{inline} \textcolor{keyword}{auto} ElementsAreArray(::std::initializer\_list<T> xs)}
\DoxyCodeLine{4171     -\/> \textcolor{keyword}{decltype}(ElementsAreArray(xs.begin(), xs.end())) \{}
\DoxyCodeLine{4172   \textcolor{keywordflow}{return} ElementsAreArray(xs.begin(), xs.end());}
\DoxyCodeLine{4173 \}}
\DoxyCodeLine{4174 }
\DoxyCodeLine{4175 \textcolor{comment}{// UnorderedElementsAreArray(iterator\_first, iterator\_last)}}
\DoxyCodeLine{4176 \textcolor{comment}{// UnorderedElementsAreArray(pointer, count)}}
\DoxyCodeLine{4177 \textcolor{comment}{// UnorderedElementsAreArray(array)}}
\DoxyCodeLine{4178 \textcolor{comment}{// UnorderedElementsAreArray(container)}}
\DoxyCodeLine{4179 \textcolor{comment}{// UnorderedElementsAreArray(\{ e1, e2, ..., en \})}}
\DoxyCodeLine{4180 \textcolor{comment}{//}}
\DoxyCodeLine{4181 \textcolor{comment}{// UnorderedElementsAreArray() verifies that a bijective mapping onto a}}
\DoxyCodeLine{4182 \textcolor{comment}{// collection of matchers exists.}}
\DoxyCodeLine{4183 \textcolor{comment}{//}}
\DoxyCodeLine{4184 \textcolor{comment}{// The matchers can be specified as an array, a pointer and count, a container,}}
\DoxyCodeLine{4185 \textcolor{comment}{// an initializer list, or an STL iterator range. In each of these cases, the}}
\DoxyCodeLine{4186 \textcolor{comment}{// underlying matchers can be either values or matchers.}}
\DoxyCodeLine{4187 }
\DoxyCodeLine{4188 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Iter>}
\DoxyCodeLine{4189 \textcolor{keyword}{inline} internal::UnorderedElementsAreArrayMatcher<}
\DoxyCodeLine{4190     typename ::std::iterator\_traits<Iter>::value\_type>}
\DoxyCodeLine{4191 UnorderedElementsAreArray(Iter first, Iter last) \{}
\DoxyCodeLine{4192   \textcolor{keyword}{typedef} typename ::std::iterator\_traits<Iter>::value\_type T;}
\DoxyCodeLine{4193   \textcolor{keywordflow}{return} internal::UnorderedElementsAreArrayMatcher<T>(}
\DoxyCodeLine{4194       internal::UnorderedMatcherRequire::ExactMatch, first, last);}
\DoxyCodeLine{4195 \}}
\DoxyCodeLine{4196 }
\DoxyCodeLine{4197 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{4198 \textcolor{keyword}{inline} internal::UnorderedElementsAreArrayMatcher<T> UnorderedElementsAreArray(}
\DoxyCodeLine{4199     \textcolor{keyword}{const} T* pointer, \textcolor{keywordtype}{size\_t} count) \{}
\DoxyCodeLine{4200   \textcolor{keywordflow}{return} UnorderedElementsAreArray(pointer, pointer + count);}
\DoxyCodeLine{4201 \}}
\DoxyCodeLine{4202 }
\DoxyCodeLine{4203 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T, \textcolor{keywordtype}{size\_t} N>}
\DoxyCodeLine{4204 \textcolor{keyword}{inline} internal::UnorderedElementsAreArrayMatcher<T> UnorderedElementsAreArray(}
\DoxyCodeLine{4205     \textcolor{keyword}{const} T (\&array)[N]) \{}
\DoxyCodeLine{4206   \textcolor{keywordflow}{return} UnorderedElementsAreArray(array, N);}
\DoxyCodeLine{4207 \}}
\DoxyCodeLine{4208 }
\DoxyCodeLine{4209 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Container>}
\DoxyCodeLine{4210 \textcolor{keyword}{inline} internal::UnorderedElementsAreArrayMatcher<}
\DoxyCodeLine{4211     \textcolor{keyword}{typename} Container::value\_type>}
\DoxyCodeLine{4212 UnorderedElementsAreArray(\textcolor{keyword}{const} Container\& container) \{}
\DoxyCodeLine{4213   \textcolor{keywordflow}{return} UnorderedElementsAreArray(container.begin(), container.end());}
\DoxyCodeLine{4214 \}}
\DoxyCodeLine{4215 }
\DoxyCodeLine{4216 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{4217 \textcolor{keyword}{inline} internal::UnorderedElementsAreArrayMatcher<T> UnorderedElementsAreArray(}
\DoxyCodeLine{4218     ::std::initializer\_list<T> xs) \{}
\DoxyCodeLine{4219   \textcolor{keywordflow}{return} UnorderedElementsAreArray(xs.begin(), xs.end());}
\DoxyCodeLine{4220 \}}
\DoxyCodeLine{4221 }
\DoxyCodeLine{4222 \textcolor{comment}{// \_ is a matcher that matches anything of any type.}}
\DoxyCodeLine{4223 \textcolor{comment}{//}}
\DoxyCodeLine{4224 \textcolor{comment}{// This definition is fine as:}}
\DoxyCodeLine{4225 \textcolor{comment}{//}}
\DoxyCodeLine{4226 \textcolor{comment}{//   1. The C++ standard permits using the name \_ in a namespace that}}
\DoxyCodeLine{4227 \textcolor{comment}{//      is not the global namespace or ::std.}}
\DoxyCodeLine{4228 \textcolor{comment}{//   2. The AnythingMatcher class has no data member or constructor,}}
\DoxyCodeLine{4229 \textcolor{comment}{//      so it's OK to create global variables of this type.}}
\DoxyCodeLine{4230 \textcolor{comment}{//   3. c-\/style has approved of using \_ in this case.}}
\DoxyCodeLine{4231 \textcolor{keyword}{const} internal::AnythingMatcher \_ = \{\};}
\DoxyCodeLine{4232 \textcolor{comment}{// Creates a matcher that matches any value of the given type T.}}
\DoxyCodeLine{4233 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{4234 \textcolor{keyword}{inline} Matcher<T> A() \{}
\DoxyCodeLine{4235   \textcolor{keywordflow}{return} \_;}
\DoxyCodeLine{4236 \}}
\DoxyCodeLine{4237 }
\DoxyCodeLine{4238 \textcolor{comment}{// Creates a matcher that matches any value of the given type T.}}
\DoxyCodeLine{4239 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{4240 \textcolor{keyword}{inline} Matcher<T> An() \{}
\DoxyCodeLine{4241   \textcolor{keywordflow}{return} \_;}
\DoxyCodeLine{4242 \}}
\DoxyCodeLine{4243 }
\DoxyCodeLine{4244 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T, \textcolor{keyword}{typename} M>}
\DoxyCodeLine{4245 Matcher<T> internal::MatcherCastImpl<T, M>::CastImpl(}
\DoxyCodeLine{4246     \textcolor{keyword}{const} M\& value, std::false\_type \textcolor{comment}{/* convertible\_to\_matcher */},}
\DoxyCodeLine{4247     std::false\_type \textcolor{comment}{/* convertible\_to\_T */}) \{}
\DoxyCodeLine{4248   \textcolor{keywordflow}{return} Eq(value);}
\DoxyCodeLine{4249 \}}
\DoxyCodeLine{4250 }
\DoxyCodeLine{4251 \textcolor{comment}{// Creates a polymorphic matcher that matches any NULL pointer.}}
\DoxyCodeLine{4252 \textcolor{keyword}{inline} PolymorphicMatcher<internal::IsNullMatcher> IsNull() \{}
\DoxyCodeLine{4253   \textcolor{keywordflow}{return} MakePolymorphicMatcher(internal::IsNullMatcher());}
\DoxyCodeLine{4254 \}}
\DoxyCodeLine{4255 }
\DoxyCodeLine{4256 \textcolor{comment}{// Creates a polymorphic matcher that matches any non-\/NULL pointer.}}
\DoxyCodeLine{4257 \textcolor{comment}{// This is convenient as Not(NULL) doesn't compile (the compiler}}
\DoxyCodeLine{4258 \textcolor{comment}{// thinks that that expression is comparing a pointer with an integer).}}
\DoxyCodeLine{4259 \textcolor{keyword}{inline} PolymorphicMatcher<internal::NotNullMatcher> NotNull() \{}
\DoxyCodeLine{4260   \textcolor{keywordflow}{return} MakePolymorphicMatcher(internal::NotNullMatcher());}
\DoxyCodeLine{4261 \}}
\DoxyCodeLine{4262 }
\DoxyCodeLine{4263 \textcolor{comment}{// Creates a polymorphic matcher that matches any argument that}}
\DoxyCodeLine{4264 \textcolor{comment}{// references variable x.}}
\DoxyCodeLine{4265 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{4266 \textcolor{keyword}{inline} internal::RefMatcher<T\&> Ref(T\& x) \{  \textcolor{comment}{// NOLINT}}
\DoxyCodeLine{4267   \textcolor{keywordflow}{return} internal::RefMatcher<T\&>(x);}
\DoxyCodeLine{4268 \}}
\DoxyCodeLine{4269 }
\DoxyCodeLine{4270 \textcolor{comment}{// Creates a polymorphic matcher that matches any NaN floating point.}}
\DoxyCodeLine{4271 \textcolor{keyword}{inline} PolymorphicMatcher<internal::IsNanMatcher> IsNan() \{}
\DoxyCodeLine{4272   \textcolor{keywordflow}{return} MakePolymorphicMatcher(internal::IsNanMatcher());}
\DoxyCodeLine{4273 \}}
\DoxyCodeLine{4274 }
\DoxyCodeLine{4275 \textcolor{comment}{// Creates a matcher that matches any double argument approximately}}
\DoxyCodeLine{4276 \textcolor{comment}{// equal to rhs, where two NANs are considered unequal.}}
\DoxyCodeLine{4277 \textcolor{keyword}{inline} internal::FloatingEqMatcher<double> DoubleEq(\textcolor{keywordtype}{double} rhs) \{}
\DoxyCodeLine{4278   \textcolor{keywordflow}{return} internal::FloatingEqMatcher<double>(rhs, \textcolor{keyword}{false});}
\DoxyCodeLine{4279 \}}
\DoxyCodeLine{4280 }
\DoxyCodeLine{4281 \textcolor{comment}{// Creates a matcher that matches any double argument approximately}}
\DoxyCodeLine{4282 \textcolor{comment}{// equal to rhs, including NaN values when rhs is NaN.}}
\DoxyCodeLine{4283 \textcolor{keyword}{inline} internal::FloatingEqMatcher<double> NanSensitiveDoubleEq(\textcolor{keywordtype}{double} rhs) \{}
\DoxyCodeLine{4284   \textcolor{keywordflow}{return} internal::FloatingEqMatcher<double>(rhs, \textcolor{keyword}{true});}
\DoxyCodeLine{4285 \}}
\DoxyCodeLine{4286 }
\DoxyCodeLine{4287 \textcolor{comment}{// Creates a matcher that matches any double argument approximately equal to}}
\DoxyCodeLine{4288 \textcolor{comment}{// rhs, up to the specified max absolute error bound, where two NANs are}}
\DoxyCodeLine{4289 \textcolor{comment}{// considered unequal.  The max absolute error bound must be non-\/negative.}}
\DoxyCodeLine{4290 \textcolor{keyword}{inline} internal::FloatingEqMatcher<double> DoubleNear(\textcolor{keywordtype}{double} rhs,}
\DoxyCodeLine{4291                                                       \textcolor{keywordtype}{double} max\_abs\_error) \{}
\DoxyCodeLine{4292   \textcolor{keywordflow}{return} internal::FloatingEqMatcher<double>(rhs, \textcolor{keyword}{false}, max\_abs\_error);}
\DoxyCodeLine{4293 \}}
\DoxyCodeLine{4294 }
\DoxyCodeLine{4295 \textcolor{comment}{// Creates a matcher that matches any double argument approximately equal to}}
\DoxyCodeLine{4296 \textcolor{comment}{// rhs, up to the specified max absolute error bound, including NaN values when}}
\DoxyCodeLine{4297 \textcolor{comment}{// rhs is NaN.  The max absolute error bound must be non-\/negative.}}
\DoxyCodeLine{4298 \textcolor{keyword}{inline} internal::FloatingEqMatcher<double> NanSensitiveDoubleNear(}
\DoxyCodeLine{4299     \textcolor{keywordtype}{double} rhs, \textcolor{keywordtype}{double} max\_abs\_error) \{}
\DoxyCodeLine{4300   \textcolor{keywordflow}{return} internal::FloatingEqMatcher<double>(rhs, \textcolor{keyword}{true}, max\_abs\_error);}
\DoxyCodeLine{4301 \}}
\DoxyCodeLine{4302 }
\DoxyCodeLine{4303 \textcolor{comment}{// Creates a matcher that matches any float argument approximately}}
\DoxyCodeLine{4304 \textcolor{comment}{// equal to rhs, where two NANs are considered unequal.}}
\DoxyCodeLine{4305 \textcolor{keyword}{inline} internal::FloatingEqMatcher<float> FloatEq(\textcolor{keywordtype}{float} rhs) \{}
\DoxyCodeLine{4306   \textcolor{keywordflow}{return} internal::FloatingEqMatcher<float>(rhs, \textcolor{keyword}{false});}
\DoxyCodeLine{4307 \}}
\DoxyCodeLine{4308 }
\DoxyCodeLine{4309 \textcolor{comment}{// Creates a matcher that matches any float argument approximately}}
\DoxyCodeLine{4310 \textcolor{comment}{// equal to rhs, including NaN values when rhs is NaN.}}
\DoxyCodeLine{4311 \textcolor{keyword}{inline} internal::FloatingEqMatcher<float> NanSensitiveFloatEq(\textcolor{keywordtype}{float} rhs) \{}
\DoxyCodeLine{4312   \textcolor{keywordflow}{return} internal::FloatingEqMatcher<float>(rhs, \textcolor{keyword}{true});}
\DoxyCodeLine{4313 \}}
\DoxyCodeLine{4314 }
\DoxyCodeLine{4315 \textcolor{comment}{// Creates a matcher that matches any float argument approximately equal to}}
\DoxyCodeLine{4316 \textcolor{comment}{// rhs, up to the specified max absolute error bound, where two NANs are}}
\DoxyCodeLine{4317 \textcolor{comment}{// considered unequal.  The max absolute error bound must be non-\/negative.}}
\DoxyCodeLine{4318 \textcolor{keyword}{inline} internal::FloatingEqMatcher<float> FloatNear(\textcolor{keywordtype}{float} rhs,}
\DoxyCodeLine{4319                                                     \textcolor{keywordtype}{float} max\_abs\_error) \{}
\DoxyCodeLine{4320   \textcolor{keywordflow}{return} internal::FloatingEqMatcher<float>(rhs, \textcolor{keyword}{false}, max\_abs\_error);}
\DoxyCodeLine{4321 \}}
\DoxyCodeLine{4322 }
\DoxyCodeLine{4323 \textcolor{comment}{// Creates a matcher that matches any float argument approximately equal to}}
\DoxyCodeLine{4324 \textcolor{comment}{// rhs, up to the specified max absolute error bound, including NaN values when}}
\DoxyCodeLine{4325 \textcolor{comment}{// rhs is NaN.  The max absolute error bound must be non-\/negative.}}
\DoxyCodeLine{4326 \textcolor{keyword}{inline} internal::FloatingEqMatcher<float> NanSensitiveFloatNear(}
\DoxyCodeLine{4327     \textcolor{keywordtype}{float} rhs, \textcolor{keywordtype}{float} max\_abs\_error) \{}
\DoxyCodeLine{4328   \textcolor{keywordflow}{return} internal::FloatingEqMatcher<float>(rhs, \textcolor{keyword}{true}, max\_abs\_error);}
\DoxyCodeLine{4329 \}}
\DoxyCodeLine{4330 }
\DoxyCodeLine{4331 \textcolor{comment}{// Creates a matcher that matches a pointer (raw or smart) that points}}
\DoxyCodeLine{4332 \textcolor{comment}{// to a value that matches inner\_matcher.}}
\DoxyCodeLine{4333 \textcolor{keyword}{template} <\textcolor{keyword}{typename} InnerMatcher>}
\DoxyCodeLine{4334 \textcolor{keyword}{inline} internal::PointeeMatcher<InnerMatcher> Pointee(}
\DoxyCodeLine{4335     \textcolor{keyword}{const} InnerMatcher\& inner\_matcher) \{}
\DoxyCodeLine{4336   \textcolor{keywordflow}{return} internal::PointeeMatcher<InnerMatcher>(inner\_matcher);}
\DoxyCodeLine{4337 \}}
\DoxyCodeLine{4338 }
\DoxyCodeLine{4339 \textcolor{preprocessor}{\#if GTEST\_HAS\_RTTI}}
\DoxyCodeLine{4340 \textcolor{comment}{// Creates a matcher that matches a pointer or reference that matches}}
\DoxyCodeLine{4341 \textcolor{comment}{// inner\_matcher when dynamic\_cast<To> is applied.}}
\DoxyCodeLine{4342 \textcolor{comment}{// The result of dynamic\_cast<To> is forwarded to the inner matcher.}}
\DoxyCodeLine{4343 \textcolor{comment}{// If To is a pointer and the cast fails, the inner matcher will receive NULL.}}
\DoxyCodeLine{4344 \textcolor{comment}{// If To is a reference and the cast fails, this matcher returns false}}
\DoxyCodeLine{4345 \textcolor{comment}{// immediately.}}
\DoxyCodeLine{4346 \textcolor{keyword}{template} <\textcolor{keyword}{typename} To>}
\DoxyCodeLine{4347 \textcolor{keyword}{inline} PolymorphicMatcher<internal::WhenDynamicCastToMatcher<To>>}
\DoxyCodeLine{4348 WhenDynamicCastTo(\textcolor{keyword}{const} Matcher<To>\& inner\_matcher) \{}
\DoxyCodeLine{4349   \textcolor{keywordflow}{return} MakePolymorphicMatcher(}
\DoxyCodeLine{4350       internal::WhenDynamicCastToMatcher<To>(inner\_matcher));}
\DoxyCodeLine{4351 \}}
\DoxyCodeLine{4352 \textcolor{preprocessor}{\#endif  }\textcolor{comment}{// GTEST\_HAS\_RTTI}}
\DoxyCodeLine{4353 }
\DoxyCodeLine{4354 \textcolor{comment}{// Creates a matcher that matches an object whose given field matches}}
\DoxyCodeLine{4355 \textcolor{comment}{// 'matcher'.  For example,}}
\DoxyCodeLine{4356 \textcolor{comment}{//   Field(\&Foo::number, Ge(5))}}
\DoxyCodeLine{4357 \textcolor{comment}{// matches a Foo object x if and only if x.number >= 5.}}
\DoxyCodeLine{4358 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Class, \textcolor{keyword}{typename} FieldType, \textcolor{keyword}{typename} FieldMatcher>}
\DoxyCodeLine{4359 \textcolor{keyword}{inline} PolymorphicMatcher<internal::FieldMatcher<Class, FieldType>> Field(}
\DoxyCodeLine{4360     FieldType Class::*field, \textcolor{keyword}{const} FieldMatcher\& matcher) \{}
\DoxyCodeLine{4361   \textcolor{keywordflow}{return} MakePolymorphicMatcher(internal::FieldMatcher<Class, FieldType>(}
\DoxyCodeLine{4362       field, MatcherCast<const FieldType\&>(matcher)));}
\DoxyCodeLine{4363   \textcolor{comment}{// The call to MatcherCast() is required for supporting inner}}
\DoxyCodeLine{4364   \textcolor{comment}{// matchers of compatible types.  For example, it allows}}
\DoxyCodeLine{4365   \textcolor{comment}{//   Field(\&Foo::bar, m)}}
\DoxyCodeLine{4366   \textcolor{comment}{// to compile where bar is an int32 and m is a matcher for int64.}}
\DoxyCodeLine{4367 \}}
\DoxyCodeLine{4368 }
\DoxyCodeLine{4369 \textcolor{comment}{// Same as Field() but also takes the name of the field to provide better error}}
\DoxyCodeLine{4370 \textcolor{comment}{// messages.}}
\DoxyCodeLine{4371 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Class, \textcolor{keyword}{typename} FieldType, \textcolor{keyword}{typename} FieldMatcher>}
\DoxyCodeLine{4372 \textcolor{keyword}{inline} PolymorphicMatcher<internal::FieldMatcher<Class, FieldType>> Field(}
\DoxyCodeLine{4373     \textcolor{keyword}{const} std::string\& field\_name, FieldType Class::*field,}
\DoxyCodeLine{4374     \textcolor{keyword}{const} FieldMatcher\& matcher) \{}
\DoxyCodeLine{4375   \textcolor{keywordflow}{return} MakePolymorphicMatcher(internal::FieldMatcher<Class, FieldType>(}
\DoxyCodeLine{4376       field\_name, field, MatcherCast<const FieldType\&>(matcher)));}
\DoxyCodeLine{4377 \}}
\DoxyCodeLine{4378 }
\DoxyCodeLine{4379 \textcolor{comment}{// Creates a matcher that matches an object whose given property}}
\DoxyCodeLine{4380 \textcolor{comment}{// matches 'matcher'.  For example,}}
\DoxyCodeLine{4381 \textcolor{comment}{//   Property(\&Foo::str, StartsWith("{}hi"{}))}}
\DoxyCodeLine{4382 \textcolor{comment}{// matches a Foo object x if and only if x.str() starts with "{}hi"{}.}}
\DoxyCodeLine{4383 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Class, \textcolor{keyword}{typename} PropertyType, \textcolor{keyword}{typename} PropertyMatcher>}
\DoxyCodeLine{4384 \textcolor{keyword}{inline} PolymorphicMatcher<internal::PropertyMatcher<}
\DoxyCodeLine{4385     Class, PropertyType, PropertyType (Class::*)() \textcolor{keyword}{const}>>}
\DoxyCodeLine{4386 Property(PropertyType (Class::*property)() \textcolor{keyword}{const},}
\DoxyCodeLine{4387          \textcolor{keyword}{const} PropertyMatcher\& matcher) \{}
\DoxyCodeLine{4388   \textcolor{keywordflow}{return} MakePolymorphicMatcher(}
\DoxyCodeLine{4389       internal::PropertyMatcher<Class, PropertyType,}
\DoxyCodeLine{4390                                 PropertyType (Class::*)() \textcolor{keyword}{const}>(}
\DoxyCodeLine{4391           property, MatcherCast<const PropertyType\&>(matcher)));}
\DoxyCodeLine{4392   \textcolor{comment}{// The call to MatcherCast() is required for supporting inner}}
\DoxyCodeLine{4393   \textcolor{comment}{// matchers of compatible types.  For example, it allows}}
\DoxyCodeLine{4394   \textcolor{comment}{//   Property(\&Foo::bar, m)}}
\DoxyCodeLine{4395   \textcolor{comment}{// to compile where bar() returns an int32 and m is a matcher for int64.}}
\DoxyCodeLine{4396 \}}
\DoxyCodeLine{4397 }
\DoxyCodeLine{4398 \textcolor{comment}{// Same as Property() above, but also takes the name of the property to provide}}
\DoxyCodeLine{4399 \textcolor{comment}{// better error messages.}}
\DoxyCodeLine{4400 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Class, \textcolor{keyword}{typename} PropertyType, \textcolor{keyword}{typename} PropertyMatcher>}
\DoxyCodeLine{4401 \textcolor{keyword}{inline} PolymorphicMatcher<internal::PropertyMatcher<}
\DoxyCodeLine{4402     Class, PropertyType, PropertyType (Class::*)() \textcolor{keyword}{const}>>}
\DoxyCodeLine{4403 Property(\textcolor{keyword}{const} std::string\& property\_name,}
\DoxyCodeLine{4404          PropertyType (Class::*property)() \textcolor{keyword}{const},}
\DoxyCodeLine{4405          \textcolor{keyword}{const} PropertyMatcher\& matcher) \{}
\DoxyCodeLine{4406   \textcolor{keywordflow}{return} MakePolymorphicMatcher(}
\DoxyCodeLine{4407       internal::PropertyMatcher<Class, PropertyType,}
\DoxyCodeLine{4408                                 PropertyType (Class::*)() \textcolor{keyword}{const}>(}
\DoxyCodeLine{4409           property\_name, property, MatcherCast<const PropertyType\&>(matcher)));}
\DoxyCodeLine{4410 \}}
\DoxyCodeLine{4411 }
\DoxyCodeLine{4412 \textcolor{comment}{// The same as above but for reference-\/qualified member functions.}}
\DoxyCodeLine{4413 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Class, \textcolor{keyword}{typename} PropertyType, \textcolor{keyword}{typename} PropertyMatcher>}
\DoxyCodeLine{4414 \textcolor{keyword}{inline} PolymorphicMatcher<internal::PropertyMatcher<}
\DoxyCodeLine{4415     Class, PropertyType, PropertyType (Class::*)() \textcolor{keyword}{const}\&>>}
\DoxyCodeLine{4416 Property(PropertyType (Class::*property)() \textcolor{keyword}{const}\&,}
\DoxyCodeLine{4417          \textcolor{keyword}{const} PropertyMatcher\& matcher) \{}
\DoxyCodeLine{4418   \textcolor{keywordflow}{return} MakePolymorphicMatcher(}
\DoxyCodeLine{4419       internal::PropertyMatcher<Class, PropertyType,}
\DoxyCodeLine{4420                                 PropertyType (Class::*)() \textcolor{keyword}{const}\&>(}
\DoxyCodeLine{4421           property, MatcherCast<const PropertyType\&>(matcher)));}
\DoxyCodeLine{4422 \}}
\DoxyCodeLine{4423 }
\DoxyCodeLine{4424 \textcolor{comment}{// Three-\/argument form for reference-\/qualified member functions.}}
\DoxyCodeLine{4425 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Class, \textcolor{keyword}{typename} PropertyType, \textcolor{keyword}{typename} PropertyMatcher>}
\DoxyCodeLine{4426 \textcolor{keyword}{inline} PolymorphicMatcher<internal::PropertyMatcher<}
\DoxyCodeLine{4427     Class, PropertyType, PropertyType (Class::*)() \textcolor{keyword}{const}\&>>}
\DoxyCodeLine{4428 Property(\textcolor{keyword}{const} std::string\& property\_name,}
\DoxyCodeLine{4429          PropertyType (Class::*property)() \textcolor{keyword}{const}\&,}
\DoxyCodeLine{4430          \textcolor{keyword}{const} PropertyMatcher\& matcher) \{}
\DoxyCodeLine{4431   \textcolor{keywordflow}{return} MakePolymorphicMatcher(}
\DoxyCodeLine{4432       internal::PropertyMatcher<Class, PropertyType,}
\DoxyCodeLine{4433                                 PropertyType (Class::*)() \textcolor{keyword}{const}\&>(}
\DoxyCodeLine{4434           property\_name, property, MatcherCast<const PropertyType\&>(matcher)));}
\DoxyCodeLine{4435 \}}
\DoxyCodeLine{4436 }
\DoxyCodeLine{4437 \textcolor{comment}{// Creates a matcher that matches an object if and only if the result of}}
\DoxyCodeLine{4438 \textcolor{comment}{// applying a callable to x matches 'matcher'. For example,}}
\DoxyCodeLine{4439 \textcolor{comment}{//   ResultOf(f, StartsWith("{}hi"{}))}}
\DoxyCodeLine{4440 \textcolor{comment}{// matches a Foo object x if and only if f(x) starts with "{}hi"{}.}}
\DoxyCodeLine{4441 \textcolor{comment}{// `callable` parameter can be a function, function pointer, or a functor. It is}}
\DoxyCodeLine{4442 \textcolor{comment}{// required to keep no state affecting the results of the calls on it and make}}
\DoxyCodeLine{4443 \textcolor{comment}{// no assumptions about how many calls will be made. Any state it keeps must be}}
\DoxyCodeLine{4444 \textcolor{comment}{// protected from the concurrent access.}}
\DoxyCodeLine{4445 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Callable, \textcolor{keyword}{typename} InnerMatcher>}
\DoxyCodeLine{4446 internal::ResultOfMatcher<Callable, InnerMatcher> ResultOf(}
\DoxyCodeLine{4447     Callable callable, InnerMatcher matcher) \{}
\DoxyCodeLine{4448   \textcolor{keywordflow}{return} internal::ResultOfMatcher<Callable, InnerMatcher>(std::move(callable),}
\DoxyCodeLine{4449                                                            std::move(matcher));}
\DoxyCodeLine{4450 \}}
\DoxyCodeLine{4451 }
\DoxyCodeLine{4452 \textcolor{comment}{// Same as ResultOf() above, but also takes a description of the `callable`}}
\DoxyCodeLine{4453 \textcolor{comment}{// result to provide better error messages.}}
\DoxyCodeLine{4454 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Callable, \textcolor{keyword}{typename} InnerMatcher>}
\DoxyCodeLine{4455 internal::ResultOfMatcher<Callable, InnerMatcher> ResultOf(}
\DoxyCodeLine{4456     \textcolor{keyword}{const} std::string\& result\_description, Callable callable,}
\DoxyCodeLine{4457     InnerMatcher matcher) \{}
\DoxyCodeLine{4458   \textcolor{keywordflow}{return} internal::ResultOfMatcher<Callable, InnerMatcher>(}
\DoxyCodeLine{4459       result\_description, std::move(callable), std::move(matcher));}
\DoxyCodeLine{4460 \}}
\DoxyCodeLine{4461 }
\DoxyCodeLine{4462 \textcolor{comment}{// String matchers.}}
\DoxyCodeLine{4463 }
\DoxyCodeLine{4464 \textcolor{comment}{// Matches a string equal to str.}}
\DoxyCodeLine{4465 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T = std::\textcolor{keywordtype}{string}>}
\DoxyCodeLine{4466 PolymorphicMatcher<internal::StrEqualityMatcher<std::string>> StrEq(}
\DoxyCodeLine{4467     \textcolor{keyword}{const} internal::StringLike<T>\& str) \{}
\DoxyCodeLine{4468   \textcolor{keywordflow}{return} MakePolymorphicMatcher(}
\DoxyCodeLine{4469       internal::StrEqualityMatcher<std::string>(std::string(str), \textcolor{keyword}{true}, \textcolor{keyword}{true}));}
\DoxyCodeLine{4470 \}}
\DoxyCodeLine{4471 }
\DoxyCodeLine{4472 \textcolor{comment}{// Matches a string not equal to str.}}
\DoxyCodeLine{4473 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T = std::\textcolor{keywordtype}{string}>}
\DoxyCodeLine{4474 PolymorphicMatcher<internal::StrEqualityMatcher<std::string>> StrNe(}
\DoxyCodeLine{4475     \textcolor{keyword}{const} internal::StringLike<T>\& str) \{}
\DoxyCodeLine{4476   \textcolor{keywordflow}{return} MakePolymorphicMatcher(}
\DoxyCodeLine{4477       internal::StrEqualityMatcher<std::string>(std::string(str), \textcolor{keyword}{false}, \textcolor{keyword}{true}));}
\DoxyCodeLine{4478 \}}
\DoxyCodeLine{4479 }
\DoxyCodeLine{4480 \textcolor{comment}{// Matches a string equal to str, ignoring case.}}
\DoxyCodeLine{4481 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T = std::\textcolor{keywordtype}{string}>}
\DoxyCodeLine{4482 PolymorphicMatcher<internal::StrEqualityMatcher<std::string>> StrCaseEq(}
\DoxyCodeLine{4483     \textcolor{keyword}{const} internal::StringLike<T>\& str) \{}
\DoxyCodeLine{4484   \textcolor{keywordflow}{return} MakePolymorphicMatcher(}
\DoxyCodeLine{4485       internal::StrEqualityMatcher<std::string>(std::string(str), \textcolor{keyword}{true}, \textcolor{keyword}{false}));}
\DoxyCodeLine{4486 \}}
\DoxyCodeLine{4487 }
\DoxyCodeLine{4488 \textcolor{comment}{// Matches a string not equal to str, ignoring case.}}
\DoxyCodeLine{4489 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T = std::\textcolor{keywordtype}{string}>}
\DoxyCodeLine{4490 PolymorphicMatcher<internal::StrEqualityMatcher<std::string>> StrCaseNe(}
\DoxyCodeLine{4491     \textcolor{keyword}{const} internal::StringLike<T>\& str) \{}
\DoxyCodeLine{4492   \textcolor{keywordflow}{return} MakePolymorphicMatcher(internal::StrEqualityMatcher<std::string>(}
\DoxyCodeLine{4493       std::string(str), \textcolor{keyword}{false}, \textcolor{keyword}{false}));}
\DoxyCodeLine{4494 \}}
\DoxyCodeLine{4495 }
\DoxyCodeLine{4496 \textcolor{comment}{// Creates a matcher that matches any string, std::string, or C string}}
\DoxyCodeLine{4497 \textcolor{comment}{// that contains the given substring.}}
\DoxyCodeLine{4498 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T = std::\textcolor{keywordtype}{string}>}
\DoxyCodeLine{4499 PolymorphicMatcher<internal::HasSubstrMatcher<std::string>> HasSubstr(}
\DoxyCodeLine{4500     \textcolor{keyword}{const} internal::StringLike<T>\& substring) \{}
\DoxyCodeLine{4501   \textcolor{keywordflow}{return} MakePolymorphicMatcher(}
\DoxyCodeLine{4502       internal::HasSubstrMatcher<std::string>(std::string(substring)));}
\DoxyCodeLine{4503 \}}
\DoxyCodeLine{4504 }
\DoxyCodeLine{4505 \textcolor{comment}{// Matches a string that starts with 'prefix' (case-\/sensitive).}}
\DoxyCodeLine{4506 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T = std::\textcolor{keywordtype}{string}>}
\DoxyCodeLine{4507 PolymorphicMatcher<internal::StartsWithMatcher<std::string>> StartsWith(}
\DoxyCodeLine{4508     \textcolor{keyword}{const} internal::StringLike<T>\& prefix) \{}
\DoxyCodeLine{4509   \textcolor{keywordflow}{return} MakePolymorphicMatcher(}
\DoxyCodeLine{4510       internal::StartsWithMatcher<std::string>(std::string(prefix)));}
\DoxyCodeLine{4511 \}}
\DoxyCodeLine{4512 }
\DoxyCodeLine{4513 \textcolor{comment}{// Matches a string that ends with 'suffix' (case-\/sensitive).}}
\DoxyCodeLine{4514 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T = std::\textcolor{keywordtype}{string}>}
\DoxyCodeLine{4515 PolymorphicMatcher<internal::EndsWithMatcher<std::string>> EndsWith(}
\DoxyCodeLine{4516     \textcolor{keyword}{const} internal::StringLike<T>\& suffix) \{}
\DoxyCodeLine{4517   \textcolor{keywordflow}{return} MakePolymorphicMatcher(}
\DoxyCodeLine{4518       internal::EndsWithMatcher<std::string>(std::string(suffix)));}
\DoxyCodeLine{4519 \}}
\DoxyCodeLine{4520 }
\DoxyCodeLine{4521 \textcolor{preprocessor}{\#if GTEST\_HAS\_STD\_WSTRING}}
\DoxyCodeLine{4522 \textcolor{comment}{// Wide string matchers.}}
\DoxyCodeLine{4523 }
\DoxyCodeLine{4524 \textcolor{comment}{// Matches a string equal to str.}}
\DoxyCodeLine{4525 \textcolor{keyword}{inline} PolymorphicMatcher<internal::StrEqualityMatcher<std::wstring>> StrEq(}
\DoxyCodeLine{4526     \textcolor{keyword}{const} std::wstring\& str) \{}
\DoxyCodeLine{4527   \textcolor{keywordflow}{return} MakePolymorphicMatcher(}
\DoxyCodeLine{4528       internal::StrEqualityMatcher<std::wstring>(str, \textcolor{keyword}{true}, \textcolor{keyword}{true}));}
\DoxyCodeLine{4529 \}}
\DoxyCodeLine{4530 }
\DoxyCodeLine{4531 \textcolor{comment}{// Matches a string not equal to str.}}
\DoxyCodeLine{4532 \textcolor{keyword}{inline} PolymorphicMatcher<internal::StrEqualityMatcher<std::wstring>> StrNe(}
\DoxyCodeLine{4533     \textcolor{keyword}{const} std::wstring\& str) \{}
\DoxyCodeLine{4534   \textcolor{keywordflow}{return} MakePolymorphicMatcher(}
\DoxyCodeLine{4535       internal::StrEqualityMatcher<std::wstring>(str, \textcolor{keyword}{false}, \textcolor{keyword}{true}));}
\DoxyCodeLine{4536 \}}
\DoxyCodeLine{4537 }
\DoxyCodeLine{4538 \textcolor{comment}{// Matches a string equal to str, ignoring case.}}
\DoxyCodeLine{4539 \textcolor{keyword}{inline} PolymorphicMatcher<internal::StrEqualityMatcher<std::wstring>> StrCaseEq(}
\DoxyCodeLine{4540     \textcolor{keyword}{const} std::wstring\& str) \{}
\DoxyCodeLine{4541   \textcolor{keywordflow}{return} MakePolymorphicMatcher(}
\DoxyCodeLine{4542       internal::StrEqualityMatcher<std::wstring>(str, \textcolor{keyword}{true}, \textcolor{keyword}{false}));}
\DoxyCodeLine{4543 \}}
\DoxyCodeLine{4544 }
\DoxyCodeLine{4545 \textcolor{comment}{// Matches a string not equal to str, ignoring case.}}
\DoxyCodeLine{4546 \textcolor{keyword}{inline} PolymorphicMatcher<internal::StrEqualityMatcher<std::wstring>> StrCaseNe(}
\DoxyCodeLine{4547     \textcolor{keyword}{const} std::wstring\& str) \{}
\DoxyCodeLine{4548   \textcolor{keywordflow}{return} MakePolymorphicMatcher(}
\DoxyCodeLine{4549       internal::StrEqualityMatcher<std::wstring>(str, \textcolor{keyword}{false}, \textcolor{keyword}{false}));}
\DoxyCodeLine{4550 \}}
\DoxyCodeLine{4551 }
\DoxyCodeLine{4552 \textcolor{comment}{// Creates a matcher that matches any ::wstring, std::wstring, or C wide string}}
\DoxyCodeLine{4553 \textcolor{comment}{// that contains the given substring.}}
\DoxyCodeLine{4554 \textcolor{keyword}{inline} PolymorphicMatcher<internal::HasSubstrMatcher<std::wstring>> HasSubstr(}
\DoxyCodeLine{4555     \textcolor{keyword}{const} std::wstring\& substring) \{}
\DoxyCodeLine{4556   \textcolor{keywordflow}{return} MakePolymorphicMatcher(}
\DoxyCodeLine{4557       internal::HasSubstrMatcher<std::wstring>(substring));}
\DoxyCodeLine{4558 \}}
\DoxyCodeLine{4559 }
\DoxyCodeLine{4560 \textcolor{comment}{// Matches a string that starts with 'prefix' (case-\/sensitive).}}
\DoxyCodeLine{4561 \textcolor{keyword}{inline} PolymorphicMatcher<internal::StartsWithMatcher<std::wstring>> StartsWith(}
\DoxyCodeLine{4562     \textcolor{keyword}{const} std::wstring\& prefix) \{}
\DoxyCodeLine{4563   \textcolor{keywordflow}{return} MakePolymorphicMatcher(}
\DoxyCodeLine{4564       internal::StartsWithMatcher<std::wstring>(prefix));}
\DoxyCodeLine{4565 \}}
\DoxyCodeLine{4566 }
\DoxyCodeLine{4567 \textcolor{comment}{// Matches a string that ends with 'suffix' (case-\/sensitive).}}
\DoxyCodeLine{4568 \textcolor{keyword}{inline} PolymorphicMatcher<internal::EndsWithMatcher<std::wstring>> EndsWith(}
\DoxyCodeLine{4569     \textcolor{keyword}{const} std::wstring\& suffix) \{}
\DoxyCodeLine{4570   \textcolor{keywordflow}{return} MakePolymorphicMatcher(}
\DoxyCodeLine{4571       internal::EndsWithMatcher<std::wstring>(suffix));}
\DoxyCodeLine{4572 \}}
\DoxyCodeLine{4573 }
\DoxyCodeLine{4574 \textcolor{preprocessor}{\#endif  }\textcolor{comment}{// GTEST\_HAS\_STD\_WSTRING}}
\DoxyCodeLine{4575 }
\DoxyCodeLine{4576 \textcolor{comment}{// Creates a polymorphic matcher that matches a 2-\/tuple where the}}
\DoxyCodeLine{4577 \textcolor{comment}{// first field == the second field.}}
\DoxyCodeLine{4578 \textcolor{keyword}{inline} internal::Eq2Matcher Eq() \{ \textcolor{keywordflow}{return} internal::Eq2Matcher(); \}}
\DoxyCodeLine{4579 }
\DoxyCodeLine{4580 \textcolor{comment}{// Creates a polymorphic matcher that matches a 2-\/tuple where the}}
\DoxyCodeLine{4581 \textcolor{comment}{// first field >= the second field.}}
\DoxyCodeLine{4582 \textcolor{keyword}{inline} internal::Ge2Matcher Ge() \{ \textcolor{keywordflow}{return} internal::Ge2Matcher(); \}}
\DoxyCodeLine{4583 }
\DoxyCodeLine{4584 \textcolor{comment}{// Creates a polymorphic matcher that matches a 2-\/tuple where the}}
\DoxyCodeLine{4585 \textcolor{comment}{// first field > the second field.}}
\DoxyCodeLine{4586 \textcolor{keyword}{inline} internal::Gt2Matcher Gt() \{ \textcolor{keywordflow}{return} internal::Gt2Matcher(); \}}
\DoxyCodeLine{4587 }
\DoxyCodeLine{4588 \textcolor{comment}{// Creates a polymorphic matcher that matches a 2-\/tuple where the}}
\DoxyCodeLine{4589 \textcolor{comment}{// first field <= the second field.}}
\DoxyCodeLine{4590 \textcolor{keyword}{inline} internal::Le2Matcher Le() \{ \textcolor{keywordflow}{return} internal::Le2Matcher(); \}}
\DoxyCodeLine{4591 }
\DoxyCodeLine{4592 \textcolor{comment}{// Creates a polymorphic matcher that matches a 2-\/tuple where the}}
\DoxyCodeLine{4593 \textcolor{comment}{// first field < the second field.}}
\DoxyCodeLine{4594 \textcolor{keyword}{inline} internal::Lt2Matcher Lt() \{ \textcolor{keywordflow}{return} internal::Lt2Matcher(); \}}
\DoxyCodeLine{4595 }
\DoxyCodeLine{4596 \textcolor{comment}{// Creates a polymorphic matcher that matches a 2-\/tuple where the}}
\DoxyCodeLine{4597 \textcolor{comment}{// first field != the second field.}}
\DoxyCodeLine{4598 \textcolor{keyword}{inline} internal::Ne2Matcher Ne() \{ \textcolor{keywordflow}{return} internal::Ne2Matcher(); \}}
\DoxyCodeLine{4599 }
\DoxyCodeLine{4600 \textcolor{comment}{// Creates a polymorphic matcher that matches a 2-\/tuple where}}
\DoxyCodeLine{4601 \textcolor{comment}{// FloatEq(first field) matches the second field.}}
\DoxyCodeLine{4602 \textcolor{keyword}{inline} internal::FloatingEq2Matcher<float> FloatEq() \{}
\DoxyCodeLine{4603   \textcolor{keywordflow}{return} internal::FloatingEq2Matcher<float>();}
\DoxyCodeLine{4604 \}}
\DoxyCodeLine{4605 }
\DoxyCodeLine{4606 \textcolor{comment}{// Creates a polymorphic matcher that matches a 2-\/tuple where}}
\DoxyCodeLine{4607 \textcolor{comment}{// DoubleEq(first field) matches the second field.}}
\DoxyCodeLine{4608 \textcolor{keyword}{inline} internal::FloatingEq2Matcher<double> DoubleEq() \{}
\DoxyCodeLine{4609   \textcolor{keywordflow}{return} internal::FloatingEq2Matcher<double>();}
\DoxyCodeLine{4610 \}}
\DoxyCodeLine{4611 }
\DoxyCodeLine{4612 \textcolor{comment}{// Creates a polymorphic matcher that matches a 2-\/tuple where}}
\DoxyCodeLine{4613 \textcolor{comment}{// FloatEq(first field) matches the second field with NaN equality.}}
\DoxyCodeLine{4614 \textcolor{keyword}{inline} internal::FloatingEq2Matcher<float> NanSensitiveFloatEq() \{}
\DoxyCodeLine{4615   \textcolor{keywordflow}{return} internal::FloatingEq2Matcher<float>(\textcolor{keyword}{true});}
\DoxyCodeLine{4616 \}}
\DoxyCodeLine{4617 }
\DoxyCodeLine{4618 \textcolor{comment}{// Creates a polymorphic matcher that matches a 2-\/tuple where}}
\DoxyCodeLine{4619 \textcolor{comment}{// DoubleEq(first field) matches the second field with NaN equality.}}
\DoxyCodeLine{4620 \textcolor{keyword}{inline} internal::FloatingEq2Matcher<double> NanSensitiveDoubleEq() \{}
\DoxyCodeLine{4621   \textcolor{keywordflow}{return} internal::FloatingEq2Matcher<double>(\textcolor{keyword}{true});}
\DoxyCodeLine{4622 \}}
\DoxyCodeLine{4623 }
\DoxyCodeLine{4624 \textcolor{comment}{// Creates a polymorphic matcher that matches a 2-\/tuple where}}
\DoxyCodeLine{4625 \textcolor{comment}{// FloatNear(first field, max\_abs\_error) matches the second field.}}
\DoxyCodeLine{4626 \textcolor{keyword}{inline} internal::FloatingEq2Matcher<float> FloatNear(\textcolor{keywordtype}{float} max\_abs\_error) \{}
\DoxyCodeLine{4627   \textcolor{keywordflow}{return} internal::FloatingEq2Matcher<float>(max\_abs\_error);}
\DoxyCodeLine{4628 \}}
\DoxyCodeLine{4629 }
\DoxyCodeLine{4630 \textcolor{comment}{// Creates a polymorphic matcher that matches a 2-\/tuple where}}
\DoxyCodeLine{4631 \textcolor{comment}{// DoubleNear(first field, max\_abs\_error) matches the second field.}}
\DoxyCodeLine{4632 \textcolor{keyword}{inline} internal::FloatingEq2Matcher<double> DoubleNear(\textcolor{keywordtype}{double} max\_abs\_error) \{}
\DoxyCodeLine{4633   \textcolor{keywordflow}{return} internal::FloatingEq2Matcher<double>(max\_abs\_error);}
\DoxyCodeLine{4634 \}}
\DoxyCodeLine{4635 }
\DoxyCodeLine{4636 \textcolor{comment}{// Creates a polymorphic matcher that matches a 2-\/tuple where}}
\DoxyCodeLine{4637 \textcolor{comment}{// FloatNear(first field, max\_abs\_error) matches the second field with NaN}}
\DoxyCodeLine{4638 \textcolor{comment}{// equality.}}
\DoxyCodeLine{4639 \textcolor{keyword}{inline} internal::FloatingEq2Matcher<float> NanSensitiveFloatNear(}
\DoxyCodeLine{4640     \textcolor{keywordtype}{float} max\_abs\_error) \{}
\DoxyCodeLine{4641   \textcolor{keywordflow}{return} internal::FloatingEq2Matcher<float>(max\_abs\_error, \textcolor{keyword}{true});}
\DoxyCodeLine{4642 \}}
\DoxyCodeLine{4643 }
\DoxyCodeLine{4644 \textcolor{comment}{// Creates a polymorphic matcher that matches a 2-\/tuple where}}
\DoxyCodeLine{4645 \textcolor{comment}{// DoubleNear(first field, max\_abs\_error) matches the second field with NaN}}
\DoxyCodeLine{4646 \textcolor{comment}{// equality.}}
\DoxyCodeLine{4647 \textcolor{keyword}{inline} internal::FloatingEq2Matcher<double> NanSensitiveDoubleNear(}
\DoxyCodeLine{4648     \textcolor{keywordtype}{double} max\_abs\_error) \{}
\DoxyCodeLine{4649   \textcolor{keywordflow}{return} internal::FloatingEq2Matcher<double>(max\_abs\_error, \textcolor{keyword}{true});}
\DoxyCodeLine{4650 \}}
\DoxyCodeLine{4651 }
\DoxyCodeLine{4652 \textcolor{comment}{// Creates a matcher that matches any value of type T that m doesn't}}
\DoxyCodeLine{4653 \textcolor{comment}{// match.}}
\DoxyCodeLine{4654 \textcolor{keyword}{template} <\textcolor{keyword}{typename} InnerMatcher>}
\DoxyCodeLine{4655 \textcolor{keyword}{inline} internal::NotMatcher<InnerMatcher> Not(InnerMatcher m) \{}
\DoxyCodeLine{4656   \textcolor{keywordflow}{return} internal::NotMatcher<InnerMatcher>(m);}
\DoxyCodeLine{4657 \}}
\DoxyCodeLine{4658 }
\DoxyCodeLine{4659 \textcolor{comment}{// Returns a matcher that matches anything that satisfies the given}}
\DoxyCodeLine{4660 \textcolor{comment}{// predicate.  The predicate can be any unary function or functor}}
\DoxyCodeLine{4661 \textcolor{comment}{// whose return type can be implicitly converted to bool.}}
\DoxyCodeLine{4662 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Predicate>}
\DoxyCodeLine{4663 \textcolor{keyword}{inline} PolymorphicMatcher<internal::TrulyMatcher<Predicate>> Truly(}
\DoxyCodeLine{4664     Predicate pred) \{}
\DoxyCodeLine{4665   \textcolor{keywordflow}{return} MakePolymorphicMatcher(internal::TrulyMatcher<Predicate>(pred));}
\DoxyCodeLine{4666 \}}
\DoxyCodeLine{4667 }
\DoxyCodeLine{4668 \textcolor{comment}{// Returns a matcher that matches the container size. The container must}}
\DoxyCodeLine{4669 \textcolor{comment}{// support both size() and size\_type which all STL-\/like containers provide.}}
\DoxyCodeLine{4670 \textcolor{comment}{// Note that the parameter 'size' can be a value of type size\_type as well as}}
\DoxyCodeLine{4671 \textcolor{comment}{// matcher. For instance:}}
\DoxyCodeLine{4672 \textcolor{comment}{//   EXPECT\_THAT(container, SizeIs(2));     // Checks container has 2 elements.}}
\DoxyCodeLine{4673 \textcolor{comment}{//   EXPECT\_THAT(container, SizeIs(Le(2));  // Checks container has at most 2.}}
\DoxyCodeLine{4674 \textcolor{keyword}{template} <\textcolor{keyword}{typename} SizeMatcher>}
\DoxyCodeLine{4675 \textcolor{keyword}{inline} internal::SizeIsMatcher<SizeMatcher> SizeIs(}
\DoxyCodeLine{4676     \textcolor{keyword}{const} SizeMatcher\& size\_matcher) \{}
\DoxyCodeLine{4677   \textcolor{keywordflow}{return} internal::SizeIsMatcher<SizeMatcher>(size\_matcher);}
\DoxyCodeLine{4678 \}}
\DoxyCodeLine{4679 }
\DoxyCodeLine{4680 \textcolor{comment}{// Returns a matcher that matches the distance between the container's begin()}}
\DoxyCodeLine{4681 \textcolor{comment}{// iterator and its end() iterator, i.e. the size of the container. This matcher}}
\DoxyCodeLine{4682 \textcolor{comment}{// can be used instead of SizeIs with containers such as std::forward\_list which}}
\DoxyCodeLine{4683 \textcolor{comment}{// do not implement size(). The container must provide const\_iterator (with}}
\DoxyCodeLine{4684 \textcolor{comment}{// valid iterator\_traits), begin() and end().}}
\DoxyCodeLine{4685 \textcolor{keyword}{template} <\textcolor{keyword}{typename} DistanceMatcher>}
\DoxyCodeLine{4686 \textcolor{keyword}{inline} internal::BeginEndDistanceIsMatcher<DistanceMatcher> BeginEndDistanceIs(}
\DoxyCodeLine{4687     \textcolor{keyword}{const} DistanceMatcher\& distance\_matcher) \{}
\DoxyCodeLine{4688   \textcolor{keywordflow}{return} internal::BeginEndDistanceIsMatcher<DistanceMatcher>(distance\_matcher);}
\DoxyCodeLine{4689 \}}
\DoxyCodeLine{4690 }
\DoxyCodeLine{4691 \textcolor{comment}{// Returns a matcher that matches an equal container.}}
\DoxyCodeLine{4692 \textcolor{comment}{// This matcher behaves like Eq(), but in the event of mismatch lists the}}
\DoxyCodeLine{4693 \textcolor{comment}{// values that are included in one container but not the other. (Duplicate}}
\DoxyCodeLine{4694 \textcolor{comment}{// values and order differences are not explained.)}}
\DoxyCodeLine{4695 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Container>}
\DoxyCodeLine{4696 \textcolor{keyword}{inline} PolymorphicMatcher<}
\DoxyCodeLine{4697     internal::ContainerEqMatcher<typename std::remove\_const<Container>::type>>}
\DoxyCodeLine{4698 ContainerEq(\textcolor{keyword}{const} Container\& rhs) \{}
\DoxyCodeLine{4699   \textcolor{keywordflow}{return} MakePolymorphicMatcher(internal::ContainerEqMatcher<Container>(rhs));}
\DoxyCodeLine{4700 \}}
\DoxyCodeLine{4701 }
\DoxyCodeLine{4702 \textcolor{comment}{// Returns a matcher that matches a container that, when sorted using}}
\DoxyCodeLine{4703 \textcolor{comment}{// the given comparator, matches container\_matcher.}}
\DoxyCodeLine{4704 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Comparator, \textcolor{keyword}{typename} ContainerMatcher>}
\DoxyCodeLine{4705 \textcolor{keyword}{inline} internal::WhenSortedByMatcher<Comparator, ContainerMatcher> WhenSortedBy(}
\DoxyCodeLine{4706     \textcolor{keyword}{const} Comparator\& comparator, \textcolor{keyword}{const} ContainerMatcher\& container\_matcher) \{}
\DoxyCodeLine{4707   \textcolor{keywordflow}{return} internal::WhenSortedByMatcher<Comparator, ContainerMatcher>(}
\DoxyCodeLine{4708       comparator, container\_matcher);}
\DoxyCodeLine{4709 \}}
\DoxyCodeLine{4710 }
\DoxyCodeLine{4711 \textcolor{comment}{// Returns a matcher that matches a container that, when sorted using}}
\DoxyCodeLine{4712 \textcolor{comment}{// the < operator, matches container\_matcher.}}
\DoxyCodeLine{4713 \textcolor{keyword}{template} <\textcolor{keyword}{typename} ContainerMatcher>}
\DoxyCodeLine{4714 \textcolor{keyword}{inline} internal::WhenSortedByMatcher<internal::LessComparator, ContainerMatcher>}
\DoxyCodeLine{4715 WhenSorted(\textcolor{keyword}{const} ContainerMatcher\& container\_matcher) \{}
\DoxyCodeLine{4716   \textcolor{keywordflow}{return} internal::WhenSortedByMatcher<internal::LessComparator,}
\DoxyCodeLine{4717                                        ContainerMatcher>(}
\DoxyCodeLine{4718       internal::LessComparator(), container\_matcher);}
\DoxyCodeLine{4719 \}}
\DoxyCodeLine{4720 }
\DoxyCodeLine{4721 \textcolor{comment}{// Matches an STL-\/style container or a native array that contains the}}
\DoxyCodeLine{4722 \textcolor{comment}{// same number of elements as in rhs, where its i-\/th element and rhs's}}
\DoxyCodeLine{4723 \textcolor{comment}{// i-\/th element (as a pair) satisfy the given pair matcher, for all i.}}
\DoxyCodeLine{4724 \textcolor{comment}{// TupleMatcher must be able to be safely cast to Matcher<std::tuple<const}}
\DoxyCodeLine{4725 \textcolor{comment}{// T1\&, const T2\&> >, where T1 and T2 are the types of elements in the}}
\DoxyCodeLine{4726 \textcolor{comment}{// LHS container and the RHS container respectively.}}
\DoxyCodeLine{4727 \textcolor{keyword}{template} <\textcolor{keyword}{typename} TupleMatcher, \textcolor{keyword}{typename} Container>}
\DoxyCodeLine{4728 \textcolor{keyword}{inline} internal::PointwiseMatcher<TupleMatcher,}
\DoxyCodeLine{4729                                   \textcolor{keyword}{typename} std::remove\_const<Container>::type>}
\DoxyCodeLine{4730 Pointwise(\textcolor{keyword}{const} TupleMatcher\& tuple\_matcher, \textcolor{keyword}{const} Container\& rhs) \{}
\DoxyCodeLine{4731   \textcolor{keywordflow}{return} internal::PointwiseMatcher<TupleMatcher, Container>(tuple\_matcher,}
\DoxyCodeLine{4732                                                              rhs);}
\DoxyCodeLine{4733 \}}
\DoxyCodeLine{4734 }
\DoxyCodeLine{4735 \textcolor{comment}{// Supports the Pointwise(m, \{a, b, c\}) syntax.}}
\DoxyCodeLine{4736 \textcolor{keyword}{template} <\textcolor{keyword}{typename} TupleMatcher, \textcolor{keyword}{typename} T>}
\DoxyCodeLine{4737 \textcolor{keyword}{inline} internal::PointwiseMatcher<TupleMatcher, std::vector<T>> Pointwise(}
\DoxyCodeLine{4738     \textcolor{keyword}{const} TupleMatcher\& tuple\_matcher, std::initializer\_list<T> rhs) \{}
\DoxyCodeLine{4739   \textcolor{keywordflow}{return} Pointwise(tuple\_matcher, std::vector<T>(rhs));}
\DoxyCodeLine{4740 \}}
\DoxyCodeLine{4741 }
\DoxyCodeLine{4742 \textcolor{comment}{// UnorderedPointwise(pair\_matcher, rhs) matches an STL-\/style}}
\DoxyCodeLine{4743 \textcolor{comment}{// container or a native array that contains the same number of}}
\DoxyCodeLine{4744 \textcolor{comment}{// elements as in rhs, where in some permutation of the container, its}}
\DoxyCodeLine{4745 \textcolor{comment}{// i-\/th element and rhs's i-\/th element (as a pair) satisfy the given}}
\DoxyCodeLine{4746 \textcolor{comment}{// pair matcher, for all i.  Tuple2Matcher must be able to be safely}}
\DoxyCodeLine{4747 \textcolor{comment}{// cast to Matcher<std::tuple<const T1\&, const T2\&> >, where T1 and T2 are}}
\DoxyCodeLine{4748 \textcolor{comment}{// the types of elements in the LHS container and the RHS container}}
\DoxyCodeLine{4749 \textcolor{comment}{// respectively.}}
\DoxyCodeLine{4750 \textcolor{comment}{//}}
\DoxyCodeLine{4751 \textcolor{comment}{// This is like Pointwise(pair\_matcher, rhs), except that the element}}
\DoxyCodeLine{4752 \textcolor{comment}{// order doesn't matter.}}
\DoxyCodeLine{4753 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Tuple2Matcher, \textcolor{keyword}{typename} RhsContainer>}
\DoxyCodeLine{4754 \textcolor{keyword}{inline} internal::UnorderedElementsAreArrayMatcher<}
\DoxyCodeLine{4755     \textcolor{keyword}{typename} internal::BoundSecondMatcher<}
\DoxyCodeLine{4756         Tuple2Matcher,}
\DoxyCodeLine{4757         \textcolor{keyword}{typename} internal::StlContainerView<}
\DoxyCodeLine{4758             \textcolor{keyword}{typename} std::remove\_const<RhsContainer>::type>::type::value\_type>>}
\DoxyCodeLine{4759 UnorderedPointwise(\textcolor{keyword}{const} Tuple2Matcher\& tuple2\_matcher,}
\DoxyCodeLine{4760                    \textcolor{keyword}{const} RhsContainer\& rhs\_container) \{}
\DoxyCodeLine{4761   \textcolor{comment}{// RhsView allows the same code to handle RhsContainer being a}}
\DoxyCodeLine{4762   \textcolor{comment}{// STL-\/style container and it being a native C-\/style array.}}
\DoxyCodeLine{4763   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} internal::StlContainerView<RhsContainer> RhsView;}
\DoxyCodeLine{4764   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} RhsView::type RhsStlContainer;}
\DoxyCodeLine{4765   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} RhsStlContainer::value\_type Second;}
\DoxyCodeLine{4766   \textcolor{keyword}{const} RhsStlContainer\& rhs\_stl\_container =}
\DoxyCodeLine{4767       RhsView::ConstReference(rhs\_container);}
\DoxyCodeLine{4768 }
\DoxyCodeLine{4769   \textcolor{comment}{// Create a matcher for each element in rhs\_container.}}
\DoxyCodeLine{4770   ::std::vector<internal::BoundSecondMatcher<Tuple2Matcher, Second>> matchers;}
\DoxyCodeLine{4771   \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} it = rhs\_stl\_container.begin(); it != rhs\_stl\_container.end();}
\DoxyCodeLine{4772        ++it) \{}
\DoxyCodeLine{4773     matchers.push\_back(internal::MatcherBindSecond(tuple2\_matcher, *it));}
\DoxyCodeLine{4774   \}}
\DoxyCodeLine{4775 }
\DoxyCodeLine{4776   \textcolor{comment}{// Delegate the work to UnorderedElementsAreArray().}}
\DoxyCodeLine{4777   \textcolor{keywordflow}{return} UnorderedElementsAreArray(matchers);}
\DoxyCodeLine{4778 \}}
\DoxyCodeLine{4779 }
\DoxyCodeLine{4780 \textcolor{comment}{// Supports the UnorderedPointwise(m, \{a, b, c\}) syntax.}}
\DoxyCodeLine{4781 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Tuple2Matcher, \textcolor{keyword}{typename} T>}
\DoxyCodeLine{4782 \textcolor{keyword}{inline} internal::UnorderedElementsAreArrayMatcher<}
\DoxyCodeLine{4783     \textcolor{keyword}{typename} internal::BoundSecondMatcher<Tuple2Matcher, T>>}
\DoxyCodeLine{4784 UnorderedPointwise(\textcolor{keyword}{const} Tuple2Matcher\& tuple2\_matcher,}
\DoxyCodeLine{4785                    std::initializer\_list<T> rhs) \{}
\DoxyCodeLine{4786   \textcolor{keywordflow}{return} UnorderedPointwise(tuple2\_matcher, std::vector<T>(rhs));}
\DoxyCodeLine{4787 \}}
\DoxyCodeLine{4788 }
\DoxyCodeLine{4789 \textcolor{comment}{// Matches an STL-\/style container or a native array that contains at}}
\DoxyCodeLine{4790 \textcolor{comment}{// least one element matching the given value or matcher.}}
\DoxyCodeLine{4791 \textcolor{comment}{//}}
\DoxyCodeLine{4792 \textcolor{comment}{// Examples:}}
\DoxyCodeLine{4793 \textcolor{comment}{//   ::std::set<int> page\_ids;}}
\DoxyCodeLine{4794 \textcolor{comment}{//   page\_ids.insert(3);}}
\DoxyCodeLine{4795 \textcolor{comment}{//   page\_ids.insert(1);}}
\DoxyCodeLine{4796 \textcolor{comment}{//   EXPECT\_THAT(page\_ids, Contains(1));}}
\DoxyCodeLine{4797 \textcolor{comment}{//   EXPECT\_THAT(page\_ids, Contains(Gt(2)));}}
\DoxyCodeLine{4798 \textcolor{comment}{//   EXPECT\_THAT(page\_ids, Not(Contains(4)));  // See below for Times(0)}}
\DoxyCodeLine{4799 \textcolor{comment}{//}}
\DoxyCodeLine{4800 \textcolor{comment}{//   ::std::map<int, size\_t> page\_lengths;}}
\DoxyCodeLine{4801 \textcolor{comment}{//   page\_lengths[1] = 100;}}
\DoxyCodeLine{4802 \textcolor{comment}{//   EXPECT\_THAT(page\_lengths,}}
\DoxyCodeLine{4803 \textcolor{comment}{//               Contains(::std::pair<const int, size\_t>(1, 100)));}}
\DoxyCodeLine{4804 \textcolor{comment}{//}}
\DoxyCodeLine{4805 \textcolor{comment}{//   const char* user\_ids[] = \{ "{}joe"{}, "{}mike"{}, "{}tom"{} \};}}
\DoxyCodeLine{4806 \textcolor{comment}{//   EXPECT\_THAT(user\_ids, Contains(Eq(::std::string("{}tom"{}))));}}
\DoxyCodeLine{4807 \textcolor{comment}{//}}
\DoxyCodeLine{4808 \textcolor{comment}{// The matcher supports a modifier `Times` that allows to check for arbitrary}}
\DoxyCodeLine{4809 \textcolor{comment}{// occurrences including testing for absence with Times(0).}}
\DoxyCodeLine{4810 \textcolor{comment}{//}}
\DoxyCodeLine{4811 \textcolor{comment}{// Examples:}}
\DoxyCodeLine{4812 \textcolor{comment}{//   ::std::vector<int> ids;}}
\DoxyCodeLine{4813 \textcolor{comment}{//   ids.insert(1);}}
\DoxyCodeLine{4814 \textcolor{comment}{//   ids.insert(1);}}
\DoxyCodeLine{4815 \textcolor{comment}{//   ids.insert(3);}}
\DoxyCodeLine{4816 \textcolor{comment}{//   EXPECT\_THAT(ids, Contains(1).Times(2));      // 1 occurs 2 times}}
\DoxyCodeLine{4817 \textcolor{comment}{//   EXPECT\_THAT(ids, Contains(2).Times(0));      // 2 is not present}}
\DoxyCodeLine{4818 \textcolor{comment}{//   EXPECT\_THAT(ids, Contains(3).Times(Ge(1)));  // 3 occurs at least once}}
\DoxyCodeLine{4819 }
\DoxyCodeLine{4820 \textcolor{keyword}{template} <\textcolor{keyword}{typename} M>}
\DoxyCodeLine{4821 \textcolor{keyword}{inline} internal::ContainsMatcher<M> Contains(M matcher) \{}
\DoxyCodeLine{4822   \textcolor{keywordflow}{return} internal::ContainsMatcher<M>(matcher);}
\DoxyCodeLine{4823 \}}
\DoxyCodeLine{4824 }
\DoxyCodeLine{4825 \textcolor{comment}{// IsSupersetOf(iterator\_first, iterator\_last)}}
\DoxyCodeLine{4826 \textcolor{comment}{// IsSupersetOf(pointer, count)}}
\DoxyCodeLine{4827 \textcolor{comment}{// IsSupersetOf(array)}}
\DoxyCodeLine{4828 \textcolor{comment}{// IsSupersetOf(container)}}
\DoxyCodeLine{4829 \textcolor{comment}{// IsSupersetOf(\{e1, e2, ..., en\})}}
\DoxyCodeLine{4830 \textcolor{comment}{//}}
\DoxyCodeLine{4831 \textcolor{comment}{// IsSupersetOf() verifies that a surjective partial mapping onto a collection}}
\DoxyCodeLine{4832 \textcolor{comment}{// of matchers exists. In other words, a container matches}}
\DoxyCodeLine{4833 \textcolor{comment}{// IsSupersetOf(\{e1, ..., en\}) if and only if there is a permutation}}
\DoxyCodeLine{4834 \textcolor{comment}{// \{y1, ..., yn\} of some of the container's elements where y1 matches e1,}}
\DoxyCodeLine{4835 \textcolor{comment}{// ..., and yn matches en. Obviously, the size of the container must be >= n}}
\DoxyCodeLine{4836 \textcolor{comment}{// in order to have a match. Examples:}}
\DoxyCodeLine{4837 \textcolor{comment}{//}}
\DoxyCodeLine{4838 \textcolor{comment}{// -\/ \{1, 2, 3\} matches IsSupersetOf(\{Ge(3), Ne(0)\}), as 3 matches Ge(3) and}}
\DoxyCodeLine{4839 \textcolor{comment}{//   1 matches Ne(0).}}
\DoxyCodeLine{4840 \textcolor{comment}{// -\/ \{1, 2\} doesn't match IsSupersetOf(\{Eq(1), Lt(2)\}), even though 1 matches}}
\DoxyCodeLine{4841 \textcolor{comment}{//   both Eq(1) and Lt(2). The reason is that different matchers must be used}}
\DoxyCodeLine{4842 \textcolor{comment}{//   for elements in different slots of the container.}}
\DoxyCodeLine{4843 \textcolor{comment}{// -\/ \{1, 1, 2\} matches IsSupersetOf(\{Eq(1), Lt(2)\}), as (the first) 1 matches}}
\DoxyCodeLine{4844 \textcolor{comment}{//   Eq(1) and (the second) 1 matches Lt(2).}}
\DoxyCodeLine{4845 \textcolor{comment}{// -\/ \{1, 2, 3\} matches IsSupersetOf(Gt(1), Gt(1)), as 2 matches (the first)}}
\DoxyCodeLine{4846 \textcolor{comment}{//   Gt(1) and 3 matches (the second) Gt(1).}}
\DoxyCodeLine{4847 \textcolor{comment}{//}}
\DoxyCodeLine{4848 \textcolor{comment}{// The matchers can be specified as an array, a pointer and count, a container,}}
\DoxyCodeLine{4849 \textcolor{comment}{// an initializer list, or an STL iterator range. In each of these cases, the}}
\DoxyCodeLine{4850 \textcolor{comment}{// underlying matchers can be either values or matchers.}}
\DoxyCodeLine{4851 }
\DoxyCodeLine{4852 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Iter>}
\DoxyCodeLine{4853 \textcolor{keyword}{inline} internal::UnorderedElementsAreArrayMatcher<}
\DoxyCodeLine{4854     typename ::std::iterator\_traits<Iter>::value\_type>}
\DoxyCodeLine{4855 IsSupersetOf(Iter first, Iter last) \{}
\DoxyCodeLine{4856   \textcolor{keyword}{typedef} typename ::std::iterator\_traits<Iter>::value\_type T;}
\DoxyCodeLine{4857   \textcolor{keywordflow}{return} internal::UnorderedElementsAreArrayMatcher<T>(}
\DoxyCodeLine{4858       internal::UnorderedMatcherRequire::Superset, first, last);}
\DoxyCodeLine{4859 \}}
\DoxyCodeLine{4860 }
\DoxyCodeLine{4861 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{4862 \textcolor{keyword}{inline} internal::UnorderedElementsAreArrayMatcher<T> IsSupersetOf(}
\DoxyCodeLine{4863     \textcolor{keyword}{const} T* pointer, \textcolor{keywordtype}{size\_t} count) \{}
\DoxyCodeLine{4864   \textcolor{keywordflow}{return} IsSupersetOf(pointer, pointer + count);}
\DoxyCodeLine{4865 \}}
\DoxyCodeLine{4866 }
\DoxyCodeLine{4867 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T, \textcolor{keywordtype}{size\_t} N>}
\DoxyCodeLine{4868 \textcolor{keyword}{inline} internal::UnorderedElementsAreArrayMatcher<T> IsSupersetOf(}
\DoxyCodeLine{4869     \textcolor{keyword}{const} T (\&array)[N]) \{}
\DoxyCodeLine{4870   \textcolor{keywordflow}{return} IsSupersetOf(array, N);}
\DoxyCodeLine{4871 \}}
\DoxyCodeLine{4872 }
\DoxyCodeLine{4873 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Container>}
\DoxyCodeLine{4874 \textcolor{keyword}{inline} internal::UnorderedElementsAreArrayMatcher<}
\DoxyCodeLine{4875     \textcolor{keyword}{typename} Container::value\_type>}
\DoxyCodeLine{4876 IsSupersetOf(\textcolor{keyword}{const} Container\& container) \{}
\DoxyCodeLine{4877   \textcolor{keywordflow}{return} IsSupersetOf(container.begin(), container.end());}
\DoxyCodeLine{4878 \}}
\DoxyCodeLine{4879 }
\DoxyCodeLine{4880 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{4881 \textcolor{keyword}{inline} internal::UnorderedElementsAreArrayMatcher<T> IsSupersetOf(}
\DoxyCodeLine{4882     ::std::initializer\_list<T> xs) \{}
\DoxyCodeLine{4883   \textcolor{keywordflow}{return} IsSupersetOf(xs.begin(), xs.end());}
\DoxyCodeLine{4884 \}}
\DoxyCodeLine{4885 }
\DoxyCodeLine{4886 \textcolor{comment}{// IsSubsetOf(iterator\_first, iterator\_last)}}
\DoxyCodeLine{4887 \textcolor{comment}{// IsSubsetOf(pointer, count)}}
\DoxyCodeLine{4888 \textcolor{comment}{// IsSubsetOf(array)}}
\DoxyCodeLine{4889 \textcolor{comment}{// IsSubsetOf(container)}}
\DoxyCodeLine{4890 \textcolor{comment}{// IsSubsetOf(\{e1, e2, ..., en\})}}
\DoxyCodeLine{4891 \textcolor{comment}{//}}
\DoxyCodeLine{4892 \textcolor{comment}{// IsSubsetOf() verifies that an injective mapping onto a collection of matchers}}
\DoxyCodeLine{4893 \textcolor{comment}{// exists.  In other words, a container matches IsSubsetOf(\{e1, ..., en\}) if and}}
\DoxyCodeLine{4894 \textcolor{comment}{// only if there is a subset of matchers \{m1, ..., mk\} which would match the}}
\DoxyCodeLine{4895 \textcolor{comment}{// container using UnorderedElementsAre.  Obviously, the size of the container}}
\DoxyCodeLine{4896 \textcolor{comment}{// must be <= n in order to have a match. Examples:}}
\DoxyCodeLine{4897 \textcolor{comment}{//}}
\DoxyCodeLine{4898 \textcolor{comment}{// -\/ \{1\} matches IsSubsetOf(\{Gt(0), Lt(0)\}), as 1 matches Gt(0).}}
\DoxyCodeLine{4899 \textcolor{comment}{// -\/ \{1, -\/1\} matches IsSubsetOf(\{Lt(0), Gt(0)\}), as 1 matches Gt(0) and -\/1}}
\DoxyCodeLine{4900 \textcolor{comment}{//   matches Lt(0).}}
\DoxyCodeLine{4901 \textcolor{comment}{// -\/ \{1, 2\} doesn't matches IsSubsetOf(\{Gt(0), Lt(0)\}), even though 1 and 2 both}}
\DoxyCodeLine{4902 \textcolor{comment}{//   match Gt(0). The reason is that different matchers must be used for}}
\DoxyCodeLine{4903 \textcolor{comment}{//   elements in different slots of the container.}}
\DoxyCodeLine{4904 \textcolor{comment}{//}}
\DoxyCodeLine{4905 \textcolor{comment}{// The matchers can be specified as an array, a pointer and count, a container,}}
\DoxyCodeLine{4906 \textcolor{comment}{// an initializer list, or an STL iterator range. In each of these cases, the}}
\DoxyCodeLine{4907 \textcolor{comment}{// underlying matchers can be either values or matchers.}}
\DoxyCodeLine{4908 }
\DoxyCodeLine{4909 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Iter>}
\DoxyCodeLine{4910 \textcolor{keyword}{inline} internal::UnorderedElementsAreArrayMatcher<}
\DoxyCodeLine{4911     typename ::std::iterator\_traits<Iter>::value\_type>}
\DoxyCodeLine{4912 IsSubsetOf(Iter first, Iter last) \{}
\DoxyCodeLine{4913   \textcolor{keyword}{typedef} typename ::std::iterator\_traits<Iter>::value\_type T;}
\DoxyCodeLine{4914   \textcolor{keywordflow}{return} internal::UnorderedElementsAreArrayMatcher<T>(}
\DoxyCodeLine{4915       internal::UnorderedMatcherRequire::Subset, first, last);}
\DoxyCodeLine{4916 \}}
\DoxyCodeLine{4917 }
\DoxyCodeLine{4918 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{4919 \textcolor{keyword}{inline} internal::UnorderedElementsAreArrayMatcher<T> IsSubsetOf(}
\DoxyCodeLine{4920     \textcolor{keyword}{const} T* pointer, \textcolor{keywordtype}{size\_t} count) \{}
\DoxyCodeLine{4921   \textcolor{keywordflow}{return} IsSubsetOf(pointer, pointer + count);}
\DoxyCodeLine{4922 \}}
\DoxyCodeLine{4923 }
\DoxyCodeLine{4924 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T, \textcolor{keywordtype}{size\_t} N>}
\DoxyCodeLine{4925 \textcolor{keyword}{inline} internal::UnorderedElementsAreArrayMatcher<T> IsSubsetOf(}
\DoxyCodeLine{4926     \textcolor{keyword}{const} T (\&array)[N]) \{}
\DoxyCodeLine{4927   \textcolor{keywordflow}{return} IsSubsetOf(array, N);}
\DoxyCodeLine{4928 \}}
\DoxyCodeLine{4929 }
\DoxyCodeLine{4930 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Container>}
\DoxyCodeLine{4931 \textcolor{keyword}{inline} internal::UnorderedElementsAreArrayMatcher<}
\DoxyCodeLine{4932     \textcolor{keyword}{typename} Container::value\_type>}
\DoxyCodeLine{4933 IsSubsetOf(\textcolor{keyword}{const} Container\& container) \{}
\DoxyCodeLine{4934   \textcolor{keywordflow}{return} IsSubsetOf(container.begin(), container.end());}
\DoxyCodeLine{4935 \}}
\DoxyCodeLine{4936 }
\DoxyCodeLine{4937 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{4938 \textcolor{keyword}{inline} internal::UnorderedElementsAreArrayMatcher<T> IsSubsetOf(}
\DoxyCodeLine{4939     ::std::initializer\_list<T> xs) \{}
\DoxyCodeLine{4940   \textcolor{keywordflow}{return} IsSubsetOf(xs.begin(), xs.end());}
\DoxyCodeLine{4941 \}}
\DoxyCodeLine{4942 }
\DoxyCodeLine{4943 \textcolor{comment}{// Matches an STL-\/style container or a native array that contains only}}
\DoxyCodeLine{4944 \textcolor{comment}{// elements matching the given value or matcher.}}
\DoxyCodeLine{4945 \textcolor{comment}{//}}
\DoxyCodeLine{4946 \textcolor{comment}{// Each(m) is semantically equivalent to `Not(Contains(Not(m)))`. Only}}
\DoxyCodeLine{4947 \textcolor{comment}{// the messages are different.}}
\DoxyCodeLine{4948 \textcolor{comment}{//}}
\DoxyCodeLine{4949 \textcolor{comment}{// Examples:}}
\DoxyCodeLine{4950 \textcolor{comment}{//   ::std::set<int> page\_ids;}}
\DoxyCodeLine{4951 \textcolor{comment}{//   // Each(m) matches an empty container, regardless of what m is.}}
\DoxyCodeLine{4952 \textcolor{comment}{//   EXPECT\_THAT(page\_ids, Each(Eq(1)));}}
\DoxyCodeLine{4953 \textcolor{comment}{//   EXPECT\_THAT(page\_ids, Each(Eq(77)));}}
\DoxyCodeLine{4954 \textcolor{comment}{//}}
\DoxyCodeLine{4955 \textcolor{comment}{//   page\_ids.insert(3);}}
\DoxyCodeLine{4956 \textcolor{comment}{//   EXPECT\_THAT(page\_ids, Each(Gt(0)));}}
\DoxyCodeLine{4957 \textcolor{comment}{//   EXPECT\_THAT(page\_ids, Not(Each(Gt(4))));}}
\DoxyCodeLine{4958 \textcolor{comment}{//   page\_ids.insert(1);}}
\DoxyCodeLine{4959 \textcolor{comment}{//   EXPECT\_THAT(page\_ids, Not(Each(Lt(2))));}}
\DoxyCodeLine{4960 \textcolor{comment}{//}}
\DoxyCodeLine{4961 \textcolor{comment}{//   ::std::map<int, size\_t> page\_lengths;}}
\DoxyCodeLine{4962 \textcolor{comment}{//   page\_lengths[1] = 100;}}
\DoxyCodeLine{4963 \textcolor{comment}{//   page\_lengths[2] = 200;}}
\DoxyCodeLine{4964 \textcolor{comment}{//   page\_lengths[3] = 300;}}
\DoxyCodeLine{4965 \textcolor{comment}{//   EXPECT\_THAT(page\_lengths, Not(Each(Pair(1, 100))));}}
\DoxyCodeLine{4966 \textcolor{comment}{//   EXPECT\_THAT(page\_lengths, Each(Key(Le(3))));}}
\DoxyCodeLine{4967 \textcolor{comment}{//}}
\DoxyCodeLine{4968 \textcolor{comment}{//   const char* user\_ids[] = \{ "{}joe"{}, "{}mike"{}, "{}tom"{} \};}}
\DoxyCodeLine{4969 \textcolor{comment}{//   EXPECT\_THAT(user\_ids, Not(Each(Eq(::std::string("{}tom"{})))));}}
\DoxyCodeLine{4970 \textcolor{keyword}{template} <\textcolor{keyword}{typename} M>}
\DoxyCodeLine{4971 \textcolor{keyword}{inline} internal::EachMatcher<M> Each(M matcher) \{}
\DoxyCodeLine{4972   \textcolor{keywordflow}{return} internal::EachMatcher<M>(matcher);}
\DoxyCodeLine{4973 \}}
\DoxyCodeLine{4974 }
\DoxyCodeLine{4975 \textcolor{comment}{// Key(inner\_matcher) matches an std::pair whose 'first' field matches}}
\DoxyCodeLine{4976 \textcolor{comment}{// inner\_matcher.  For example, Contains(Key(Ge(5))) can be used to match an}}
\DoxyCodeLine{4977 \textcolor{comment}{// std::map that contains at least one element whose key is >= 5.}}
\DoxyCodeLine{4978 \textcolor{keyword}{template} <\textcolor{keyword}{typename} M>}
\DoxyCodeLine{4979 \textcolor{keyword}{inline} internal::KeyMatcher<M> \mbox{\hyperlink{classKey}{Key}}(M inner\_matcher) \{}
\DoxyCodeLine{4980   \textcolor{keywordflow}{return} internal::KeyMatcher<M>(inner\_matcher);}
\DoxyCodeLine{4981 \}}
\DoxyCodeLine{4982 }
\DoxyCodeLine{4983 \textcolor{comment}{// Pair(first\_matcher, second\_matcher) matches a std::pair whose 'first' field}}
\DoxyCodeLine{4984 \textcolor{comment}{// matches first\_matcher and whose 'second' field matches second\_matcher.  For}}
\DoxyCodeLine{4985 \textcolor{comment}{// example, EXPECT\_THAT(map\_type, ElementsAre(Pair(Ge(5), "{}foo"{}))) can be used}}
\DoxyCodeLine{4986 \textcolor{comment}{// to match a std::map<int, string> that contains exactly one element whose key}}
\DoxyCodeLine{4987 \textcolor{comment}{// is >= 5 and whose value equals "{}foo"{}.}}
\DoxyCodeLine{4988 \textcolor{keyword}{template} <\textcolor{keyword}{typename} FirstMatcher, \textcolor{keyword}{typename} SecondMatcher>}
\DoxyCodeLine{4989 \textcolor{keyword}{inline} internal::PairMatcher<FirstMatcher, SecondMatcher> Pair(}
\DoxyCodeLine{4990     FirstMatcher first\_matcher, SecondMatcher second\_matcher) \{}
\DoxyCodeLine{4991   \textcolor{keywordflow}{return} internal::PairMatcher<FirstMatcher, SecondMatcher>(first\_matcher,}
\DoxyCodeLine{4992                                                             second\_matcher);}
\DoxyCodeLine{4993 \}}
\DoxyCodeLine{4994 }
\DoxyCodeLine{4995 \textcolor{keyword}{namespace }no\_adl \{}
\DoxyCodeLine{4996 \textcolor{comment}{// Conditional() creates a matcher that conditionally uses either the first or}}
\DoxyCodeLine{4997 \textcolor{comment}{// second matcher provided. For example, we could create an `equal if, and only}}
\DoxyCodeLine{4998 \textcolor{comment}{// if' matcher using the Conditional wrapper as follows:}}
\DoxyCodeLine{4999 \textcolor{comment}{//}}
\DoxyCodeLine{5000 \textcolor{comment}{//   EXPECT\_THAT(result, Conditional(condition, Eq(expected), Ne(expected)));}}
\DoxyCodeLine{5001 \textcolor{keyword}{template} <\textcolor{keyword}{typename} MatcherTrue, \textcolor{keyword}{typename} MatcherFalse>}
\DoxyCodeLine{5002 internal::ConditionalMatcher<MatcherTrue, MatcherFalse> Conditional(}
\DoxyCodeLine{5003     \textcolor{keywordtype}{bool} condition, MatcherTrue matcher\_true, MatcherFalse matcher\_false) \{}
\DoxyCodeLine{5004   \textcolor{keywordflow}{return} internal::ConditionalMatcher<MatcherTrue, MatcherFalse>(}
\DoxyCodeLine{5005       condition, std::move(matcher\_true), std::move(matcher\_false));}
\DoxyCodeLine{5006 \}}
\DoxyCodeLine{5007 }
\DoxyCodeLine{5008 \textcolor{comment}{// FieldsAre(matchers...) matches piecewise the fields of compatible structs.}}
\DoxyCodeLine{5009 \textcolor{comment}{// These include those that support `get<I>(obj)`, and when structured bindings}}
\DoxyCodeLine{5010 \textcolor{comment}{// are enabled any class that supports them.}}
\DoxyCodeLine{5011 \textcolor{comment}{// In particular, `std::tuple`, `std::pair`, `std::array` and aggregate types.}}
\DoxyCodeLine{5012 \textcolor{keyword}{template} <\textcolor{keyword}{typename}... M>}
\DoxyCodeLine{5013 internal::FieldsAreMatcher<typename std::decay<M>::type...> FieldsAre(}
\DoxyCodeLine{5014     M\&\&... matchers) \{}
\DoxyCodeLine{5015   \textcolor{keywordflow}{return} internal::FieldsAreMatcher<typename std::decay<M>::type...>(}
\DoxyCodeLine{5016       std::forward<M>(matchers)...);}
\DoxyCodeLine{5017 \}}
\DoxyCodeLine{5018 }
\DoxyCodeLine{5019 \textcolor{comment}{// Creates a matcher that matches a pointer (raw or smart) that matches}}
\DoxyCodeLine{5020 \textcolor{comment}{// inner\_matcher.}}
\DoxyCodeLine{5021 \textcolor{keyword}{template} <\textcolor{keyword}{typename} InnerMatcher>}
\DoxyCodeLine{5022 \textcolor{keyword}{inline} internal::PointerMatcher<InnerMatcher> Pointer(}
\DoxyCodeLine{5023     \textcolor{keyword}{const} InnerMatcher\& inner\_matcher) \{}
\DoxyCodeLine{5024   \textcolor{keywordflow}{return} internal::PointerMatcher<InnerMatcher>(inner\_matcher);}
\DoxyCodeLine{5025 \}}
\DoxyCodeLine{5026 }
\DoxyCodeLine{5027 \textcolor{comment}{// Creates a matcher that matches an object that has an address that matches}}
\DoxyCodeLine{5028 \textcolor{comment}{// inner\_matcher.}}
\DoxyCodeLine{5029 \textcolor{keyword}{template} <\textcolor{keyword}{typename} InnerMatcher>}
\DoxyCodeLine{5030 \textcolor{keyword}{inline} internal::AddressMatcher<InnerMatcher> Address(}
\DoxyCodeLine{5031     \textcolor{keyword}{const} InnerMatcher\& inner\_matcher) \{}
\DoxyCodeLine{5032   \textcolor{keywordflow}{return} internal::AddressMatcher<InnerMatcher>(inner\_matcher);}
\DoxyCodeLine{5033 \}}
\DoxyCodeLine{5034 }
\DoxyCodeLine{5035 \textcolor{comment}{// Matches a base64 escaped string, when the unescaped string matches the}}
\DoxyCodeLine{5036 \textcolor{comment}{// internal matcher.}}
\DoxyCodeLine{5037 \textcolor{keyword}{template} <\textcolor{keyword}{typename} MatcherType>}
\DoxyCodeLine{5038 internal::WhenBase64UnescapedMatcher WhenBase64Unescaped(}
\DoxyCodeLine{5039     \textcolor{keyword}{const} MatcherType\& internal\_matcher) \{}
\DoxyCodeLine{5040   \textcolor{keywordflow}{return} internal::WhenBase64UnescapedMatcher(internal\_matcher);}
\DoxyCodeLine{5041 \}}
\DoxyCodeLine{5042 \}  \textcolor{comment}{// namespace no\_adl}}
\DoxyCodeLine{5043 }
\DoxyCodeLine{5044 \textcolor{comment}{// Returns a predicate that is satisfied by anything that matches the}}
\DoxyCodeLine{5045 \textcolor{comment}{// given matcher.}}
\DoxyCodeLine{5046 \textcolor{keyword}{template} <\textcolor{keyword}{typename} M>}
\DoxyCodeLine{5047 \textcolor{keyword}{inline} internal::MatcherAsPredicate<M> Matches(M matcher) \{}
\DoxyCodeLine{5048   \textcolor{keywordflow}{return} internal::MatcherAsPredicate<M>(matcher);}
\DoxyCodeLine{5049 \}}
\DoxyCodeLine{5050 }
\DoxyCodeLine{5051 \textcolor{comment}{// Returns true if and only if the value matches the matcher.}}
\DoxyCodeLine{5052 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T, \textcolor{keyword}{typename} M>}
\DoxyCodeLine{5053 \textcolor{keyword}{inline} \textcolor{keywordtype}{bool} Value(\textcolor{keyword}{const} T\& value, M matcher) \{}
\DoxyCodeLine{5054   \textcolor{keywordflow}{return} testing::Matches(matcher)(value);}
\DoxyCodeLine{5055 \}}
\DoxyCodeLine{5056 }
\DoxyCodeLine{5057 \textcolor{comment}{// Matches the value against the given matcher and explains the match}}
\DoxyCodeLine{5058 \textcolor{comment}{// result to listener.}}
\DoxyCodeLine{5059 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T, \textcolor{keyword}{typename} M>}
\DoxyCodeLine{5060 \textcolor{keyword}{inline} \textcolor{keywordtype}{bool} ExplainMatchResult(M matcher, \textcolor{keyword}{const} T\& value,}
\DoxyCodeLine{5061                                MatchResultListener* listener) \{}
\DoxyCodeLine{5062   \textcolor{keywordflow}{return} SafeMatcherCast<const T\&>(matcher).MatchAndExplain(value, listener);}
\DoxyCodeLine{5063 \}}
\DoxyCodeLine{5064 }
\DoxyCodeLine{5065 \textcolor{comment}{// Returns a string representation of the given matcher.  Useful for description}}
\DoxyCodeLine{5066 \textcolor{comment}{// strings of matchers defined using MATCHER\_P* macros that accept matchers as}}
\DoxyCodeLine{5067 \textcolor{comment}{// their arguments.  For example:}}
\DoxyCodeLine{5068 \textcolor{comment}{//}}
\DoxyCodeLine{5069 \textcolor{comment}{// MATCHER\_P(XAndYThat, matcher,}}
\DoxyCodeLine{5070 \textcolor{comment}{//           "{}X that "{} + DescribeMatcher<int>(matcher, negation) +}}
\DoxyCodeLine{5071 \textcolor{comment}{//               (negation ? "{} or"{} : "{} and"{}) + "{} Y that "{} +}}
\DoxyCodeLine{5072 \textcolor{comment}{//               DescribeMatcher<double>(matcher, negation)) \{}}
\DoxyCodeLine{5073 \textcolor{comment}{//   return ExplainMatchResult(matcher, arg.x(), result\_listener) \&\&}}
\DoxyCodeLine{5074 \textcolor{comment}{//          ExplainMatchResult(matcher, arg.y(), result\_listener);}}
\DoxyCodeLine{5075 \textcolor{comment}{// \}}}
\DoxyCodeLine{5076 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T, \textcolor{keyword}{typename} M>}
\DoxyCodeLine{5077 std::string DescribeMatcher(\textcolor{keyword}{const} M\& matcher, \textcolor{keywordtype}{bool} negation = \textcolor{keyword}{false}) \{}
\DoxyCodeLine{5078   ::std::stringstream ss;}
\DoxyCodeLine{5079   Matcher<T> monomorphic\_matcher = SafeMatcherCast<T>(matcher);}
\DoxyCodeLine{5080   \textcolor{keywordflow}{if} (negation) \{}
\DoxyCodeLine{5081     monomorphic\_matcher.DescribeNegationTo(\&ss);}
\DoxyCodeLine{5082   \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{5083     monomorphic\_matcher.DescribeTo(\&ss);}
\DoxyCodeLine{5084   \}}
\DoxyCodeLine{5085   \textcolor{keywordflow}{return} ss.str();}
\DoxyCodeLine{5086 \}}
\DoxyCodeLine{5087 }
\DoxyCodeLine{5088 \textcolor{keyword}{template} <\textcolor{keyword}{typename}... Args>}
\DoxyCodeLine{5089 internal::ElementsAreMatcher<}
\DoxyCodeLine{5090     std::tuple<typename std::decay<const Args\&>::type...>>}
\DoxyCodeLine{5091 ElementsAre(\textcolor{keyword}{const} Args\&... matchers) \{}
\DoxyCodeLine{5092   \textcolor{keywordflow}{return} internal::ElementsAreMatcher<}
\DoxyCodeLine{5093       std::tuple<typename std::decay<const Args\&>::type...>>(}
\DoxyCodeLine{5094       std::make\_tuple(matchers...));}
\DoxyCodeLine{5095 \}}
\DoxyCodeLine{5096 }
\DoxyCodeLine{5097 \textcolor{keyword}{template} <\textcolor{keyword}{typename}... Args>}
\DoxyCodeLine{5098 internal::UnorderedElementsAreMatcher<}
\DoxyCodeLine{5099     std::tuple<typename std::decay<const Args\&>::type...>>}
\DoxyCodeLine{5100 UnorderedElementsAre(\textcolor{keyword}{const} Args\&... matchers) \{}
\DoxyCodeLine{5101   \textcolor{keywordflow}{return} internal::UnorderedElementsAreMatcher<}
\DoxyCodeLine{5102       std::tuple<typename std::decay<const Args\&>::type...>>(}
\DoxyCodeLine{5103       std::make\_tuple(matchers...));}
\DoxyCodeLine{5104 \}}
\DoxyCodeLine{5105 }
\DoxyCodeLine{5106 \textcolor{comment}{// Define variadic matcher versions.}}
\DoxyCodeLine{5107 \textcolor{keyword}{template} <\textcolor{keyword}{typename}... Args>}
\DoxyCodeLine{5108 internal::AllOfMatcher<typename std::decay<const Args\&>::type...> AllOf(}
\DoxyCodeLine{5109     \textcolor{keyword}{const} Args\&... matchers) \{}
\DoxyCodeLine{5110   \textcolor{keywordflow}{return} internal::AllOfMatcher<typename std::decay<const Args\&>::type...>(}
\DoxyCodeLine{5111       matchers...);}
\DoxyCodeLine{5112 \}}
\DoxyCodeLine{5113 }
\DoxyCodeLine{5114 \textcolor{keyword}{template} <\textcolor{keyword}{typename}... Args>}
\DoxyCodeLine{5115 internal::AnyOfMatcher<typename std::decay<const Args\&>::type...> AnyOf(}
\DoxyCodeLine{5116     \textcolor{keyword}{const} Args\&... matchers) \{}
\DoxyCodeLine{5117   \textcolor{keywordflow}{return} internal::AnyOfMatcher<typename std::decay<const Args\&>::type...>(}
\DoxyCodeLine{5118       matchers...);}
\DoxyCodeLine{5119 \}}
\DoxyCodeLine{5120 }
\DoxyCodeLine{5121 \textcolor{comment}{// AnyOfArray(array)}}
\DoxyCodeLine{5122 \textcolor{comment}{// AnyOfArray(pointer, count)}}
\DoxyCodeLine{5123 \textcolor{comment}{// AnyOfArray(container)}}
\DoxyCodeLine{5124 \textcolor{comment}{// AnyOfArray(\{ e1, e2, ..., en \})}}
\DoxyCodeLine{5125 \textcolor{comment}{// AnyOfArray(iterator\_first, iterator\_last)}}
\DoxyCodeLine{5126 \textcolor{comment}{//}}
\DoxyCodeLine{5127 \textcolor{comment}{// AnyOfArray() verifies whether a given value matches any member of a}}
\DoxyCodeLine{5128 \textcolor{comment}{// collection of matchers.}}
\DoxyCodeLine{5129 \textcolor{comment}{//}}
\DoxyCodeLine{5130 \textcolor{comment}{// AllOfArray(array)}}
\DoxyCodeLine{5131 \textcolor{comment}{// AllOfArray(pointer, count)}}
\DoxyCodeLine{5132 \textcolor{comment}{// AllOfArray(container)}}
\DoxyCodeLine{5133 \textcolor{comment}{// AllOfArray(\{ e1, e2, ..., en \})}}
\DoxyCodeLine{5134 \textcolor{comment}{// AllOfArray(iterator\_first, iterator\_last)}}
\DoxyCodeLine{5135 \textcolor{comment}{//}}
\DoxyCodeLine{5136 \textcolor{comment}{// AllOfArray() verifies whether a given value matches all members of a}}
\DoxyCodeLine{5137 \textcolor{comment}{// collection of matchers.}}
\DoxyCodeLine{5138 \textcolor{comment}{//}}
\DoxyCodeLine{5139 \textcolor{comment}{// The matchers can be specified as an array, a pointer and count, a container,}}
\DoxyCodeLine{5140 \textcolor{comment}{// an initializer list, or an STL iterator range. In each of these cases, the}}
\DoxyCodeLine{5141 \textcolor{comment}{// underlying matchers can be either values or matchers.}}
\DoxyCodeLine{5142 }
\DoxyCodeLine{5143 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Iter>}
\DoxyCodeLine{5144 \textcolor{keyword}{inline} internal::AnyOfArrayMatcher<}
\DoxyCodeLine{5145     typename ::std::iterator\_traits<Iter>::value\_type>}
\DoxyCodeLine{5146 AnyOfArray(Iter first, Iter last) \{}
\DoxyCodeLine{5147   \textcolor{keywordflow}{return} internal::AnyOfArrayMatcher<}
\DoxyCodeLine{5148       typename ::std::iterator\_traits<Iter>::value\_type>(first, last);}
\DoxyCodeLine{5149 \}}
\DoxyCodeLine{5150 }
\DoxyCodeLine{5151 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Iter>}
\DoxyCodeLine{5152 \textcolor{keyword}{inline} internal::AllOfArrayMatcher<}
\DoxyCodeLine{5153     typename ::std::iterator\_traits<Iter>::value\_type>}
\DoxyCodeLine{5154 AllOfArray(Iter first, Iter last) \{}
\DoxyCodeLine{5155   \textcolor{keywordflow}{return} internal::AllOfArrayMatcher<}
\DoxyCodeLine{5156       typename ::std::iterator\_traits<Iter>::value\_type>(first, last);}
\DoxyCodeLine{5157 \}}
\DoxyCodeLine{5158 }
\DoxyCodeLine{5159 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{5160 \textcolor{keyword}{inline} internal::AnyOfArrayMatcher<T> AnyOfArray(\textcolor{keyword}{const} T* ptr, \textcolor{keywordtype}{size\_t} count) \{}
\DoxyCodeLine{5161   \textcolor{keywordflow}{return} AnyOfArray(ptr, ptr + count);}
\DoxyCodeLine{5162 \}}
\DoxyCodeLine{5163 }
\DoxyCodeLine{5164 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{5165 \textcolor{keyword}{inline} internal::AllOfArrayMatcher<T> AllOfArray(\textcolor{keyword}{const} T* ptr, \textcolor{keywordtype}{size\_t} count) \{}
\DoxyCodeLine{5166   \textcolor{keywordflow}{return} AllOfArray(ptr, ptr + count);}
\DoxyCodeLine{5167 \}}
\DoxyCodeLine{5168 }
\DoxyCodeLine{5169 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T, \textcolor{keywordtype}{size\_t} N>}
\DoxyCodeLine{5170 \textcolor{keyword}{inline} internal::AnyOfArrayMatcher<T> AnyOfArray(\textcolor{keyword}{const} T (\&array)[N]) \{}
\DoxyCodeLine{5171   \textcolor{keywordflow}{return} AnyOfArray(array, N);}
\DoxyCodeLine{5172 \}}
\DoxyCodeLine{5173 }
\DoxyCodeLine{5174 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T, \textcolor{keywordtype}{size\_t} N>}
\DoxyCodeLine{5175 \textcolor{keyword}{inline} internal::AllOfArrayMatcher<T> AllOfArray(\textcolor{keyword}{const} T (\&array)[N]) \{}
\DoxyCodeLine{5176   \textcolor{keywordflow}{return} AllOfArray(array, N);}
\DoxyCodeLine{5177 \}}
\DoxyCodeLine{5178 }
\DoxyCodeLine{5179 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Container>}
\DoxyCodeLine{5180 \textcolor{keyword}{inline} internal::AnyOfArrayMatcher<typename Container::value\_type> AnyOfArray(}
\DoxyCodeLine{5181     \textcolor{keyword}{const} Container\& container) \{}
\DoxyCodeLine{5182   \textcolor{keywordflow}{return} AnyOfArray(container.begin(), container.end());}
\DoxyCodeLine{5183 \}}
\DoxyCodeLine{5184 }
\DoxyCodeLine{5185 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Container>}
\DoxyCodeLine{5186 \textcolor{keyword}{inline} internal::AllOfArrayMatcher<typename Container::value\_type> AllOfArray(}
\DoxyCodeLine{5187     \textcolor{keyword}{const} Container\& container) \{}
\DoxyCodeLine{5188   \textcolor{keywordflow}{return} AllOfArray(container.begin(), container.end());}
\DoxyCodeLine{5189 \}}
\DoxyCodeLine{5190 }
\DoxyCodeLine{5191 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{5192 \textcolor{keyword}{inline} internal::AnyOfArrayMatcher<T> AnyOfArray(}
\DoxyCodeLine{5193     ::std::initializer\_list<T> xs) \{}
\DoxyCodeLine{5194   \textcolor{keywordflow}{return} AnyOfArray(xs.begin(), xs.end());}
\DoxyCodeLine{5195 \}}
\DoxyCodeLine{5196 }
\DoxyCodeLine{5197 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{5198 \textcolor{keyword}{inline} internal::AllOfArrayMatcher<T> AllOfArray(}
\DoxyCodeLine{5199     ::std::initializer\_list<T> xs) \{}
\DoxyCodeLine{5200   \textcolor{keywordflow}{return} AllOfArray(xs.begin(), xs.end());}
\DoxyCodeLine{5201 \}}
\DoxyCodeLine{5202 }
\DoxyCodeLine{5203 \textcolor{comment}{// Args<N1, N2, ..., Nk>(a\_matcher) matches a tuple if the selected}}
\DoxyCodeLine{5204 \textcolor{comment}{// fields of it matches a\_matcher.  C++ doesn't support default}}
\DoxyCodeLine{5205 \textcolor{comment}{// arguments for function templates, so we have to overload it.}}
\DoxyCodeLine{5206 \textcolor{keyword}{template} <\textcolor{keywordtype}{size\_t}... k, \textcolor{keyword}{typename} InnerMatcher>}
\DoxyCodeLine{5207 internal::ArgsMatcher<typename std::decay<InnerMatcher>::type, k...> Args(}
\DoxyCodeLine{5208     InnerMatcher\&\& matcher) \{}
\DoxyCodeLine{5209   \textcolor{keywordflow}{return} internal::ArgsMatcher<typename std::decay<InnerMatcher>::type, k...>(}
\DoxyCodeLine{5210       std::forward<InnerMatcher>(matcher));}
\DoxyCodeLine{5211 \}}
\DoxyCodeLine{5212 }
\DoxyCodeLine{5213 \textcolor{comment}{// AllArgs(m) is a synonym of m.  This is useful in}}
\DoxyCodeLine{5214 \textcolor{comment}{//}}
\DoxyCodeLine{5215 \textcolor{comment}{//   EXPECT\_CALL(foo, Bar(\_, \_)).With(AllArgs(Eq()));}}
\DoxyCodeLine{5216 \textcolor{comment}{//}}
\DoxyCodeLine{5217 \textcolor{comment}{// which is easier to read than}}
\DoxyCodeLine{5218 \textcolor{comment}{//}}
\DoxyCodeLine{5219 \textcolor{comment}{//   EXPECT\_CALL(foo, Bar(\_, \_)).With(Eq());}}
\DoxyCodeLine{5220 \textcolor{keyword}{template} <\textcolor{keyword}{typename} InnerMatcher>}
\DoxyCodeLine{5221 \textcolor{keyword}{inline} InnerMatcher AllArgs(\textcolor{keyword}{const} InnerMatcher\& matcher) \{}
\DoxyCodeLine{5222   \textcolor{keywordflow}{return} matcher;}
\DoxyCodeLine{5223 \}}
\DoxyCodeLine{5224 }
\DoxyCodeLine{5225 \textcolor{comment}{// Returns a matcher that matches the value of an optional<> type variable.}}
\DoxyCodeLine{5226 \textcolor{comment}{// The matcher implementation only uses '!arg' and requires that the optional<>}}
\DoxyCodeLine{5227 \textcolor{comment}{// type has a 'value\_type' member type and that '*arg' is of type 'value\_type'}}
\DoxyCodeLine{5228 \textcolor{comment}{// and is printable using 'PrintToString'. It is compatible with}}
\DoxyCodeLine{5229 \textcolor{comment}{// std::optional/std::experimental::optional.}}
\DoxyCodeLine{5230 \textcolor{comment}{// Note that to compare an optional type variable against nullopt you should}}
\DoxyCodeLine{5231 \textcolor{comment}{// use Eq(nullopt) and not Eq(Optional(nullopt)). The latter implies that the}}
\DoxyCodeLine{5232 \textcolor{comment}{// optional value contains an optional itself.}}
\DoxyCodeLine{5233 \textcolor{keyword}{template} <\textcolor{keyword}{typename} ValueMatcher>}
\DoxyCodeLine{5234 \textcolor{keyword}{inline} internal::OptionalMatcher<ValueMatcher> Optional(}
\DoxyCodeLine{5235     \textcolor{keyword}{const} ValueMatcher\& value\_matcher) \{}
\DoxyCodeLine{5236   \textcolor{keywordflow}{return} internal::OptionalMatcher<ValueMatcher>(value\_matcher);}
\DoxyCodeLine{5237 \}}
\DoxyCodeLine{5238 }
\DoxyCodeLine{5239 \textcolor{comment}{// Returns a matcher that matches the value of a absl::any type variable.}}
\DoxyCodeLine{5240 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{5241 PolymorphicMatcher<internal::any\_cast\_matcher::AnyCastMatcher<T>> AnyWith(}
\DoxyCodeLine{5242     \textcolor{keyword}{const} Matcher<const T\&>\& matcher) \{}
\DoxyCodeLine{5243   \textcolor{keywordflow}{return} MakePolymorphicMatcher(}
\DoxyCodeLine{5244       internal::any\_cast\_matcher::AnyCastMatcher<T>(matcher));}
\DoxyCodeLine{5245 \}}
\DoxyCodeLine{5246 }
\DoxyCodeLine{5247 \textcolor{comment}{// Returns a matcher that matches the value of a variant<> type variable.}}
\DoxyCodeLine{5248 \textcolor{comment}{// The matcher implementation uses ADL to find the holds\_alternative and get}}
\DoxyCodeLine{5249 \textcolor{comment}{// functions.}}
\DoxyCodeLine{5250 \textcolor{comment}{// It is compatible with std::variant.}}
\DoxyCodeLine{5251 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{5252 PolymorphicMatcher<internal::variant\_matcher::VariantMatcher<T>> VariantWith(}
\DoxyCodeLine{5253     \textcolor{keyword}{const} Matcher<const T\&>\& matcher) \{}
\DoxyCodeLine{5254   \textcolor{keywordflow}{return} MakePolymorphicMatcher(}
\DoxyCodeLine{5255       internal::variant\_matcher::VariantMatcher<T>(matcher));}
\DoxyCodeLine{5256 \}}
\DoxyCodeLine{5257 }
\DoxyCodeLine{5258 \textcolor{preprocessor}{\#if GTEST\_HAS\_EXCEPTIONS}}
\DoxyCodeLine{5259 }
\DoxyCodeLine{5260 \textcolor{comment}{// Anything inside the `internal` namespace is internal to the implementation}}
\DoxyCodeLine{5261 \textcolor{comment}{// and must not be used in user code!}}
\DoxyCodeLine{5262 \textcolor{keyword}{namespace }internal \{}
\DoxyCodeLine{5263 }
\DoxyCodeLine{5264 \textcolor{keyword}{class }WithWhatMatcherImpl \{}
\DoxyCodeLine{5265  \textcolor{keyword}{public}:}
\DoxyCodeLine{5266   WithWhatMatcherImpl(Matcher<std::string> matcher)}
\DoxyCodeLine{5267       : matcher\_(std::move(matcher)) \{\}}
\DoxyCodeLine{5268 }
\DoxyCodeLine{5269   \textcolor{keywordtype}{void} DescribeTo(std::ostream* os)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{5270     *os << \textcolor{stringliteral}{"{}contains .what() that "{}};}
\DoxyCodeLine{5271     matcher\_.DescribeTo(os);}
\DoxyCodeLine{5272   \}}
\DoxyCodeLine{5273 }
\DoxyCodeLine{5274   \textcolor{keywordtype}{void} DescribeNegationTo(std::ostream* os)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{5275     *os << \textcolor{stringliteral}{"{}contains .what() that does not "{}};}
\DoxyCodeLine{5276     matcher\_.DescribeTo(os);}
\DoxyCodeLine{5277   \}}
\DoxyCodeLine{5278 }
\DoxyCodeLine{5279   \textcolor{keyword}{template} <\textcolor{keyword}{typename} Err>}
\DoxyCodeLine{5280   \textcolor{keywordtype}{bool} MatchAndExplain(\textcolor{keyword}{const} Err\& err, MatchResultListener* listener)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{5281     *listener << \textcolor{stringliteral}{"{}which contains .what() (of value = "{}} << err.what()}
\DoxyCodeLine{5282               << \textcolor{stringliteral}{"{}) that "{}};}
\DoxyCodeLine{5283     \textcolor{keywordflow}{return} matcher\_.MatchAndExplain(err.what(), listener);}
\DoxyCodeLine{5284   \}}
\DoxyCodeLine{5285 }
\DoxyCodeLine{5286  \textcolor{keyword}{private}:}
\DoxyCodeLine{5287   \textcolor{keyword}{const} Matcher<std::string> matcher\_;}
\DoxyCodeLine{5288 \};}
\DoxyCodeLine{5289 }
\DoxyCodeLine{5290 \textcolor{keyword}{inline} PolymorphicMatcher<WithWhatMatcherImpl> WithWhat(}
\DoxyCodeLine{5291     Matcher<std::string> m) \{}
\DoxyCodeLine{5292   \textcolor{keywordflow}{return} MakePolymorphicMatcher(WithWhatMatcherImpl(std::move(m)));}
\DoxyCodeLine{5293 \}}
\DoxyCodeLine{5294 }
\DoxyCodeLine{5295 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Err>}
\DoxyCodeLine{5296 \textcolor{keyword}{class }ExceptionMatcherImpl \{}
\DoxyCodeLine{5297   \textcolor{keyword}{class }NeverThrown \{}
\DoxyCodeLine{5298    \textcolor{keyword}{public}:}
\DoxyCodeLine{5299     \textcolor{keyword}{const} \textcolor{keywordtype}{char}* what() const noexcept \{}
\DoxyCodeLine{5300       \textcolor{keywordflow}{return} \textcolor{stringliteral}{"{}this exception should never be thrown"{}};}
\DoxyCodeLine{5301     \}}
\DoxyCodeLine{5302   \};}
\DoxyCodeLine{5303 }
\DoxyCodeLine{5304   \textcolor{comment}{// If the matchee raises an exception of a wrong type, we'd like to}}
\DoxyCodeLine{5305   \textcolor{comment}{// catch it and print its message and type. To do that, we add an additional}}
\DoxyCodeLine{5306   \textcolor{comment}{// catch clause:}}
\DoxyCodeLine{5307   \textcolor{comment}{//}}
\DoxyCodeLine{5308   \textcolor{comment}{//     try \{ ... \}}}
\DoxyCodeLine{5309   \textcolor{comment}{//     catch (const Err\&) \{ /* an expected exception */ \}}}
\DoxyCodeLine{5310   \textcolor{comment}{//     catch (const std::exception\&) \{ /* exception of a wrong type */ \}}}
\DoxyCodeLine{5311   \textcolor{comment}{//}}
\DoxyCodeLine{5312   \textcolor{comment}{// However, if the `Err` itself is `std::exception`, we'd end up with two}}
\DoxyCodeLine{5313   \textcolor{comment}{// identical `catch` clauses:}}
\DoxyCodeLine{5314   \textcolor{comment}{//}}
\DoxyCodeLine{5315   \textcolor{comment}{//     try \{ ... \}}}
\DoxyCodeLine{5316   \textcolor{comment}{//     catch (const std::exception\&) \{ /* an expected exception */ \}}}
\DoxyCodeLine{5317   \textcolor{comment}{//     catch (const std::exception\&) \{ /* exception of a wrong type */ \}}}
\DoxyCodeLine{5318   \textcolor{comment}{//}}
\DoxyCodeLine{5319   \textcolor{comment}{// This can cause a warning or an error in some compilers. To resolve}}
\DoxyCodeLine{5320   \textcolor{comment}{// the issue, we use a fake error type whenever `Err` is `std::exception`:}}
\DoxyCodeLine{5321   \textcolor{comment}{//}}
\DoxyCodeLine{5322   \textcolor{comment}{//     try \{ ... \}}}
\DoxyCodeLine{5323   \textcolor{comment}{//     catch (const std::exception\&) \{ /* an expected exception */ \}}}
\DoxyCodeLine{5324   \textcolor{comment}{//     catch (const NeverThrown\&) \{ /* exception of a wrong type */ \}}}
\DoxyCodeLine{5325   \textcolor{keyword}{using }DefaultExceptionType = \textcolor{keyword}{typename} std::conditional<}
\DoxyCodeLine{5326       std::is\_same<\textcolor{keyword}{typename} std::remove\_cv<}
\DoxyCodeLine{5327                        \textcolor{keyword}{typename} std::remove\_reference<Err>::type>::type,}
\DoxyCodeLine{5328                    std::exception>::value,}
\DoxyCodeLine{5329       \textcolor{keyword}{const} NeverThrown\&, \textcolor{keyword}{const} std::exception\&>::type;}
\DoxyCodeLine{5330 }
\DoxyCodeLine{5331  \textcolor{keyword}{public}:}
\DoxyCodeLine{5332   ExceptionMatcherImpl(Matcher<const Err\&> matcher)}
\DoxyCodeLine{5333       : matcher\_(std::move(matcher)) \{\}}
\DoxyCodeLine{5334 }
\DoxyCodeLine{5335   \textcolor{keywordtype}{void} DescribeTo(std::ostream* os)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{5336     *os << \textcolor{stringliteral}{"{}throws an exception which is a "{}} << GetTypeName<Err>();}
\DoxyCodeLine{5337     *os << \textcolor{stringliteral}{"{} which "{}};}
\DoxyCodeLine{5338     matcher\_.DescribeTo(os);}
\DoxyCodeLine{5339   \}}
\DoxyCodeLine{5340 }
\DoxyCodeLine{5341   \textcolor{keywordtype}{void} DescribeNegationTo(std::ostream* os)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{5342     *os << \textcolor{stringliteral}{"{}throws an exception which is not a "{}} << GetTypeName<Err>();}
\DoxyCodeLine{5343     *os << \textcolor{stringliteral}{"{} which "{}};}
\DoxyCodeLine{5344     matcher\_.DescribeNegationTo(os);}
\DoxyCodeLine{5345   \}}
\DoxyCodeLine{5346 }
\DoxyCodeLine{5347   \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{5348   \textcolor{keywordtype}{bool} MatchAndExplain(T\&\& x, MatchResultListener* listener)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{5349     \textcolor{keywordflow}{try} \{}
\DoxyCodeLine{5350       (void)(std::forward<T>(x)());}
\DoxyCodeLine{5351     \} \textcolor{keywordflow}{catch} (\textcolor{keyword}{const} Err\& err) \{}
\DoxyCodeLine{5352       *listener << \textcolor{stringliteral}{"{}throws an exception which is a "{}} << GetTypeName<Err>();}
\DoxyCodeLine{5353       *listener << \textcolor{stringliteral}{"{} "{}};}
\DoxyCodeLine{5354       \textcolor{keywordflow}{return} matcher\_.MatchAndExplain(err, listener);}
\DoxyCodeLine{5355     \} \textcolor{keywordflow}{catch} (DefaultExceptionType err) \{}
\DoxyCodeLine{5356 \textcolor{preprocessor}{\#if GTEST\_HAS\_RTTI}}
\DoxyCodeLine{5357       *listener << \textcolor{stringliteral}{"{}throws an exception of type "{}} << GetTypeName(\textcolor{keyword}{typeid}(err));}
\DoxyCodeLine{5358       *listener << \textcolor{stringliteral}{"{} "{}};}
\DoxyCodeLine{5359 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{5360       *listener << \textcolor{stringliteral}{"{}throws an std::exception-\/derived type "{}};}
\DoxyCodeLine{5361 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{5362       *listener << \textcolor{stringliteral}{"{}with description \(\backslash\)"{}"{}} << err.what() << \textcolor{stringliteral}{"{}\(\backslash\)"{}"{}};}
\DoxyCodeLine{5363       \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{5364     \} \textcolor{keywordflow}{catch} (...) \{}
\DoxyCodeLine{5365       *listener << \textcolor{stringliteral}{"{}throws an exception of an unknown type"{}};}
\DoxyCodeLine{5366       \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{5367     \}}
\DoxyCodeLine{5368 }
\DoxyCodeLine{5369     *listener << \textcolor{stringliteral}{"{}does not throw any exception"{}};}
\DoxyCodeLine{5370     \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{5371   \}}
\DoxyCodeLine{5372 }
\DoxyCodeLine{5373  \textcolor{keyword}{private}:}
\DoxyCodeLine{5374   \textcolor{keyword}{const} Matcher<const Err\&> matcher\_;}
\DoxyCodeLine{5375 \};}
\DoxyCodeLine{5376 }
\DoxyCodeLine{5377 \}  \textcolor{comment}{// namespace internal}}
\DoxyCodeLine{5378 }
\DoxyCodeLine{5379 \textcolor{comment}{// Throws()}}
\DoxyCodeLine{5380 \textcolor{comment}{// Throws(exceptionMatcher)}}
\DoxyCodeLine{5381 \textcolor{comment}{// ThrowsMessage(messageMatcher)}}
\DoxyCodeLine{5382 \textcolor{comment}{//}}
\DoxyCodeLine{5383 \textcolor{comment}{// This matcher accepts a callable and verifies that when invoked, it throws}}
\DoxyCodeLine{5384 \textcolor{comment}{// an exception with the given type and properties.}}
\DoxyCodeLine{5385 \textcolor{comment}{//}}
\DoxyCodeLine{5386 \textcolor{comment}{// Examples:}}
\DoxyCodeLine{5387 \textcolor{comment}{//}}
\DoxyCodeLine{5388 \textcolor{comment}{//   EXPECT\_THAT(}}
\DoxyCodeLine{5389 \textcolor{comment}{//       []() \{ throw std::runtime\_error("{}message"{}); \},}}
\DoxyCodeLine{5390 \textcolor{comment}{//       Throws<std::runtime\_error>());}}
\DoxyCodeLine{5391 \textcolor{comment}{//}}
\DoxyCodeLine{5392 \textcolor{comment}{//   EXPECT\_THAT(}}
\DoxyCodeLine{5393 \textcolor{comment}{//       []() \{ throw std::runtime\_error("{}message"{}); \},}}
\DoxyCodeLine{5394 \textcolor{comment}{//       ThrowsMessage<std::runtime\_error>(HasSubstr("{}message"{})));}}
\DoxyCodeLine{5395 \textcolor{comment}{//}}
\DoxyCodeLine{5396 \textcolor{comment}{//   EXPECT\_THAT(}}
\DoxyCodeLine{5397 \textcolor{comment}{//       []() \{ throw std::runtime\_error("{}message"{}); \},}}
\DoxyCodeLine{5398 \textcolor{comment}{//       Throws<std::runtime\_error>(}}
\DoxyCodeLine{5399 \textcolor{comment}{//           Property(\&std::runtime\_error::what, HasSubstr("{}message"{}))));}}
\DoxyCodeLine{5400 }
\DoxyCodeLine{5401 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Err>}
\DoxyCodeLine{5402 PolymorphicMatcher<internal::ExceptionMatcherImpl<Err>> Throws() \{}
\DoxyCodeLine{5403   \textcolor{keywordflow}{return} MakePolymorphicMatcher(}
\DoxyCodeLine{5404       internal::ExceptionMatcherImpl<Err>(A<const Err\&>()));}
\DoxyCodeLine{5405 \}}
\DoxyCodeLine{5406 }
\DoxyCodeLine{5407 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Err, \textcolor{keyword}{typename} ExceptionMatcher>}
\DoxyCodeLine{5408 PolymorphicMatcher<internal::ExceptionMatcherImpl<Err>> Throws(}
\DoxyCodeLine{5409     \textcolor{keyword}{const} ExceptionMatcher\& exception\_matcher) \{}
\DoxyCodeLine{5410   \textcolor{comment}{// Using matcher cast allows users to pass a matcher of a more broad type.}}
\DoxyCodeLine{5411   \textcolor{comment}{// For example user may want to pass Matcher<std::exception>}}
\DoxyCodeLine{5412   \textcolor{comment}{// to Throws<std::runtime\_error>, or Matcher<int64> to Throws<int32>.}}
\DoxyCodeLine{5413   \textcolor{keywordflow}{return} MakePolymorphicMatcher(internal::ExceptionMatcherImpl<Err>(}
\DoxyCodeLine{5414       SafeMatcherCast<const Err\&>(exception\_matcher)));}
\DoxyCodeLine{5415 \}}
\DoxyCodeLine{5416 }
\DoxyCodeLine{5417 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Err, \textcolor{keyword}{typename} MessageMatcher>}
\DoxyCodeLine{5418 PolymorphicMatcher<internal::ExceptionMatcherImpl<Err>> ThrowsMessage(}
\DoxyCodeLine{5419     MessageMatcher\&\& message\_matcher) \{}
\DoxyCodeLine{5420   \textcolor{keyword}{static\_assert}(std::is\_base\_of<std::exception, Err>::value,}
\DoxyCodeLine{5421                 \textcolor{stringliteral}{"{}expected an std::exception-\/derived type"{}});}
\DoxyCodeLine{5422   \textcolor{keywordflow}{return} Throws<Err>(internal::WithWhat(}
\DoxyCodeLine{5423       MatcherCast<std::string>(std::forward<MessageMatcher>(message\_matcher))));}
\DoxyCodeLine{5424 \}}
\DoxyCodeLine{5425 }
\DoxyCodeLine{5426 \textcolor{preprocessor}{\#endif  }\textcolor{comment}{// GTEST\_HAS\_EXCEPTIONS}}
\DoxyCodeLine{5427 }
\DoxyCodeLine{5428 \textcolor{comment}{// These macros allow using matchers to check values in Google Test}}
\DoxyCodeLine{5429 \textcolor{comment}{// tests.  ASSERT\_THAT(value, matcher) and EXPECT\_THAT(value, matcher)}}
\DoxyCodeLine{5430 \textcolor{comment}{// succeed if and only if the value matches the matcher.  If the assertion}}
\DoxyCodeLine{5431 \textcolor{comment}{// fails, the value and the description of the matcher will be printed.}}
\DoxyCodeLine{5432 \textcolor{preprocessor}{\#define ASSERT\_THAT(value, matcher) \(\backslash\)}}
\DoxyCodeLine{5433 \textcolor{preprocessor}{  ASSERT\_PRED\_FORMAT1(              \(\backslash\)}}
\DoxyCodeLine{5434 \textcolor{preprocessor}{      ::testing::internal::MakePredicateFormatterFromMatcher(matcher), value)}}
\DoxyCodeLine{5435 \textcolor{preprocessor}{\#define EXPECT\_THAT(value, matcher) \(\backslash\)}}
\DoxyCodeLine{5436 \textcolor{preprocessor}{  EXPECT\_PRED\_FORMAT1(              \(\backslash\)}}
\DoxyCodeLine{5437 \textcolor{preprocessor}{      ::testing::internal::MakePredicateFormatterFromMatcher(matcher), value)}}
\DoxyCodeLine{5438 }
\DoxyCodeLine{5439 \textcolor{comment}{// MATCHER* macros itself are listed below.}}
\DoxyCodeLine{5440 \textcolor{preprocessor}{\#define MATCHER(name, description)                                             \(\backslash\)}}
\DoxyCodeLine{5441 \textcolor{preprocessor}{  class name\#\#Matcher                                                          \(\backslash\)}}
\DoxyCodeLine{5442 \textcolor{preprocessor}{      : public ::testing::internal::MatcherBaseImpl<name\#\#Matcher> \{           \(\backslash\)}}
\DoxyCodeLine{5443 \textcolor{preprocessor}{   public:                                                                     \(\backslash\)}}
\DoxyCodeLine{5444 \textcolor{preprocessor}{    template <typename arg\_type>                                               \(\backslash\)}}
\DoxyCodeLine{5445 \textcolor{preprocessor}{    class gmock\_Impl : public ::testing::MatcherInterface<const arg\_type\&> \{   \(\backslash\)}}
\DoxyCodeLine{5446 \textcolor{preprocessor}{     public:                                                                   \(\backslash\)}}
\DoxyCodeLine{5447 \textcolor{preprocessor}{      gmock\_Impl() \{\}                                                          \(\backslash\)}}
\DoxyCodeLine{5448 \textcolor{preprocessor}{      bool MatchAndExplain(                                                    \(\backslash\)}}
\DoxyCodeLine{5449 \textcolor{preprocessor}{          const arg\_type\& arg,                                                 \(\backslash\)}}
\DoxyCodeLine{5450 \textcolor{preprocessor}{          ::testing::MatchResultListener* result\_listener) const override;     \(\backslash\)}}
\DoxyCodeLine{5451 \textcolor{preprocessor}{      void DescribeTo(::std::ostream* gmock\_os) const override \{               \(\backslash\)}}
\DoxyCodeLine{5452 \textcolor{preprocessor}{        *gmock\_os << FormatDescription(false);                                 \(\backslash\)}}
\DoxyCodeLine{5453 \textcolor{preprocessor}{      \}                                                                        \(\backslash\)}}
\DoxyCodeLine{5454 \textcolor{preprocessor}{      void DescribeNegationTo(::std::ostream* gmock\_os) const override \{       \(\backslash\)}}
\DoxyCodeLine{5455 \textcolor{preprocessor}{        *gmock\_os << FormatDescription(true);                                  \(\backslash\)}}
\DoxyCodeLine{5456 \textcolor{preprocessor}{      \}                                                                        \(\backslash\)}}
\DoxyCodeLine{5457 \textcolor{preprocessor}{                                                                               \(\backslash\)}}
\DoxyCodeLine{5458 \textcolor{preprocessor}{     private:                                                                  \(\backslash\)}}
\DoxyCodeLine{5459 \textcolor{preprocessor}{      ::std::string FormatDescription(bool negation) const \{                   \(\backslash\)}}
\DoxyCodeLine{5460 \textcolor{preprocessor}{        }\textcolor{comment}{/* NOLINTNEXTLINE readability-\/redundant-\/string-\/init */}\textcolor{preprocessor}{                 \(\backslash\)}}
\DoxyCodeLine{5461 \textcolor{preprocessor}{        ::std::string gmock\_description = (description);                       \(\backslash\)}}
\DoxyCodeLine{5462 \textcolor{preprocessor}{        if (!gmock\_description.empty()) \{                                      \(\backslash\)}}
\DoxyCodeLine{5463 \textcolor{preprocessor}{          return gmock\_description;                                            \(\backslash\)}}
\DoxyCodeLine{5464 \textcolor{preprocessor}{        \}                                                                      \(\backslash\)}}
\DoxyCodeLine{5465 \textcolor{preprocessor}{        return ::testing::internal::FormatMatcherDescription(negation, \#name,  \(\backslash\)}}
\DoxyCodeLine{5466 \textcolor{preprocessor}{                                                             \{\}, \{\});          \(\backslash\)}}
\DoxyCodeLine{5467 \textcolor{preprocessor}{      \}                                                                        \(\backslash\)}}
\DoxyCodeLine{5468 \textcolor{preprocessor}{    \};                                                                         \(\backslash\)}}
\DoxyCodeLine{5469 \textcolor{preprocessor}{  \};                                                                           \(\backslash\)}}
\DoxyCodeLine{5470 \textcolor{preprocessor}{  GTEST\_ATTRIBUTE\_UNUSED\_ inline name\#\#Matcher name() \{ return \{\}; \}           \(\backslash\)}}
\DoxyCodeLine{5471 \textcolor{preprocessor}{  template <typename arg\_type>                                                 \(\backslash\)}}
\DoxyCodeLine{5472 \textcolor{preprocessor}{  bool name\#\#Matcher::gmock\_Impl<arg\_type>::MatchAndExplain(                   \(\backslash\)}}
\DoxyCodeLine{5473 \textcolor{preprocessor}{      const arg\_type\& arg,                                                     \(\backslash\)}}
\DoxyCodeLine{5474 \textcolor{preprocessor}{      ::testing::MatchResultListener* result\_listener GTEST\_ATTRIBUTE\_UNUSED\_) \(\backslash\)}}
\DoxyCodeLine{5475 \textcolor{preprocessor}{      const}}
\DoxyCodeLine{5476 }
\DoxyCodeLine{5477 \textcolor{preprocessor}{\#define MATCHER\_P(name, p0, description) \(\backslash\)}}
\DoxyCodeLine{5478 \textcolor{preprocessor}{  GMOCK\_INTERNAL\_MATCHER(name, name\#\#MatcherP, description, (\#p0), (p0))}}
\DoxyCodeLine{5479 \textcolor{preprocessor}{\#define MATCHER\_P2(name, p0, p1, description)                            \(\backslash\)}}
\DoxyCodeLine{5480 \textcolor{preprocessor}{  GMOCK\_INTERNAL\_MATCHER(name, name\#\#MatcherP2, description, (\#p0, \#p1), \(\backslash\)}}
\DoxyCodeLine{5481 \textcolor{preprocessor}{                         (p0, p1))}}
\DoxyCodeLine{5482 \textcolor{preprocessor}{\#define MATCHER\_P3(name, p0, p1, p2, description)                             \(\backslash\)}}
\DoxyCodeLine{5483 \textcolor{preprocessor}{  GMOCK\_INTERNAL\_MATCHER(name, name\#\#MatcherP3, description, (\#p0, \#p1, \#p2), \(\backslash\)}}
\DoxyCodeLine{5484 \textcolor{preprocessor}{                         (p0, p1, p2))}}
\DoxyCodeLine{5485 \textcolor{preprocessor}{\#define MATCHER\_P4(name, p0, p1, p2, p3, description)        \(\backslash\)}}
\DoxyCodeLine{5486 \textcolor{preprocessor}{  GMOCK\_INTERNAL\_MATCHER(name, name\#\#MatcherP4, description, \(\backslash\)}}
\DoxyCodeLine{5487 \textcolor{preprocessor}{                         (\#p0, \#p1, \#p2, \#p3), (p0, p1, p2, p3))}}
\DoxyCodeLine{5488 \textcolor{preprocessor}{\#define MATCHER\_P5(name, p0, p1, p2, p3, p4, description)    \(\backslash\)}}
\DoxyCodeLine{5489 \textcolor{preprocessor}{  GMOCK\_INTERNAL\_MATCHER(name, name\#\#MatcherP5, description, \(\backslash\)}}
\DoxyCodeLine{5490 \textcolor{preprocessor}{                         (\#p0, \#p1, \#p2, \#p3, \#p4), (p0, p1, p2, p3, p4))}}
\DoxyCodeLine{5491 \textcolor{preprocessor}{\#define MATCHER\_P6(name, p0, p1, p2, p3, p4, p5, description) \(\backslash\)}}
\DoxyCodeLine{5492 \textcolor{preprocessor}{  GMOCK\_INTERNAL\_MATCHER(name, name\#\#MatcherP6, description,  \(\backslash\)}}
\DoxyCodeLine{5493 \textcolor{preprocessor}{                         (\#p0, \#p1, \#p2, \#p3, \#p4, \#p5),      \(\backslash\)}}
\DoxyCodeLine{5494 \textcolor{preprocessor}{                         (p0, p1, p2, p3, p4, p5))}}
\DoxyCodeLine{5495 \textcolor{preprocessor}{\#define MATCHER\_P7(name, p0, p1, p2, p3, p4, p5, p6, description) \(\backslash\)}}
\DoxyCodeLine{5496 \textcolor{preprocessor}{  GMOCK\_INTERNAL\_MATCHER(name, name\#\#MatcherP7, description,      \(\backslash\)}}
\DoxyCodeLine{5497 \textcolor{preprocessor}{                         (\#p0, \#p1, \#p2, \#p3, \#p4, \#p5, \#p6),     \(\backslash\)}}
\DoxyCodeLine{5498 \textcolor{preprocessor}{                         (p0, p1, p2, p3, p4, p5, p6))}}
\DoxyCodeLine{5499 \textcolor{preprocessor}{\#define MATCHER\_P8(name, p0, p1, p2, p3, p4, p5, p6, p7, description) \(\backslash\)}}
\DoxyCodeLine{5500 \textcolor{preprocessor}{  GMOCK\_INTERNAL\_MATCHER(name, name\#\#MatcherP8, description,          \(\backslash\)}}
\DoxyCodeLine{5501 \textcolor{preprocessor}{                         (\#p0, \#p1, \#p2, \#p3, \#p4, \#p5, \#p6, \#p7),    \(\backslash\)}}
\DoxyCodeLine{5502 \textcolor{preprocessor}{                         (p0, p1, p2, p3, p4, p5, p6, p7))}}
\DoxyCodeLine{5503 \textcolor{preprocessor}{\#define MATCHER\_P9(name, p0, p1, p2, p3, p4, p5, p6, p7, p8, description) \(\backslash\)}}
\DoxyCodeLine{5504 \textcolor{preprocessor}{  GMOCK\_INTERNAL\_MATCHER(name, name\#\#MatcherP9, description,              \(\backslash\)}}
\DoxyCodeLine{5505 \textcolor{preprocessor}{                         (\#p0, \#p1, \#p2, \#p3, \#p4, \#p5, \#p6, \#p7, \#p8),   \(\backslash\)}}
\DoxyCodeLine{5506 \textcolor{preprocessor}{                         (p0, p1, p2, p3, p4, p5, p6, p7, p8))}}
\DoxyCodeLine{5507 \textcolor{preprocessor}{\#define MATCHER\_P10(name, p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, description) \(\backslash\)}}
\DoxyCodeLine{5508 \textcolor{preprocessor}{  GMOCK\_INTERNAL\_MATCHER(name, name\#\#MatcherP10, description,                  \(\backslash\)}}
\DoxyCodeLine{5509 \textcolor{preprocessor}{                         (\#p0, \#p1, \#p2, \#p3, \#p4, \#p5, \#p6, \#p7, \#p8, \#p9),   \(\backslash\)}}
\DoxyCodeLine{5510 \textcolor{preprocessor}{                         (p0, p1, p2, p3, p4, p5, p6, p7, p8, p9))}}
\DoxyCodeLine{5511 }
\DoxyCodeLine{5512 \textcolor{preprocessor}{\#define GMOCK\_INTERNAL\_MATCHER(name, full\_name, description, arg\_names, args)  \(\backslash\)}}
\DoxyCodeLine{5513 \textcolor{preprocessor}{  template <GMOCK\_INTERNAL\_MATCHER\_TEMPLATE\_PARAMS(args)>                      \(\backslash\)}}
\DoxyCodeLine{5514 \textcolor{preprocessor}{  class full\_name : public ::testing::internal::MatcherBaseImpl<               \(\backslash\)}}
\DoxyCodeLine{5515 \textcolor{preprocessor}{                        full\_name<GMOCK\_INTERNAL\_MATCHER\_TYPE\_PARAMS(args)>> \{ \(\backslash\)}}
\DoxyCodeLine{5516 \textcolor{preprocessor}{   public:                                                                     \(\backslash\)}}
\DoxyCodeLine{5517 \textcolor{preprocessor}{    using full\_name::MatcherBaseImpl::MatcherBaseImpl;                         \(\backslash\)}}
\DoxyCodeLine{5518 \textcolor{preprocessor}{    template <typename arg\_type>                                               \(\backslash\)}}
\DoxyCodeLine{5519 \textcolor{preprocessor}{    class gmock\_Impl : public ::testing::MatcherInterface<const arg\_type\&> \{   \(\backslash\)}}
\DoxyCodeLine{5520 \textcolor{preprocessor}{     public:                                                                   \(\backslash\)}}
\DoxyCodeLine{5521 \textcolor{preprocessor}{      explicit gmock\_Impl(GMOCK\_INTERNAL\_MATCHER\_FUNCTION\_ARGS(args))          \(\backslash\)}}
\DoxyCodeLine{5522 \textcolor{preprocessor}{          : GMOCK\_INTERNAL\_MATCHER\_FORWARD\_ARGS(args) \{\}                       \(\backslash\)}}
\DoxyCodeLine{5523 \textcolor{preprocessor}{      bool MatchAndExplain(                                                    \(\backslash\)}}
\DoxyCodeLine{5524 \textcolor{preprocessor}{          const arg\_type\& arg,                                                 \(\backslash\)}}
\DoxyCodeLine{5525 \textcolor{preprocessor}{          ::testing::MatchResultListener* result\_listener) const override;     \(\backslash\)}}
\DoxyCodeLine{5526 \textcolor{preprocessor}{      void DescribeTo(::std::ostream* gmock\_os) const override \{               \(\backslash\)}}
\DoxyCodeLine{5527 \textcolor{preprocessor}{        *gmock\_os << FormatDescription(false);                                 \(\backslash\)}}
\DoxyCodeLine{5528 \textcolor{preprocessor}{      \}                                                                        \(\backslash\)}}
\DoxyCodeLine{5529 \textcolor{preprocessor}{      void DescribeNegationTo(::std::ostream* gmock\_os) const override \{       \(\backslash\)}}
\DoxyCodeLine{5530 \textcolor{preprocessor}{        *gmock\_os << FormatDescription(true);                                  \(\backslash\)}}
\DoxyCodeLine{5531 \textcolor{preprocessor}{      \}                                                                        \(\backslash\)}}
\DoxyCodeLine{5532 \textcolor{preprocessor}{      GMOCK\_INTERNAL\_MATCHER\_MEMBERS(args)                                     \(\backslash\)}}
\DoxyCodeLine{5533 \textcolor{preprocessor}{                                                                               \(\backslash\)}}
\DoxyCodeLine{5534 \textcolor{preprocessor}{     private:                                                                  \(\backslash\)}}
\DoxyCodeLine{5535 \textcolor{preprocessor}{      ::std::string FormatDescription(bool negation) const \{                   \(\backslash\)}}
\DoxyCodeLine{5536 \textcolor{preprocessor}{        ::std::string gmock\_description = (description);                       \(\backslash\)}}
\DoxyCodeLine{5537 \textcolor{preprocessor}{        if (!gmock\_description.empty()) \{                                      \(\backslash\)}}
\DoxyCodeLine{5538 \textcolor{preprocessor}{          return gmock\_description;                                            \(\backslash\)}}
\DoxyCodeLine{5539 \textcolor{preprocessor}{        \}                                                                      \(\backslash\)}}
\DoxyCodeLine{5540 \textcolor{preprocessor}{        return ::testing::internal::FormatMatcherDescription(                  \(\backslash\)}}
\DoxyCodeLine{5541 \textcolor{preprocessor}{            negation, \#name, \{GMOCK\_PP\_REMOVE\_PARENS(arg\_names)\},              \(\backslash\)}}
\DoxyCodeLine{5542 \textcolor{preprocessor}{            ::testing::internal::UniversalTersePrintTupleFieldsToStrings(      \(\backslash\)}}
\DoxyCodeLine{5543 \textcolor{preprocessor}{                ::std::tuple<GMOCK\_INTERNAL\_MATCHER\_TYPE\_PARAMS(args)>(        \(\backslash\)}}
\DoxyCodeLine{5544 \textcolor{preprocessor}{                    GMOCK\_INTERNAL\_MATCHER\_MEMBERS\_USAGE(args))));             \(\backslash\)}}
\DoxyCodeLine{5545 \textcolor{preprocessor}{      \}                                                                        \(\backslash\)}}
\DoxyCodeLine{5546 \textcolor{preprocessor}{    \};                                                                         \(\backslash\)}}
\DoxyCodeLine{5547 \textcolor{preprocessor}{  \};                                                                           \(\backslash\)}}
\DoxyCodeLine{5548 \textcolor{preprocessor}{  template <GMOCK\_INTERNAL\_MATCHER\_TEMPLATE\_PARAMS(args)>                      \(\backslash\)}}
\DoxyCodeLine{5549 \textcolor{preprocessor}{  inline full\_name<GMOCK\_INTERNAL\_MATCHER\_TYPE\_PARAMS(args)> name(             \(\backslash\)}}
\DoxyCodeLine{5550 \textcolor{preprocessor}{      GMOCK\_INTERNAL\_MATCHER\_FUNCTION\_ARGS(args)) \{                            \(\backslash\)}}
\DoxyCodeLine{5551 \textcolor{preprocessor}{    return full\_name<GMOCK\_INTERNAL\_MATCHER\_TYPE\_PARAMS(args)>(                \(\backslash\)}}
\DoxyCodeLine{5552 \textcolor{preprocessor}{        GMOCK\_INTERNAL\_MATCHER\_ARGS\_USAGE(args));                              \(\backslash\)}}
\DoxyCodeLine{5553 \textcolor{preprocessor}{  \}                                                                            \(\backslash\)}}
\DoxyCodeLine{5554 \textcolor{preprocessor}{  template <GMOCK\_INTERNAL\_MATCHER\_TEMPLATE\_PARAMS(args)>                      \(\backslash\)}}
\DoxyCodeLine{5555 \textcolor{preprocessor}{  template <typename arg\_type>                                                 \(\backslash\)}}
\DoxyCodeLine{5556 \textcolor{preprocessor}{  bool full\_name<GMOCK\_INTERNAL\_MATCHER\_TYPE\_PARAMS(args)>::gmock\_Impl<        \(\backslash\)}}
\DoxyCodeLine{5557 \textcolor{preprocessor}{      arg\_type>::MatchAndExplain(const arg\_type\& arg,                          \(\backslash\)}}
\DoxyCodeLine{5558 \textcolor{preprocessor}{                                 ::testing::MatchResultListener*               \(\backslash\)}}
\DoxyCodeLine{5559 \textcolor{preprocessor}{                                     result\_listener GTEST\_ATTRIBUTE\_UNUSED\_)  \(\backslash\)}}
\DoxyCodeLine{5560 \textcolor{preprocessor}{      const}}
\DoxyCodeLine{5561 }
\DoxyCodeLine{5562 \textcolor{preprocessor}{\#define GMOCK\_INTERNAL\_MATCHER\_TEMPLATE\_PARAMS(args) \(\backslash\)}}
\DoxyCodeLine{5563 \textcolor{preprocessor}{  GMOCK\_PP\_TAIL(                                     \(\backslash\)}}
\DoxyCodeLine{5564 \textcolor{preprocessor}{      GMOCK\_PP\_FOR\_EACH(GMOCK\_INTERNAL\_MATCHER\_TEMPLATE\_PARAM, , args))}}
\DoxyCodeLine{5565 \textcolor{preprocessor}{\#define GMOCK\_INTERNAL\_MATCHER\_TEMPLATE\_PARAM(i\_unused, data\_unused, arg) \(\backslash\)}}
\DoxyCodeLine{5566 \textcolor{preprocessor}{  , typename arg\#\#\_type}}
\DoxyCodeLine{5567 }
\DoxyCodeLine{5568 \textcolor{preprocessor}{\#define GMOCK\_INTERNAL\_MATCHER\_TYPE\_PARAMS(args) \(\backslash\)}}
\DoxyCodeLine{5569 \textcolor{preprocessor}{  GMOCK\_PP\_TAIL(GMOCK\_PP\_FOR\_EACH(GMOCK\_INTERNAL\_MATCHER\_TYPE\_PARAM, , args))}}
\DoxyCodeLine{5570 \textcolor{preprocessor}{\#define GMOCK\_INTERNAL\_MATCHER\_TYPE\_PARAM(i\_unused, data\_unused, arg) \(\backslash\)}}
\DoxyCodeLine{5571 \textcolor{preprocessor}{  , arg\#\#\_type}}
\DoxyCodeLine{5572 }
\DoxyCodeLine{5573 \textcolor{preprocessor}{\#define GMOCK\_INTERNAL\_MATCHER\_FUNCTION\_ARGS(args) \(\backslash\)}}
\DoxyCodeLine{5574 \textcolor{preprocessor}{  GMOCK\_PP\_TAIL(dummy\_first GMOCK\_PP\_FOR\_EACH(     \(\backslash\)}}
\DoxyCodeLine{5575 \textcolor{preprocessor}{      GMOCK\_INTERNAL\_MATCHER\_FUNCTION\_ARG, , args))}}
\DoxyCodeLine{5576 \textcolor{preprocessor}{\#define GMOCK\_INTERNAL\_MATCHER\_FUNCTION\_ARG(i, data\_unused, arg) \(\backslash\)}}
\DoxyCodeLine{5577 \textcolor{preprocessor}{  , arg\#\#\_type gmock\_p\#\#i}}
\DoxyCodeLine{5578 }
\DoxyCodeLine{5579 \textcolor{preprocessor}{\#define GMOCK\_INTERNAL\_MATCHER\_FORWARD\_ARGS(args) \(\backslash\)}}
\DoxyCodeLine{5580 \textcolor{preprocessor}{  GMOCK\_PP\_TAIL(GMOCK\_PP\_FOR\_EACH(GMOCK\_INTERNAL\_MATCHER\_FORWARD\_ARG, , args))}}
\DoxyCodeLine{5581 \textcolor{preprocessor}{\#define GMOCK\_INTERNAL\_MATCHER\_FORWARD\_ARG(i, data\_unused, arg) \(\backslash\)}}
\DoxyCodeLine{5582 \textcolor{preprocessor}{  , arg(::std::forward<arg\#\#\_type>(gmock\_p\#\#i))}}
\DoxyCodeLine{5583 }
\DoxyCodeLine{5584 \textcolor{preprocessor}{\#define GMOCK\_INTERNAL\_MATCHER\_MEMBERS(args) \(\backslash\)}}
\DoxyCodeLine{5585 \textcolor{preprocessor}{  GMOCK\_PP\_FOR\_EACH(GMOCK\_INTERNAL\_MATCHER\_MEMBER, , args)}}
\DoxyCodeLine{5586 \textcolor{preprocessor}{\#define GMOCK\_INTERNAL\_MATCHER\_MEMBER(i\_unused, data\_unused, arg) \(\backslash\)}}
\DoxyCodeLine{5587 \textcolor{preprocessor}{  const arg\#\#\_type arg;}}
\DoxyCodeLine{5588 }
\DoxyCodeLine{5589 \textcolor{preprocessor}{\#define GMOCK\_INTERNAL\_MATCHER\_MEMBERS\_USAGE(args) \(\backslash\)}}
\DoxyCodeLine{5590 \textcolor{preprocessor}{  GMOCK\_PP\_TAIL(GMOCK\_PP\_FOR\_EACH(GMOCK\_INTERNAL\_MATCHER\_MEMBER\_USAGE, , args))}}
\DoxyCodeLine{5591 \textcolor{preprocessor}{\#define GMOCK\_INTERNAL\_MATCHER\_MEMBER\_USAGE(i\_unused, data\_unused, arg) , arg}}
\DoxyCodeLine{5592 }
\DoxyCodeLine{5593 \textcolor{preprocessor}{\#define GMOCK\_INTERNAL\_MATCHER\_ARGS\_USAGE(args) \(\backslash\)}}
\DoxyCodeLine{5594 \textcolor{preprocessor}{  GMOCK\_PP\_TAIL(GMOCK\_PP\_FOR\_EACH(GMOCK\_INTERNAL\_MATCHER\_ARG\_USAGE, , args))}}
\DoxyCodeLine{5595 \textcolor{preprocessor}{\#define GMOCK\_INTERNAL\_MATCHER\_ARG\_USAGE(i, data\_unused, arg\_unused) \(\backslash\)}}
\DoxyCodeLine{5596 \textcolor{preprocessor}{  , gmock\_p\#\#i}}
\DoxyCodeLine{5597 }
\DoxyCodeLine{5598 \textcolor{comment}{// To prevent ADL on certain functions we put them on a separate namespace.}}
\DoxyCodeLine{5599 \textcolor{keyword}{using namespace }no\_adl;  \textcolor{comment}{// NOLINT}}
\DoxyCodeLine{5600 }
\DoxyCodeLine{5601 \}  \textcolor{comment}{// namespace testing}}
\DoxyCodeLine{5602 }
\DoxyCodeLine{5603 GTEST\_DISABLE\_MSC\_WARNINGS\_POP\_()  \textcolor{comment}{//  4251 5046}}
\DoxyCodeLine{5604 }
\DoxyCodeLine{5605 \textcolor{comment}{// Include any custom callback matchers added by the local installation.}}
\DoxyCodeLine{5606 \textcolor{comment}{// We must include this header at the end to make sure it can use the}}
\DoxyCodeLine{5607 \textcolor{comment}{// declarations from this file.}}
\DoxyCodeLine{5608 \textcolor{preprocessor}{\#include "{}gmock/internal/custom/gmock-\/matchers.h"{}}}
\DoxyCodeLine{5609 }
\DoxyCodeLine{5610 \textcolor{preprocessor}{\#endif  }\textcolor{comment}{// GOOGLEMOCK\_INCLUDE\_GMOCK\_GMOCK\_MATCHERS\_H\_}}

\end{DoxyCode}
